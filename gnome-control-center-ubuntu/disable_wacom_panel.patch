diff -Nru gnome-control-center-3.3.90.orig/configure.ac gnome-control-center-3.3.90/configure.ac
--- gnome-control-center-3.3.90.orig/configure.ac	2012-03-02 12:23:42.510387594 -0500
+++ gnome-control-center-3.3.90/configure.ac	2012-03-02 12:29:15.403728399 -0500
@@ -139,10 +139,6 @@
                   gnome-desktop-3.0
                   gdk-pixbuf-2.0 >= $GDKPIXBUF_REQUIRED_VERSION
                   $SYSTEMD)
-PKG_CHECK_MODULES(WACOM_PANEL, $COMMON_MODULES
-                  gnome-settings-daemon >= $GSD_REQUIRED_VERSION
-                  xi >= 1.2 x11 libwacom >= $LIBWACOM_REQUIRED_VERSION
-                  gnome-desktop-3.0 >= $GNOME_DESKTOP_REQUIRED_VERSION)
 
 GDESKTOP_PREFIX=`$PKG_CONFIG --variable prefix gsettings-desktop-schemas`
 AC_SUBST(GDESKTOP_PREFIX)
@@ -427,9 +423,6 @@
 panels/user-accounts/data/gnome-user-accounts-panel.desktop.in
 panels/user-accounts/data/faces/Makefile
 panels/user-accounts/data/icons/Makefile
-panels/wacom/Makefile
-panels/wacom/calibrator/Makefile
-panels/wacom/gnome-wacom-panel.desktop.in
 po/Makefile.in
 shell/Makefile
 shell/gnome-control-center.desktop.in
diff -Nru gnome-control-center-3.3.90.orig/panels/Makefile.am gnome-control-center-3.3.90/panels/Makefile.am
--- gnome-control-center-3.3.90.orig/panels/Makefile.am	2012-03-02 12:23:42.263720921 -0500
+++ gnome-control-center-3.3.90/panels/Makefile.am	2012-03-02 12:28:50.923727849 -0500
@@ -14,8 +14,7 @@
 	keyboard \
 	universal-access \
 	user-accounts \
-	datetime \
-	wacom
+	datetime
 
 if BUILD_PRINTERS
 SUBDIRS += printers
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/calibrator/Makefile.am gnome-control-center-3.3.90/panels/wacom/calibrator/Makefile.am
--- gnome-control-center-3.3.90.orig/panels/wacom/calibrator/Makefile.am	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/calibrator/Makefile.am	1969-12-31 19:00:00.000000000 -0500
@@ -1,37 +0,0 @@
-# This is used in PANEL_CFLAGS
-cappletname = wacom
-
-INCLUDES = 						\
-	$(PANEL_CFLAGS)					\
-	$(WACOM_PANEL_CFLAGS)				\
-	-DGNOMELOCALEDIR="\"$(datadir)/locale\""	\
-	-DGNOMECC_DATA_DIR="\"$(pkgdatadir)\""		\
-	-DGNOMECC_UI_DIR="\"$(uidir)\""			\
-	-DPIXMAP_DIR=\""$(datadir)/gnome-control-center/pixmaps"\"	\
-	$(NULL)
-
-
-noinst_LTLIBRARIES = libwacom-calibrator.la
-
-libwacom_calibrator_la_SOURCES =	\
-	calibrator.c			\
-	calibrator.h			\
-	gui_gtk.c			\
-	gui_gtk.h
-
-libwacom_calibrator_la_LIBADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS)
-libwacom_calibrator_la_LDFLAGS = $(PANEL_LDFLAGS)
-
-noinst_PROGRAMS = test-calibrator
-
-test_calibrator_SOURCES =		\
-	main.c				\
-	calibrator.c			\
-	calibrator.h			\
-	gui_gtk.c			\
-	gui_gtk.h
-
-test_calibrator_CPPFLAGS = $(INCLUDES)
-test_calibrator_LDADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS)
-
--include $(top_srcdir)/git.mk
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-mapping-panel.c gnome-control-center-3.3.90/panels/wacom/cc-wacom-mapping-panel.c
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-mapping-panel.c	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-mapping-panel.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,315 +0,0 @@
-/*
- * Copyright © 2012 Wacom.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Jason Gerecke <killertofu@gmail.com>
- *
- */
-
-#include <config.h>
-
-#include <gtk/gtk.h>
-#include <glib/gi18n.h>
-#define GNOME_DESKTOP_USE_UNSTABLE_API
-#include <libgnome-desktop/gnome-rr.h>
-#include <libgnome-desktop/gnome-rr-config.h>
-
-#include <string.h>
-
-#include "gsd-wacom-device.h"
-#include "cc-wacom-mapping-panel.h"
-
-G_DEFINE_TYPE (CcWacomMappingPanel, cc_wacom_mapping_panel, GTK_TYPE_BOX)
-
-#define WACOM_MAPPING_PANEL_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_MAPPING_PANEL, CcWacomMappingPanelPrivate))
-
-struct _CcWacomMappingPanelPrivate
-{
-	GsdWacomDevice *device;
-	GtkWidget      *label;
-	GtkWidget      *combobox;
-	GtkWidget      *checkbutton;
-};
-
-enum {
-	MONITOR_NAME_COLUMN,
-	MONITOR_NUM_COLUMN,
-	MONITOR_NUM_COLUMNS
-};
-
-static void combobox_changed_cb (GtkWidget *widget, CcWacomMappingPanel *self);
-static void checkbutton_toggled_cb (GtkWidget *widget, CcWacomMappingPanel *self);
-
-static GnomeRROutputInfo**
-get_rr_outputs (void)
-{
-	GError *error = NULL;
-	GnomeRRScreen *rr_screen;
-	GnomeRRConfig *rr_config;
-
-	/* TODO: Check the value of 'error' */
-	rr_screen = gnome_rr_screen_new (gdk_screen_get_default (), &error);
-	rr_config = gnome_rr_config_new_current (rr_screen, &error);
-	return gnome_rr_config_get_outputs (rr_config);
-}
-
-static void
-set_combobox_sensitive (CcWacomMappingPanel *self,
-			gboolean             sensitive)
-{
-	gtk_widget_set_sensitive (GTK_WIDGET(self->priv->combobox), sensitive);
-	gtk_widget_set_sensitive (GTK_WIDGET(self->priv->label), sensitive);
-}
-
-/* Update the display of available monitors based on the latest
- * information from RandR. At the moment the chooser is just a
- * a combobox crudely listing available outputs. The UI mockup
- * has something more akin to the Display panel, with the ability
- * to do rubber-band selection of multiple outputs (note: the
- * g-s-d backend can only handle a single output at the moment)
- */
-static void
-update_monitor_chooser (CcWacomMappingPanel *self)
-{
-	GtkListStore *store;
-	GnomeRROutputInfo **outputs;
-	GdkRectangle geom;
-	gint monitor;
-	gboolean single_mon;
-
-	store = gtk_list_store_new (MONITOR_NUM_COLUMNS, G_TYPE_STRING, G_TYPE_INT);
-	gtk_combo_box_set_model (GTK_COMBO_BOX(self->priv->combobox), GTK_TREE_MODEL(store));
-
-	if (self->priv->device == NULL) {
-		set_combobox_sensitive (self, FALSE);
-		g_object_unref (store);
-		return;
-	}
-
-	monitor = gsd_wacom_device_get_display_monitor (self->priv->device);
-	single_mon = (monitor != -1);
-
-	g_signal_handlers_block_by_func (G_OBJECT (self->priv->checkbutton), checkbutton_toggled_cb, self);
-	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(self->priv->checkbutton), single_mon);
-	g_signal_handlers_unblock_by_func (G_OBJECT (self->priv->checkbutton), checkbutton_toggled_cb, self);
-
-	/* FIXME: does this break screen tablets? What's the default
-	 * for unconfigured tablets? */
-	if (monitor < 0)
-		monitor = 0;
-	gdk_screen_get_monitor_geometry (gdk_screen_get_default (), monitor, &geom);
-
-	for (outputs = get_rr_outputs (); *outputs != NULL; outputs++) {
-		if (gnome_rr_output_info_is_active (*outputs)) {
-			GtkTreeIter iter;
-			gchar *name, *disp_name, *text;
-			int x, y, w, h;
-			int mon_at_point;
-
-			name = gnome_rr_output_info_get_name (*outputs);
-			disp_name = gnome_rr_output_info_get_display_name (*outputs);
-			text = g_strdup_printf ("%s (%s)", name, disp_name);
-
-			gnome_rr_output_info_get_geometry (*outputs, &x, &y, &w, &h);
-			mon_at_point = gdk_screen_get_monitor_at_point (gdk_screen_get_default (), x, y);
-			gtk_list_store_append (store, &iter);
-			gtk_list_store_set (store, &iter, MONITOR_NAME_COLUMN, text, MONITOR_NUM_COLUMN, mon_at_point, -1);
-
-			if (x == geom.x && y == geom.y && w == geom.width && h == geom.height) {
-				g_signal_handlers_block_by_func (G_OBJECT (self->priv->combobox), combobox_changed_cb, self);
-				gtk_combo_box_set_active_iter (GTK_COMBO_BOX(self->priv->combobox), &iter);
-				g_signal_handlers_unblock_by_func (G_OBJECT (self->priv->combobox), combobox_changed_cb, self);
-			}
-
-			g_free (text);
-		}
-	}
-
-	set_combobox_sensitive (self, single_mon);
-
-	g_object_unref (store);
-}
-
-static void
-update_ui (CcWacomMappingPanel *self)
-{
-	if (self->priv->device == NULL) {
-		gtk_widget_set_sensitive (GTK_WIDGET(self->priv->checkbutton), FALSE);
-		gtk_toggle_button_set_inconsistent (GTK_TOGGLE_BUTTON(self->priv->checkbutton), TRUE);
-	} else {
-		gboolean is_screen_tablet;
-
-		is_screen_tablet = gsd_wacom_device_is_screen_tablet (self->priv->device);
-		gtk_widget_set_sensitive (GTK_WIDGET(self->priv->checkbutton), !is_screen_tablet);
-		gtk_toggle_button_set_inconsistent (GTK_TOGGLE_BUTTON(self->priv->checkbutton), FALSE);
-	}
-
-	update_monitor_chooser (self);
-}
-
-static void
-update_mapping (CcWacomMappingPanel *self)
-{
-	int monitor = -1;
-
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (self->priv->checkbutton))) {
-		GtkTreeIter iter;
-		GtkTreeModel *model;
-		char *name;
-
-		model = gtk_combo_box_get_model (GTK_COMBO_BOX (self->priv->combobox));
-		if (!gtk_combo_box_get_active_iter (GTK_COMBO_BOX (self->priv->combobox), &iter)) {
-			g_warning ("Map to single monitor checked, but no screen selected.");
-			return;
-		}
-
-		gtk_tree_model_get (model, &iter, MONITOR_NAME_COLUMN, &name, MONITOR_NUM_COLUMN, &monitor, -1);
-	}
-
-	if (monitor != -1) {
-		gsd_wacom_device_set_display (self->priv->device, monitor);
-	} else {
-		/* FIXME: does this break screen tablets that aren't
-		 * on the first monitor */
-		gsd_wacom_device_set_display (self->priv->device, 0);
-	}
-}
-
-void
-cc_wacom_mapping_panel_set_device (CcWacomMappingPanel *self,
-                                   GsdWacomDevice *device)
-{
-	self->priv->device = device;
-	update_ui (self);
-}
-
-static void
-checkbutton_toggled_cb (GtkWidget           *widget,
-			CcWacomMappingPanel *self)
-{
-	gboolean active;
-
-	active = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget));
-	set_combobox_sensitive (self, active);
-	update_mapping (self);
-}
-
-static void
-combobox_changed_cb (GtkWidget           *widget,
-                     CcWacomMappingPanel *self)
-{
-	update_mapping (self);
-}
-
-static void
-cc_wacom_mapping_panel_init (CcWacomMappingPanel *self)
-{
-	CcWacomMappingPanelPrivate *priv;
-	GtkWidget *vbox, *hbox;
-	GtkCellRenderer *renderer;
-
-	priv = self->priv = WACOM_MAPPING_PANEL_PRIVATE (self);
-
-	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);
-	gtk_container_add (GTK_CONTAINER (self), vbox);
-	gtk_widget_set_vexpand (GTK_WIDGET (vbox), TRUE);
-	gtk_widget_set_hexpand (GTK_WIDGET (vbox), TRUE);
-
-	/* Output Combobox */
-	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 8);
-	priv->label = gtk_label_new ("Output:");
-	priv->combobox = gtk_combo_box_new ();
-	g_signal_connect (G_OBJECT (priv->combobox), "changed",
-	                      G_CALLBACK (combobox_changed_cb), self);
-	renderer = gtk_cell_renderer_text_new ();
-	gtk_cell_layout_pack_start (GTK_CELL_LAYOUT(priv->combobox), renderer, TRUE);
-	gtk_cell_layout_add_attribute (GTK_CELL_LAYOUT(priv->combobox), renderer, "text", 0);
-	gtk_box_pack_start (GTK_BOX(hbox), GTK_WIDGET(priv->label),
-				FALSE, FALSE, 8);
-	gtk_box_pack_start (GTK_BOX(hbox), GTK_WIDGET(priv->combobox),
-				FALSE, FALSE, 0);
-
-	/* Whole-desktop checkbox */
-	priv->checkbutton = gtk_check_button_new_with_label ("Map to single monitor");
-	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (priv->checkbutton), FALSE);
-	g_signal_connect (G_OBJECT (priv->checkbutton), "toggled",
-                      G_CALLBACK (checkbutton_toggled_cb), self);
-
-	gtk_box_pack_start (GTK_BOX(vbox), GTK_WIDGET(priv->checkbutton),
-				FALSE, FALSE, 0);
-	gtk_box_pack_start (GTK_BOX(vbox), GTK_WIDGET(hbox),
-				FALSE, FALSE, 8);
-
-	/* Update display */
-	cc_wacom_mapping_panel_set_device (self, NULL);
-	gtk_widget_show_all(GTK_WIDGET(self));
-}
-
-GtkWidget *
-cc_wacom_mapping_panel_new (void)
-{
-	CcWacomMappingPanel *panel;
-
-	panel = CC_WACOM_MAPPING_PANEL(g_object_new (CC_TYPE_WACOM_MAPPING_PANEL, NULL));
-	panel->priv->device = NULL;
-
-	return GTK_WIDGET(panel);
-}
-
-static void
-cc_wacom_mapping_panel_get_property (GObject    *object,
-                                     guint       property_id,
-                                     GValue     *value,
-                                     GParamSpec *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_mapping_panel_set_property (GObject      *object,
-                                     guint         property_id,
-                                     const GValue *value,
-                                     GParamSpec   *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_mapping_panel_dispose (GObject *object)
-{
-	G_OBJECT_CLASS (cc_wacom_mapping_panel_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_mapping_panel_class_init (CcWacomMappingPanelClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomMappingPanelPrivate));
-
-	object_class->get_property = cc_wacom_mapping_panel_get_property;
-	object_class->set_property = cc_wacom_mapping_panel_set_property;
-	object_class->dispose = cc_wacom_mapping_panel_dispose;
-}
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-mapping-panel.h gnome-control-center-3.3.90/panels/wacom/cc-wacom-mapping-panel.h
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-mapping-panel.h	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-mapping-panel.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,77 +0,0 @@
-/*
- * Copyright © 2012 Wacom.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Jason Gerecke <killertofu@gmail.com>
- *
- */
-
-#ifndef CC_WACOM_MAPPING_PANEL_H_
-#define CC_WACOM_MAPPING_PANEL_H_
-
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_MAPPING_PANEL cc_wacom_mapping_panel_get_type()
-
-#define CC_WACOM_MAPPING_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_MAPPING_PANEL, CcWacomMappingPanel))
-
-#define CC_WACOM_MAPPING_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_MAPPING_PANEL, CcWacomMappignPanelClass))
-
-#define CC_IS_WACOM_MAPPING_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_MAPPING_PANEL))
-
-#define CC_IS_WACOM_MAPPING_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_MAPPING_PANEL))
-
-#define CC_WACOM_MAPPING_PANEL_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_MAPPING_PANEL, CcWacomMappingPanelClass))
-
-typedef struct _CcWacomMappingPanel CcWacomMappingPanel;
-typedef struct _CcWacomMappingPanelClass CcWacomMappingPanelClass;
-typedef struct _CcWacomMappingPanelPrivate CcWacomMappingPanelPrivate;
-
-struct _CcWacomMappingPanel
-{
-  GtkBox parent;
-
-  CcWacomMappingPanelPrivate *priv;
-};
-
-struct _CcWacomMappingPanelClass
-{
-  GtkBoxClass parent_class;
-};
-
-GType cc_wacom_mapping_panel_get_type (void) G_GNUC_CONST;
-
-GtkWidget * cc_wacom_mapping_panel_new (void);
-
-
-void cc_wacom_mapping_panel_set_device (CcWacomMappingPanel *self,
-                                        GsdWacomDevice *device);
-
-G_END_DECLS
-
-#endif /* CC_WACOM_MAPPING_PANEL_H_ */
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-nav-button.c gnome-control-center-3.3.90/panels/wacom/cc-wacom-nav-button.c
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-nav-button.c	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-nav-button.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,258 +0,0 @@
-/*
- * Copyright © 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include <config.h>
-
-#include <glib/gi18n.h>
-#include <gtk/gtk.h>
-
-#include "cc-wacom-nav-button.h"
-
-G_DEFINE_TYPE (CcWacomNavButton, cc_wacom_nav_button, GTK_TYPE_BOX)
-
-#define WACOM_NAV_BUTTON_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_NAV_BUTTON, CcWacomNavButtonPrivate))
-
-struct _CcWacomNavButtonPrivate
-{
-	GtkNotebook *notebook;
-	GtkWidget   *label;
-	GtkWidget   *prev;
-	GtkWidget   *next;
-	guint        page_added_id;
-	guint        page_removed_id;
-	guint        page_switched_id;
-	gboolean     ignore_first_page;
-};
-
-enum {
-	PROP_0,
-	PROP_NOTEBOOK,
-	PROP_IGNORE_FIRST
-};
-
-static void
-cc_wacom_nav_button_update (CcWacomNavButton *nav)
-{
-	CcWacomNavButtonPrivate *priv = nav->priv;
-	int num_pages;
-	int current_page;
-	char *text;
-
-	if (priv->notebook == NULL) {
-		gtk_widget_hide (GTK_WIDGET (nav));
-		return;
-	}
-
-	num_pages = gtk_notebook_get_n_pages (GTK_NOTEBOOK (priv->notebook));
-	if (num_pages == 0)
-		return;
-	if (priv->ignore_first_page && num_pages == 1)
-		return;
-
-	if (priv->ignore_first_page)
-		num_pages--;
-
-	g_assert (num_pages >= 1);
-
-	if (num_pages == 1)
-		gtk_widget_hide (GTK_WIDGET (nav));
-	else
-		gtk_widget_show (GTK_WIDGET (nav));
-
-	current_page = gtk_notebook_get_current_page (GTK_NOTEBOOK (priv->notebook));
-	if (current_page < 0)
-		return;
-	if (priv->ignore_first_page)
-		current_page--;
-	gtk_widget_set_sensitive (priv->prev, current_page == 0 ? FALSE : TRUE);
-	gtk_widget_set_sensitive (priv->next, current_page + 1 == num_pages ? FALSE : TRUE);
-
-	text = g_strdup_printf (_("%d of %d"),
-				current_page + 1,
-				num_pages);
-	gtk_label_set_text (GTK_LABEL (priv->label), text);
-}
-
-static void
-pages_changed (GtkNotebook      *notebook,
-	       GtkWidget        *child,
-	       guint             page_num,
-	       CcWacomNavButton *nav)
-{
-	cc_wacom_nav_button_update (nav);
-}
-
-static void
-page_switched (GtkNotebook      *notebook,
-	       GParamSpec       *pspec,
-	       CcWacomNavButton *nav)
-{
-	cc_wacom_nav_button_update (nav);
-}
-
-static void
-next_clicked (GtkButton        *button,
-	      CcWacomNavButton *nav)
-{
-	int current_page;
-
-	current_page = gtk_notebook_get_current_page (GTK_NOTEBOOK (nav->priv->notebook));
-	current_page++;
-	gtk_notebook_set_current_page (GTK_NOTEBOOK (nav->priv->notebook), current_page);
-}
-
-static void
-prev_clicked (GtkButton        *button,
-	      CcWacomNavButton *nav)
-{
-	int current_page;
-
-	current_page = gtk_notebook_get_current_page (GTK_NOTEBOOK (nav->priv->notebook));
-	current_page--;
-	gtk_notebook_set_current_page (GTK_NOTEBOOK (nav->priv->notebook), current_page--);
-}
-
-static void
-cc_wacom_nav_button_set_property (GObject      *object,
-				  guint         property_id,
-				  const GValue *value,
-				  GParamSpec   *pspec)
-{
-	CcWacomNavButton *nav = CC_WACOM_NAV_BUTTON (object);
-	CcWacomNavButtonPrivate *priv = nav->priv;
-
-	switch (property_id) {
-	case PROP_NOTEBOOK:
-		if (priv->notebook) {
-			g_signal_handler_disconnect (priv->notebook, priv->page_added_id);
-			g_signal_handler_disconnect (priv->notebook, priv->page_removed_id);
-			g_signal_handler_disconnect (priv->notebook, priv->page_switched_id);
-			g_object_unref (priv->notebook);
-		}
-		priv->notebook = g_value_dup_object (value);
-		priv->page_added_id = g_signal_connect (G_OBJECT (priv->notebook), "page-added",
-							G_CALLBACK (pages_changed), nav);
-		priv->page_removed_id = g_signal_connect (G_OBJECT (priv->notebook), "page-removed",
-							  G_CALLBACK (pages_changed), nav);
-		priv->page_switched_id = g_signal_connect (G_OBJECT (priv->notebook), "notify::page",
-							   G_CALLBACK (page_switched), nav);
-		cc_wacom_nav_button_update (nav);
-		break;
-	case PROP_IGNORE_FIRST:
-		priv->ignore_first_page = g_value_get_boolean (value);
-		cc_wacom_nav_button_update (nav);
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_nav_button_dispose (GObject *object)
-{
-	CcWacomNavButtonPrivate *priv = CC_WACOM_NAV_BUTTON (object)->priv;
-
-	if (priv->notebook) {
-		g_signal_handler_disconnect (priv->notebook, priv->page_added_id);
-		priv->page_added_id = 0;
-		g_signal_handler_disconnect (priv->notebook, priv->page_removed_id);
-		priv->page_removed_id = 0;
-		g_signal_handler_disconnect (priv->notebook, priv->page_switched_id);
-		priv->page_switched_id = 0;
-		g_object_unref (priv->notebook);
-		priv->notebook = NULL;
-	}
-
-	G_OBJECT_CLASS (cc_wacom_nav_button_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_nav_button_class_init (CcWacomNavButtonClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomNavButtonPrivate));
-
-	object_class->set_property = cc_wacom_nav_button_set_property;
-	object_class->dispose = cc_wacom_nav_button_dispose;
-
-	g_object_class_install_property (object_class, PROP_NOTEBOOK,
-					 g_param_spec_object ("notebook", "notebook", "notebook",
-							      GTK_TYPE_NOTEBOOK,
-							      G_PARAM_WRITABLE));
-	g_object_class_install_property (object_class, PROP_IGNORE_FIRST,
-					 g_param_spec_boolean ("ignore-first", "ignore-first", "ignore-first",
-							       FALSE,
-							       G_PARAM_WRITABLE));
-}
-
-static void
-cc_wacom_nav_button_init (CcWacomNavButton *self)
-{
-	CcWacomNavButtonPrivate *priv;
-	GtkStyleContext *context;
-	GtkWidget *image, *box;
-
-	priv = self->priv = WACOM_NAV_BUTTON_PRIVATE (self);
-
-	/* Label */
-	priv->label = gtk_label_new (NULL);
-	gtk_style_context_add_class (gtk_widget_get_style_context (priv->label), "dim-label");
-	gtk_box_pack_start (GTK_BOX (self), priv->label,
-			    FALSE, FALSE, 8);
-
-	box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
-	context = gtk_widget_get_style_context (GTK_WIDGET (box));
-	gtk_style_context_add_class (context, GTK_STYLE_CLASS_LINKED);
-	gtk_box_pack_start (GTK_BOX (self), box,
-			    FALSE, FALSE, 8);
-
-	/* Prev button */
-	priv->prev = gtk_button_new ();
-	image = gtk_image_new_from_icon_name ("go-previous-symbolic", GTK_ICON_SIZE_MENU);
-	gtk_container_add (GTK_CONTAINER (priv->prev), image);
-	g_signal_connect (G_OBJECT (priv->prev), "clicked",
-			  G_CALLBACK (prev_clicked), self);
-	gtk_widget_set_valign (priv->prev, GTK_ALIGN_CENTER);
-
-	/* Next button */
-	priv->next = gtk_button_new ();
-	image = gtk_image_new_from_icon_name ("go-next-symbolic", GTK_ICON_SIZE_MENU);
-	gtk_container_add (GTK_CONTAINER (priv->next), image);
-	g_signal_connect (G_OBJECT (priv->next), "clicked",
-			  G_CALLBACK (next_clicked), self);
-	gtk_widget_set_valign (priv->next, GTK_ALIGN_CENTER);
-
-	gtk_box_pack_start (GTK_BOX (box), priv->prev,
-			    FALSE, FALSE, 0);
-	gtk_box_pack_start (GTK_BOX (box), priv->next,
-			    FALSE, FALSE, 0);
-
-	gtk_widget_show (priv->label);
-	gtk_widget_show_all (box);
-}
-
-GtkWidget *
-cc_wacom_nav_button_new (void)
-{
-	return GTK_WIDGET (g_object_new (CC_TYPE_WACOM_NAV_BUTTON, NULL));
-}
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-nav-button.h gnome-control-center-3.3.90/panels/wacom/cc-wacom-nav-button.h
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-nav-button.h	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-nav-button.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,73 +0,0 @@
-/*
- * Copyright © 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Bastien Nocera <hadess@hadess.net>
- */
-
-
-#ifndef _CC_WACOM_NAV_BUTTON_H
-#define _CC_WACOM_NAV_BUTTON_H
-
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_NAV_BUTTON cc_wacom_nav_button_get_type()
-
-#define CC_WACOM_NAV_BUTTON(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_NAV_BUTTON, CcWacomNavButton))
-
-#define CC_WACOM_NAV_BUTTON_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_NAV_BUTTON, CcWacomNavButtonClass))
-
-#define CC_IS_WACOM_NAV_BUTTON(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_NAV_BUTTON))
-
-#define CC_IS_WACOM_NAV_BUTTON_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_NAV_BUTTON))
-
-#define CC_WACOM_NAV_BUTTON_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_NAV_BUTTON, CcWacomNavButtonClass))
-
-typedef struct _CcWacomNavButton CcWacomNavButton;
-typedef struct _CcWacomNavButtonClass CcWacomNavButtonClass;
-typedef struct _CcWacomNavButtonPrivate CcWacomNavButtonPrivate;
-
-struct _CcWacomNavButton
-{
-  GtkBox parent;
-
-  CcWacomNavButtonPrivate *priv;
-};
-
-struct _CcWacomNavButtonClass
-{
-  GtkBoxClass parent_class;
-};
-
-GType cc_wacom_nav_button_get_type (void) G_GNUC_CONST;
-
-GtkWidget * cc_wacom_nav_button_new (void);
-
-G_END_DECLS
-
-#endif /* _CC_WACOM_NAV_BUTTON_H */
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-page.c gnome-control-center-3.3.90/panels/wacom/cc-wacom-page.c
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-page.c	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-page.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1006 +0,0 @@
-/*
- * Copyright © 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include <config.h>
-
-#include <glib/gi18n-lib.h>
-#include <gtk/gtk.h>
-
-#include "cc-wacom-page.h"
-#include "cc-wacom-nav-button.h"
-#include "cc-wacom-mapping-panel.h"
-#include "cc-wacom-stylus-page.h"
-#include "gsd-enums.h"
-#include "gui_gtk.h"
-
-#include <string.h>
-
-#define WID(x) (GtkWidget *) gtk_builder_get_object (priv->builder, x)
-#define CWID(x) (GtkContainer *) gtk_builder_get_object (priv->builder, x)
-#define MWID(x) (GtkWidget *) gtk_builder_get_object (priv->mapping_builder, x)
-
-G_DEFINE_TYPE (CcWacomPage, cc_wacom_page, GTK_TYPE_BOX)
-
-#define WACOM_PAGE_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_PAGE, CcWacomPagePrivate))
-
-#define THRESHOLD_MISCLICK	15
-#define THRESHOLD_DOUBLECLICK	7
-
-#define ACTION_TYPE_KEY         "action-type"
-#define CUSTOM_ACTION_KEY       "custom-action"
-
-enum {
-	MAPPING_DESCRIPTION_COLUMN,
-	MAPPING_BUTTON_COLUMN,
-	MAPPING_N_COLUMNS
-};
-
-struct _CcWacomPagePrivate
-{
-	CcWacomPanel   *panel;
-	GsdWacomDevice *stylus, *eraser, *pad;
-	GtkBuilder     *builder;
-	GtkWidget      *nav;
-	GtkWidget      *notebook;
-	CalibArea      *area;
-	GSettings      *wacom_settings;
-
-	/* Button mapping */
-	GtkBuilder     *mapping_builder;
-
-	/* Display mapping */
-	GtkWidget      *mapping;
-	GtkWidget      *dialog;
-};
-
-/* Button combo box storage columns */
-enum {
-	BUTTONNUMBER_COLUMN,
-	BUTTONNAME_COLUMN,
-	N_BUTTONCOLUMNS
-};
-
-/* Tablet mode combo box storage columns */
-enum {
-	MODENUMBER_COLUMN,
-	MODELABEL_COLUMN,
-	N_MODECOLUMNS
-};
-
-/* Tablet mode options - keep in sync with .ui */
-enum {
-	MODE_ABSOLUTE, /* stylus + eraser absolute */
-	MODE_RELATIVE, /* stylus + eraser relative */
-};
-
-static void
-set_calibration (gint      *cal,
-                 gsize      ncal,
-                 GSettings *settings)
-{
-	GVariant    *current; /* current calibration */
-	GVariant    *array;   /* new calibration */
-	GVariant   **tmp;
-	gsize        nvalues;
-	int          i;
-
-	current = g_settings_get_value (settings, "area");
-	g_variant_get_fixed_array (current, &nvalues, sizeof (gint32));
-	if ((ncal != 4) || (nvalues != 4)) {
-		g_warning("Unable set set device calibration property. Got %"G_GSIZE_FORMAT" items to put in %"G_GSIZE_FORMAT" slots; expected %d items.\n", ncal, nvalues, 4);
-		return;
-	}
-
-	tmp = g_malloc (nvalues * sizeof (GVariant*));
-	for (i = 0; i < ncal; i++)
-		tmp[i] = g_variant_new_int32 (cal[i]);
-
-	array = g_variant_new_array (G_VARIANT_TYPE_INT32, tmp, nvalues);
-	g_settings_set_value (settings, "area", array);
-
-	g_free (tmp);
-	g_variant_unref (array);
-}
-
-static void
-finish_calibration (CalibArea *area,
-		    gpointer   user_data)
-{
-	CcWacomPage *page = (CcWacomPage *) user_data;
-	CcWacomPagePrivate *priv = page->priv;
-	XYinfo axis;
-	gboolean swap_xy;
-	int cal[4];
-
-	if (calib_area_finish (area, &axis, &swap_xy)) {
-		cal[0] = axis.x_min;
-		cal[1] = axis.y_min;
-		cal[2] = axis.x_max;
-		cal[3] = axis.y_max;
-
-		set_calibration(cal, 4, page->priv->wacom_settings);
-	}
-
-	calib_area_free (area);
-	page->priv->area = NULL;
-	gtk_widget_set_sensitive (WID ("button-calibrate"), TRUE);
-}
-
-static gboolean
-run_calibration (CcWacomPage *page,
-		 gint        *cal,
-		 gint         monitor)
-{
-	XYinfo old_axis;
-
-	g_assert (page->priv->area == NULL);
-
-	old_axis.x_min = cal[0];
-	old_axis.y_min = cal[1];
-	old_axis.x_max = cal[2];
-	old_axis.y_max = cal[3];
-
-	page->priv->area = calib_area_new (NULL,
-					   monitor,
-					   finish_calibration,
-					   page,
-					   &old_axis,
-					   THRESHOLD_MISCLICK,
-					   THRESHOLD_DOUBLECLICK);
-
-	return FALSE;
-}
-
-static void
-calibrate_button_clicked_cb (GtkButton   *button,
-			     CcWacomPage *page)
-{
-	int i, calibration[4];
-	GVariant *variant;
-	int *current;
-	gsize ncal;
-	gint monitor;
-
-	monitor = gsd_wacom_device_get_display_monitor (page->priv->stylus);
-	if (monitor < 0) {
-		/* The display the tablet should be mapped to could not be located.
-		 * This shouldn't happen if the EDID data is good...
-		 */
-		g_critical("Output associated with the tablet is not connected. Unable to calibrate.");
-		return;
-	}
-
-	variant = g_settings_get_value (page->priv->wacom_settings, "area");
-	current = (int *) g_variant_get_fixed_array (variant, &ncal, sizeof (gint32));
-
-	if (ncal != 4) {
-		g_warning("Device calibration property has wrong length. Got %"G_GSIZE_FORMAT" items; expected %d.\n", ncal, 4);
-		g_free (current);
-		return;
-	}
-
-	for (i = 0; i < 4; i++)
-		calibration[i] = current[i];
-
-	if (calibration[0] == -1 &&
-	    calibration[1] == -1 &&
-	    calibration[2] == -1 &&
-	    calibration[3] == -1) {
-		gint *device_cal;
-		device_cal = gsd_wacom_device_get_area (page->priv->stylus);
-		for (i = 0; i < 4; i++)
-			calibration[i] = device_cal[i];
-		g_free (device_cal);
-	}
-
-	run_calibration (page, calibration, monitor);
-	gtk_widget_set_sensitive (GTK_WIDGET (button), FALSE);
-}
-
-static void
-accel_set_func (GtkTreeViewColumn *tree_column,
-		GtkCellRenderer   *cell,
-		GtkTreeModel      *model,
-		GtkTreeIter       *iter,
-		gpointer           data)
-{
-	GsdWacomTabletButton *button;
-	GsdWacomActionType type;
-	char *str;
-	guint keyval;
-	guint mask;
-
-	gtk_tree_model_get (model, iter,
-			    MAPPING_BUTTON_COLUMN, &button,
-			    -1);
-
-	if (button == NULL) {
-		g_object_set (cell,
-			      "visible", FALSE,
-			      NULL);
-		return;
-	}
-
-	if (button->type == WACOM_TABLET_BUTTON_TYPE_HARDCODED) {
-		g_object_set (cell,
-			      "visible", TRUE,
-			      "editable", FALSE,
-			      "accel-key", 0,
-			      "accel-mods", 0,
-			      "style", PANGO_STYLE_NORMAL,
-			      "text", _("Switch Modes"),
-			      NULL);
-		return;
-	}
-
-	if (button->settings == NULL) {
-		g_warning ("Button '%s' does not have an associated GSettings", button->id);
-		return;
-	}
-
-	type = g_settings_get_enum (button->settings, ACTION_TYPE_KEY);
-	if (type == GSD_WACOM_ACTION_TYPE_NONE) {
-		g_object_set (cell,
-			      "visible", TRUE,
-			      "editable", TRUE,
-			      "accel-key", 0,
-			      "accel-mods", 0,
-			      "style", PANGO_STYLE_NORMAL,
-			      "text", _("None"),
-			      NULL);
-		return;
-	}
-
-	str = g_settings_get_string (button->settings, CUSTOM_ACTION_KEY);
-	gtk_accelerator_parse (str, &keyval, &mask);
-	g_free (str);
-
-	g_object_set (cell,
-		      "visible", TRUE,
-		      "editable", TRUE,
-		      "accel-key", keyval,
-		      "accel-mods", mask,
-		      "style", PANGO_STYLE_NORMAL,
-		      NULL);
-}
-
-static gboolean
-start_editing_cb (GtkTreeView    *tree_view,
-		  GdkEventButton *event,
-		  gpointer        user_data)
-{
-	GtkTreePath *path;
-	GtkTreeViewColumn *column;
-
-	if (event->window != gtk_tree_view_get_bin_window (tree_view))
-		return FALSE;
-
-	if (gtk_tree_view_get_path_at_pos (tree_view,
-					   (gint) event->x,
-					   (gint) event->y,
-					   &path, &column,
-					   NULL, NULL))
-	{
-		GtkTreeModel *model;
-		GtkTreeIter iter;
-		GsdWacomTabletButton *button;
-
-		model = gtk_tree_view_get_model (tree_view);
-		gtk_tree_model_get_iter (model, &iter, path);
-		gtk_tree_model_get (model, &iter,
-				    MAPPING_BUTTON_COLUMN, &button,
-				    -1);
-
-		gtk_widget_grab_focus (GTK_WIDGET (tree_view));
-		gtk_tree_view_set_cursor (tree_view,
-					  path,
-					  gtk_tree_view_get_column (tree_view, 1),
-					  TRUE);
-		g_signal_stop_emission_by_name (tree_view, "button_press_event");
-		gtk_tree_path_free (path);
-	}
-	return TRUE;
-}
-
-static void
-start_editing_kb_cb (GtkTreeView *treeview,
-                          GtkTreePath *path,
-                          GtkTreeViewColumn *column,
-                          gpointer user_data)
-{
-  GtkTreeModel *model;
-  GtkTreeIter iter;
-  GsdWacomTabletButton *button;
-
-  model = gtk_tree_view_get_model (treeview);
-  gtk_tree_model_get_iter (model, &iter, path);
-  gtk_tree_model_get (model, &iter,
-                      MAPPING_BUTTON_COLUMN, &button,
-                      -1);
-
-  gtk_widget_grab_focus (GTK_WIDGET (treeview));
-  gtk_tree_view_set_cursor (treeview,
-			    path,
-			    gtk_tree_view_get_column (treeview, 1),
-			    TRUE);
-}
-
-static void
-accel_edited_callback (GtkCellRendererText   *cell,
-                       const char            *path_string,
-                       guint                  keyval,
-                       GdkModifierType        mask,
-                       guint                  keycode,
-                       CcWacomPage           *page)
-{
-  GtkTreeModel *model;
-  GtkTreePath *path = gtk_tree_path_new_from_string (path_string);
-  GtkTreeView *view;
-  GtkTreeIter iter;
-  CcWacomPagePrivate *priv;
-  GsdWacomTabletButton *button;
-  char *str;
-
-  priv = page->priv;
-  view = GTK_TREE_VIEW (MWID("shortcut_treeview"));
-  model = gtk_tree_view_get_model (view);
-  gtk_tree_model_get_iter (model, &iter, path);
-  gtk_tree_path_free (path);
-  gtk_tree_model_get (model, &iter,
-		      MAPPING_BUTTON_COLUMN, &button,
-                      -1);
-
-  /* sanity check */
-  if (button == NULL)
-    return;
-
-  /* CapsLock isn't supported as a keybinding modifier, so keep it from confusing us */
-  mask &= ~GDK_LOCK_MASK;
-
-  str = gtk_accelerator_name (keyval, mask);
-  g_settings_set_string (button->settings, CUSTOM_ACTION_KEY, str);
-  g_settings_set_enum (button->settings, ACTION_TYPE_KEY, GSD_WACOM_ACTION_TYPE_CUSTOM);
-  g_free (str);
-}
-
-static void
-accel_cleared_callback (GtkCellRendererText *cell,
-                        const char          *path_string,
-                        CcWacomPage         *page)
-{
-  GtkTreeView *view;
-  GtkTreePath *path = gtk_tree_path_new_from_string (path_string);
-  GtkTreeIter iter;
-  GtkTreeModel *model;
-  GsdWacomTabletButton *button;
-  CcWacomPagePrivate *priv;
-
-  priv = page->priv;
-  view = GTK_TREE_VIEW (MWID("shortcut_treeview"));
-  model = gtk_tree_view_get_model (view);
-  gtk_tree_model_get_iter (model, &iter, path);
-  gtk_tree_path_free (path);
-  gtk_tree_model_get (model, &iter,
-		      MAPPING_BUTTON_COLUMN, &button,
-                      -1);
-
-  /* sanity check */
-  if (button == NULL)
-    return;
-
-  /* Unset the key */
-  g_settings_set_enum (button->settings, ACTION_TYPE_KEY, GSD_WACOM_ACTION_TYPE_NONE);
-  g_settings_set_string (button->settings, CUSTOM_ACTION_KEY, "");
-}
-
-static void
-setup_mapping_treeview (CcWacomPage *page)
-{
-	CcWacomPagePrivate *priv;
-	GtkTreeView *treeview;
-	GtkCellRenderer *renderer;
-	GtkTreeViewColumn *column;
-	GtkListStore *model;
-	GList *list, *l;
-
-	priv = page->priv;
-	treeview = GTK_TREE_VIEW(MWID ("shortcut_treeview"));
-
-	g_signal_connect (treeview, "button_press_event",
-			  G_CALLBACK (start_editing_cb), page);
-	g_signal_connect (treeview, "row-activated",
-			  G_CALLBACK (start_editing_kb_cb), page);
-
-	renderer = gtk_cell_renderer_text_new ();
-	g_object_set (G_OBJECT (renderer), "ellipsize", PANGO_ELLIPSIZE_END, NULL);
-
-	column = gtk_tree_view_column_new_with_attributes (_("Button"),
-							   renderer,
-							   "text", MAPPING_DESCRIPTION_COLUMN,
-							   NULL);
-	gtk_tree_view_column_set_resizable (column, FALSE);
-	gtk_tree_view_column_set_expand (column, TRUE);
-
-	gtk_tree_view_append_column (treeview, column);
-	gtk_tree_view_column_set_sort_column_id (column, MAPPING_DESCRIPTION_COLUMN);
-
-	renderer = (GtkCellRenderer *) g_object_new (GTK_TYPE_CELL_RENDERER_ACCEL,
-						     "accel-mode", GTK_CELL_RENDERER_ACCEL_MODE_OTHER,
-						     NULL);
-
-	g_signal_connect (renderer, "accel_edited",
-			  G_CALLBACK (accel_edited_callback),
-			  page);
-	g_signal_connect (renderer, "accel_cleared",
-			  G_CALLBACK (accel_cleared_callback),
-			  page);
-
-	column = gtk_tree_view_column_new_with_attributes (_("Action"), renderer, NULL);
-	gtk_tree_view_column_set_cell_data_func (column, renderer, accel_set_func, NULL, NULL);
-	gtk_tree_view_column_set_resizable (column, FALSE);
-	gtk_tree_view_column_set_expand (column, FALSE);
-
-	gtk_tree_view_append_column (treeview, column);
-
-	model = gtk_list_store_new (MAPPING_N_COLUMNS, G_TYPE_STRING, G_TYPE_POINTER);
-	gtk_tree_view_set_model (treeview, GTK_TREE_MODEL (model));
-
-	/* Fill it up! */
-	list = gsd_wacom_device_get_buttons (page->priv->pad);
-	for (l = list; l != NULL; l = l->next) {
-		GsdWacomTabletButton *button = l->data;
-		GtkTreeIter new_row;
-
-		/* FIXME
-		 * We need to handle up/down buttons, such as the touchrings */
-		if (button->type == WACOM_TABLET_BUTTON_TYPE_ELEVATOR)
-			continue;
-
-		gtk_list_store_append (model, &new_row);
-		gtk_list_store_set (model, &new_row,
-				    MAPPING_DESCRIPTION_COLUMN, button->name,
-				    MAPPING_BUTTON_COLUMN, button,
-				    -1);
-	}
-	g_list_free (list);
-	g_object_unref (model);
-}
-
-static void
-button_mapping_dialog_closed (GtkDialog   *dialog,
-			      int          response_id,
-			      CcWacomPage *page)
-{
-	CcWacomPagePrivate *priv;
-
-	priv = page->priv;
-	gtk_widget_destroy (MWID ("button-mapping-dialog"));
-	g_object_unref (page->priv->mapping_builder);
-	page->priv->mapping_builder = NULL;
-}
-
-static void
-map_buttons_button_clicked_cb (GtkButton   *button,
-			       CcWacomPage *page)
-{
-	GError *error = NULL;
-	GtkWidget *dialog;
-	CcWacomPagePrivate *priv;
-	GtkWidget *toplevel;
-
-	priv = page->priv;
-
-	g_assert (priv->mapping_builder == NULL);
-	priv->mapping_builder = gtk_builder_new ();
-	gtk_builder_add_from_file (priv->mapping_builder,
-				   GNOMECC_UI_DIR "/button-mapping.ui",
-				   &error);
-
-	if (error != NULL) {
-		g_warning ("Error loading UI file: %s", error->message);
-		g_object_unref (priv->mapping_builder);
-		priv->mapping_builder = NULL;
-		g_error_free (error);
-		return;
-	}
-
-	setup_mapping_treeview (page);
-
-	dialog = MWID ("button-mapping-dialog");
-	toplevel = gtk_widget_get_toplevel (GTK_WIDGET (page));
-	gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (toplevel));
-	gtk_window_set_modal (GTK_WINDOW (dialog), TRUE);
-	g_signal_connect (G_OBJECT (dialog), "response",
-			  G_CALLBACK (button_mapping_dialog_closed), page);
-
-	gtk_widget_show (dialog);
-}
-
-static void
-display_mapping_dialog_closed (GtkDialog   *dialog,
-			       int          response_id,
-			       CcWacomPage *page)
-{
-	CcWacomPagePrivate *priv;
-
-	priv = page->priv;
-	gtk_widget_destroy (priv->dialog);
-	priv->dialog = NULL;
-	priv->mapping = NULL;
-}
-
-static void
-display_mapping_button_clicked_cb (GtkButton   *button,
-				   CcWacomPage *page)
-{
-	CcWacomPagePrivate *priv;
-
-	priv = page->priv;
-
-	g_assert (priv->mapping == NULL);
-
-	priv->dialog = gtk_dialog_new_with_buttons (_("Display Mapping"),
-						    GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (page))),
-						    GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
-						    GTK_STOCK_CLOSE,
-						    GTK_RESPONSE_ACCEPT,
-						    NULL);
-	priv->mapping = cc_wacom_mapping_panel_new ();
-	cc_wacom_mapping_panel_set_device (CC_WACOM_MAPPING_PANEL (priv->mapping),
-					   priv->stylus);
-	gtk_container_add (GTK_CONTAINER (gtk_dialog_get_content_area (GTK_DIALOG (priv->dialog))),
-			   priv->mapping);
-	g_signal_connect (G_OBJECT (priv->dialog), "response",
-			  G_CALLBACK (display_mapping_dialog_closed), page);
-	gtk_widget_show_all (priv->dialog);
-}
-
-static void
-tabletmode_changed_cb (GtkComboBox *combo, gpointer user_data)
-{
-	CcWacomPagePrivate	*priv	= CC_WACOM_PAGE(user_data)->priv;
-	GtkListStore		*liststore;
-	GtkTreeIter		iter;
-	gint			mode;
-	gboolean		is_absolute;
-
-	if (!gtk_combo_box_get_active_iter (combo, &iter))
-		return;
-
-	liststore = GTK_LIST_STORE (WID ("liststore-tabletmode"));
-	gtk_tree_model_get (GTK_TREE_MODEL (liststore), &iter,
-			    MODENUMBER_COLUMN, &mode,
-			    -1);
-
-	is_absolute = (mode == MODE_ABSOLUTE);
-	g_settings_set_boolean (priv->wacom_settings, "is-absolute", is_absolute);
-}
-
-static void
-left_handed_toggled_cb (GtkSwitch *sw, GParamSpec *pspec, gpointer *user_data)
-{
-	CcWacomPagePrivate	*priv = CC_WACOM_PAGE(user_data)->priv;
-	const gchar*		rotation;
-
-	rotation = gtk_switch_get_active (sw) ? "half" : "none";
-
-	g_settings_set_string (priv->wacom_settings, "rotation", rotation);
-}
-
-static void
-set_left_handed_from_gsettings (CcWacomPage *page)
-{
-	CcWacomPagePrivate	*priv = CC_WACOM_PAGE(page)->priv;
-	const gchar*		rotation;
-
-	rotation = g_settings_get_string (priv->wacom_settings, "rotation");
-	if (strcmp (rotation, "half") == 0)
-		gtk_switch_set_active (GTK_SWITCH (WID ("switch-left-handed")), TRUE);
-}
-
-static void
-set_mode_from_gsettings (GtkComboBox *combo, CcWacomPage *page)
-{
-	CcWacomPagePrivate	*priv = page->priv;
-	gboolean		is_absolute;
-
-	is_absolute = g_settings_get_boolean (priv->wacom_settings, "is-absolute");
-
-	/* this must be kept in sync with the .ui file */
-	gtk_combo_box_set_active (combo, is_absolute ? MODE_ABSOLUTE : MODE_RELATIVE);
-}
-
-static void
-combobox_text_cellrenderer (GtkComboBox *combo, int name_column)
-{
-	GtkCellRenderer	*renderer;
-
-	renderer = gtk_cell_renderer_text_new ();
-	gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo), renderer, TRUE);
-	gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo), renderer,
-					"text", BUTTONNAME_COLUMN, NULL);
-}
-
-static gboolean
-display_clicked_cb (GtkButton   *button,
-		    CcWacomPage *page)
-{
-	cc_wacom_panel_switch_to_panel (page->priv->panel, "display");
-	return TRUE;
-}
-
-/* Boilerplate code goes below */
-
-static void
-cc_wacom_page_get_property (GObject    *object,
-                             guint       property_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_page_set_property (GObject      *object,
-                             guint         property_id,
-                             const GValue *value,
-                             GParamSpec   *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_page_dispose (GObject *object)
-{
-	CcWacomPagePrivate *priv = CC_WACOM_PAGE (object)->priv;
-
-	if (priv->area) {
-		calib_area_free (priv->area);
-		priv->area = NULL;
-	}
-
-	if (priv->builder) {
-		g_object_unref (priv->builder);
-		priv->builder = NULL;
-	}
-
-
-	G_OBJECT_CLASS (cc_wacom_page_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_page_class_init (CcWacomPageClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomPagePrivate));
-
-	object_class->get_property = cc_wacom_page_get_property;
-	object_class->set_property = cc_wacom_page_set_property;
-	object_class->dispose = cc_wacom_page_dispose;
-}
-
-static void
-cc_wacom_page_init (CcWacomPage *self)
-{
-	CcWacomPagePrivate *priv;
-	GError *error = NULL;
-	GtkComboBox *combo;
-	GtkWidget *box;
-	GtkSwitch *sw;
-	char *objects[] = {
-		"main-grid",
-		"liststore-tabletmode",
-		"liststore-buttons",
-		"adjustment-tip-feel",
-		"adjustment-eraser-feel",
-		NULL
-	};
-
-	priv = self->priv = WACOM_PAGE_PRIVATE (self);
-
-	priv->builder = gtk_builder_new ();
-
-	gtk_builder_add_objects_from_file (priv->builder,
-					   GNOMECC_UI_DIR "/gnome-wacom-properties.ui",
-					   objects,
-					   &error);
-	if (error != NULL) {
-		g_warning ("Error loading UI file: %s", error->message);
-		g_object_unref (priv->builder);
-		g_error_free (error);
-		return;
-	}
-
-	box = WID ("main-grid");
-	gtk_container_add (GTK_CONTAINER (self), box);
-	gtk_widget_set_vexpand (GTK_WIDGET (box), TRUE);
-
-	self->priv->notebook = WID ("stylus-notebook");
-
-	g_signal_connect (WID ("button-calibrate"), "clicked",
-			  G_CALLBACK (calibrate_button_clicked_cb), self);
-	g_signal_connect (WID ("map-buttons-button"), "clicked",
-			  G_CALLBACK (map_buttons_button_clicked_cb), self);
-
-	combo = GTK_COMBO_BOX (WID ("combo-tabletmode"));
-	combobox_text_cellrenderer (combo, MODELABEL_COLUMN);
-	g_signal_connect (G_OBJECT (combo), "changed",
-			  G_CALLBACK (tabletmode_changed_cb), self);
-
-	sw = GTK_SWITCH (WID ("switch-left-handed"));
-	g_signal_connect (G_OBJECT (sw), "notify::active",
-			  G_CALLBACK (left_handed_toggled_cb), self);
-
-	g_signal_connect (G_OBJECT (WID ("display-link")), "activate-link",
-			  G_CALLBACK (display_clicked_cb), self);
-
-	g_signal_connect (G_OBJECT (WID ("display-mapping-button")), "clicked",
-			  G_CALLBACK (display_mapping_button_clicked_cb), self);
-
-	priv->nav = cc_wacom_nav_button_new ();
-        gtk_widget_set_halign (priv->nav, GTK_ALIGN_END);
-        gtk_widget_set_margin_right (priv->nav, 10);
-	gtk_grid_attach (GTK_GRID (box), priv->nav, 0, 0, 1, 1);
-}
-
-static void
-set_icon_name (CcWacomPage *page,
-	       const char  *widget_name,
-	       const char  *icon_name)
-{
-	CcWacomPagePrivate *priv;
-	char *filename, *path;
-
-	priv = page->priv;
-
-	filename = g_strdup_printf ("%s.svg", icon_name);
-	path = g_build_filename (GNOMECC_UI_DIR, filename, NULL);
-	g_free (filename);
-
-	gtk_image_set_from_file (GTK_IMAGE (WID (widget_name)), path);
-	g_free (path);
-}
-
-typedef struct {
-	GsdWacomStylus *stylus;
-	GsdWacomStylus *eraser;
-} StylusPair;
-
-static void
-add_styli (CcWacomPage *page)
-{
-	GList *styli, *l;
-	CcWacomPagePrivate *priv;
-
-	priv = page->priv;
-
-	styli = gsd_wacom_device_list_styli (priv->stylus);
-
-	for (l = styli; l; l = l->next) {
-		GsdWacomStylus *stylus, *eraser;
-		GtkWidget *page;
-
-		stylus = l->data;
-
-		if (gsd_wacom_stylus_get_stylus_type (stylus) == WACOM_STYLUS_TYPE_PUCK)
-			continue;
-
-		if (gsd_wacom_stylus_get_has_eraser (stylus)) {
-			GsdWacomDeviceType type;
-			type = gsd_wacom_stylus_get_stylus_type (stylus);
-			eraser = gsd_wacom_device_get_stylus_for_type (priv->eraser, type);
-		} else {
-			eraser = NULL;
-		}
-
-		page = cc_wacom_stylus_page_new (stylus, eraser);
-		cc_wacom_stylus_page_set_navigation (CC_WACOM_STYLUS_PAGE (page), GTK_NOTEBOOK (priv->notebook));
-		gtk_widget_show (page);
-		gtk_notebook_append_page (GTK_NOTEBOOK (priv->notebook), page, NULL);
-	}
-	g_list_free (styli);
-}
-
-static void
-stylus_changed (GsdWacomDevice *device,
-		GParamSpec     *pspec,
-		CcWacomPage    *page)
-{
-	GsdWacomStylus *stylus;
-	CcWacomPagePrivate *priv;
-	int num_pages;
-	guint i;
-
-	priv = page->priv;
-	g_object_get (G_OBJECT (device), "last-stylus", &stylus, NULL);
-	if (stylus == NULL)
-		return;
-
-	num_pages = gtk_notebook_get_n_pages (GTK_NOTEBOOK (priv->notebook));
-	for (i = 0; i < num_pages; i++) {
-		GsdWacomStylus *s;
-		CcWacomStylusPage *spage;
-
-		spage = CC_WACOM_STYLUS_PAGE (gtk_notebook_get_nth_page (GTK_NOTEBOOK (priv->notebook), i));
-		s = cc_wacom_stylus_page_get_stylus (spage);
-		if (s == stylus) {
-			gtk_notebook_set_current_page (GTK_NOTEBOOK (priv->notebook), i);
-			return;
-		}
-	}
-
-	g_warning ("Failed to find the page for stylus '%s'",
-		   gsd_wacom_stylus_get_name (stylus));
-}
-
-/* Different types of layout for the tablet config */
-enum {
-	LAYOUT_NORMAL,        /* tracking mode, button mapping */
-	LAYOUT_REVERSIBLE,    /* tracking mode, button mapping, left-hand orientation */
-	LAYOUT_SCREEN        /* button mapping, calibration, display resolution */
-};
-
-static void
-remove_left_handed (CcWacomPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("label-left-handed"));
-	gtk_widget_destroy (WID ("switch-left-handed"));
-}
-
-static void
-remove_display_link (CcWacomPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("display-link"));
-
-        gtk_container_child_set (CWID ("main-grid"),
-                                 WID ("main-controls-grid"),
-                                 "top_attach", 2, NULL);
-}
-
-static void
-update_tablet_ui (CcWacomPage *page,
-		  int          layout)
-{
-	CcWacomPagePrivate *priv;
-
-	priv = page->priv;
-
-	/* FIXME Handle ->pad being NULL and hide the pad buttons */
-
-	switch (layout) {
-	case LAYOUT_NORMAL:
-		remove_left_handed (page->priv);
-		remove_display_link (page->priv);
-		break;
-	case LAYOUT_REVERSIBLE:
-		remove_display_link (page->priv);
-		break;
-	case LAYOUT_SCREEN:
-		remove_left_handed (page->priv);
-
-		gtk_widget_destroy (WID ("combo-tabletmode"));
-		gtk_widget_destroy (WID ("label-trackingmode"));
-		gtk_widget_destroy (WID ("display-mapping-button"));
-
-		gtk_widget_show (WID ("button-calibrate"));
-		gtk_widget_show (WID ("display-link"));
-
-		gtk_container_child_set (CWID ("main-grid"),
-					 WID ("tablet-buttons-box"),
-					 "top_attach", 1, NULL);
-		gtk_container_child_set (CWID ("main-grid"),
-					 WID ("display-link"),
-					 "top_attach", 2, NULL);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-}
-
-GtkWidget *
-cc_wacom_page_new (CcWacomPanel   *panel,
-		   GsdWacomDevice *stylus,
-		   GsdWacomDevice *eraser,
-		   GsdWacomDevice *pad)
-{
-	CcWacomPage *page;
-	CcWacomPagePrivate *priv;
-	int layout;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (stylus), NULL);
-	g_return_val_if_fail (gsd_wacom_device_get_device_type (stylus) == WACOM_TYPE_STYLUS, NULL);
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (eraser), NULL);
-	g_return_val_if_fail (gsd_wacom_device_get_device_type (eraser) == WACOM_TYPE_ERASER, NULL);
-
-	if (pad != NULL)
-		g_return_val_if_fail (gsd_wacom_device_get_device_type (pad) == WACOM_TYPE_PAD, NULL);
-
-	page = g_object_new (CC_TYPE_WACOM_PAGE, NULL);
-
-	priv = page->priv;
-	priv->panel = panel;
-	priv->stylus = stylus;
-	priv->eraser = eraser;
-	priv->pad = pad;
-
-	/* FIXME move this to construct */
-	priv->wacom_settings  = gsd_wacom_device_get_settings (stylus);
-	set_mode_from_gsettings (GTK_COMBO_BOX (WID ("combo-tabletmode")), page);
-
-	/* Tablet name */
-	gtk_label_set_text (GTK_LABEL (WID ("label-tabletmodel")), gsd_wacom_device_get_name (stylus));
-
-	/* Type of layout */
-	if (gsd_wacom_device_is_screen_tablet (stylus))
-		layout = LAYOUT_SCREEN;
-	else if (gsd_wacom_device_reversible (stylus))
-		layout = LAYOUT_REVERSIBLE;
-	else
-		layout = LAYOUT_NORMAL;
-
-	update_tablet_ui (page, layout);
-
-	/* Left-handedness */
-	if (gsd_wacom_device_reversible (stylus))
-		set_left_handed_from_gsettings (page);
-
-	/* Tablet icon */
-	set_icon_name (page, "image-tablet", gsd_wacom_device_get_icon_name (stylus));
-
-	/* Add styli */
-	add_styli (page);
-
-	/* Get the current stylus and switch to its page */
-	stylus_changed (priv->stylus, NULL, page);
-	g_signal_connect (G_OBJECT (priv->stylus), "notify::last-stylus",
-			  G_CALLBACK (stylus_changed), page);
-
-	return GTK_WIDGET (page);
-}
-
-void
-cc_wacom_page_set_navigation (CcWacomPage *page,
-			      GtkNotebook *notebook,
-			      gboolean     ignore_first_page)
-{
-	CcWacomPagePrivate *priv;
-
-	g_return_if_fail (CC_IS_WACOM_PAGE (page));
-
-	priv = page->priv;
-
-	g_object_set (G_OBJECT (priv->nav),
-		      "notebook", notebook,
-		      "ignore-first", ignore_first_page,
-		      NULL);
-}
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-page.h gnome-control-center-3.3.90/panels/wacom/cc-wacom-page.h
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-page.h	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-page.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,83 +0,0 @@
-/*
- * Copyright © 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- */
-
-
-#ifndef _CC_WACOM_PAGE_H
-#define _CC_WACOM_PAGE_H
-
-#include <gtk/gtk.h>
-#include "cc-wacom-panel.h"
-#include "gsd-wacom-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_PAGE cc_wacom_page_get_type()
-
-#define CC_WACOM_PAGE(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_PAGE, CcWacomPage))
-
-#define CC_WACOM_PAGE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_PAGE, CcWacomPageClass))
-
-#define CC_IS_WACOM_PAGE(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_PAGE))
-
-#define CC_IS_WACOM_PAGE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_PAGE))
-
-#define CC_WACOM_PAGE_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_PAGE, CcWacomPageClass))
-
-typedef struct _CcWacomPage CcWacomPage;
-typedef struct _CcWacomPageClass CcWacomPageClass;
-typedef struct _CcWacomPagePrivate CcWacomPagePrivate;
-
-struct _CcWacomPage
-{
-  GtkBox parent;
-
-  CcWacomPagePrivate *priv;
-};
-
-struct _CcWacomPageClass
-{
-  GtkBoxClass parent_class;
-};
-
-GType cc_wacom_page_get_type (void) G_GNUC_CONST;
-
-GtkWidget * cc_wacom_page_new (CcWacomPanel   *panel,
-			       GsdWacomDevice *stylus,
-			       GsdWacomDevice *eraser,
-			       GsdWacomDevice *pad);
-
-void cc_wacom_page_set_navigation (CcWacomPage *page,
-				   GtkNotebook *notebook,
-				   gboolean     ignore_first_page);
-
-G_END_DECLS
-
-#endif /* _CC_WACOM_PAGE_H */
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-panel.c gnome-control-center-3.3.90/panels/wacom/cc-wacom-panel.c
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-panel.c	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-panel.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,394 +0,0 @@
-/*
- * Copyright © 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include <config.h>
-
-#include <string.h>
-#include <gtk/gtk.h>
-
-#include "cc-wacom-panel.h"
-#include "cc-wacom-page.h"
-#include "gsd-wacom-device.h"
-
-#define WID(x) (GtkWidget *) gtk_builder_get_object (priv->builder, x)
-
-G_DEFINE_DYNAMIC_TYPE (CcWacomPanel, cc_wacom_panel, CC_TYPE_PANEL)
-
-#define WACOM_PANEL_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_PANEL, CcWacomPanelPrivate))
-
-struct _CcWacomPanelPrivate
-{
-	GtkBuilder       *builder;
-	GtkWidget        *notebook;
-	GHashTable       *devices; /* key=GdkDevice, value=GsdWacomDevice */
-	GHashTable       *pages; /* key=device name, value=GtkWidget */
-	GdkDeviceManager *manager;
-	guint             device_added_id;
-	guint             device_removed_id;
-};
-
-typedef struct {
-	const char *name;
-	GsdWacomDevice *stylus;
-	GsdWacomDevice *eraser;
-	GsdWacomDevice *pad;
-} Tablet;
-
-enum {
-	WACOM_PAGE = -1,
-	PLUG_IN_PAGE = 0,
-};
-
-/* Boilerplate code goes below */
-
-static void
-cc_wacom_panel_get_property (GObject    *object,
-                             guint       property_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_panel_set_property (GObject      *object,
-                             guint         property_id,
-                             const GValue *value,
-                             GParamSpec   *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_panel_dispose (GObject *object)
-{
-	CcWacomPanelPrivate *priv = CC_WACOM_PANEL (object)->priv;
-
-	if (priv->builder)
-	{
-		g_object_unref (priv->builder);
-		priv->builder = NULL;
-	}
-
-	if (priv->manager)
-	{
-		g_signal_handler_disconnect (priv->manager, priv->device_added_id);
-		g_signal_handler_disconnect (priv->manager, priv->device_removed_id);
-		priv->manager = NULL;
-	}
-
-	if (priv->devices)
-	{
-		g_hash_table_destroy (priv->devices);
-		priv->devices = NULL;
-	}
-
-	if (priv->pages)
-	{
-		g_hash_table_destroy (priv->pages);
-		priv->pages = NULL;
-	}
-
-	G_OBJECT_CLASS (cc_wacom_panel_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_panel_class_init (CcWacomPanelClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomPanelPrivate));
-
-	object_class->get_property = cc_wacom_panel_get_property;
-	object_class->set_property = cc_wacom_panel_set_property;
-	object_class->dispose = cc_wacom_panel_dispose;
-}
-
-static void
-cc_wacom_panel_class_finalize (CcWacomPanelClass *klass)
-{
-}
-
-static void
-remove_page (GtkNotebook *notebook,
-	     GtkWidget   *widget)
-{
-	int num_pages, i;
-
-	num_pages = gtk_notebook_get_n_pages (notebook);
-	g_return_if_fail (num_pages > 1);
-	for (i = 1; i < num_pages; i++) {
-		if (gtk_notebook_get_nth_page (notebook, i) == widget) {
-			gtk_notebook_remove_page (notebook, i);
-			return;
-		}
-	}
-}
-
-static void
-update_current_page (CcWacomPanel *self)
-{
-	GHashTable *ht;
-	GList *devices, *tablets, *l;
-	gboolean changed;
-	CcWacomPanelPrivate *priv;
-
-	priv = self->priv;
-	changed = FALSE;
-
-	ht = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
-	devices = g_hash_table_get_values (priv->devices);
-	for (l = devices; l; l = l->next) {
-		Tablet *tablet;
-		GsdWacomDevice *device;
-
-		device = l->data;
-		tablet = g_hash_table_lookup (ht, gsd_wacom_device_get_name (device));
-		if (tablet == NULL) {
-			tablet = g_new0 (Tablet, 1);
-			tablet->name = gsd_wacom_device_get_name (device);
-			g_hash_table_insert (ht, (gpointer) tablet->name, tablet);
-		}
-
-		switch (gsd_wacom_device_get_device_type (device)) {
-		case WACOM_TYPE_STYLUS:
-			tablet->stylus = device;
-			break;
-		case WACOM_TYPE_ERASER:
-			tablet->eraser = device;
-			break;
-		case WACOM_TYPE_PAD:
-			tablet->pad = device;
-			break;
-		default:
-			/* Nothing */
-			;
-		}
-	}
-	g_list_free (devices);
-
-	/* We now have a list of Tablet structs,
-	 * see which ones are full tablets */
-	tablets = g_hash_table_get_values (ht);
-	for (l = tablets; l; l = l->next) {
-		Tablet *tablet;
-
-		tablet = l->data;
-		if (tablet->stylus == NULL ||
-		    tablet->eraser == NULL) {
-			GtkWidget *page;
-
-			page = g_hash_table_lookup (priv->pages, tablet->name);
-			if (page != NULL) {
-				remove_page (GTK_NOTEBOOK (priv->notebook), page);
-				g_hash_table_remove (priv->pages, tablet->name);
-
-				changed = TRUE;
-			}
-			continue;
-		}
-
-		if (g_hash_table_lookup (priv->pages, tablet->name) == NULL) {
-			GtkWidget *page;
-			page = cc_wacom_page_new (self, tablet->stylus, tablet->eraser, tablet->pad);
-			cc_wacom_page_set_navigation (CC_WACOM_PAGE (page), GTK_NOTEBOOK (priv->notebook), TRUE);
-			gtk_widget_show (page);
-			gtk_notebook_append_page (GTK_NOTEBOOK (priv->notebook), page, NULL);
-			g_hash_table_insert (priv->pages, g_strdup (tablet->name), page);
-
-			changed = TRUE;
-		}
-	}
-	g_list_free (tablets);
-
-	g_hash_table_destroy (ht);
-
-	if (changed == TRUE) {
-		int num_pages;
-
-		num_pages = gtk_notebook_get_n_pages (GTK_NOTEBOOK (priv->notebook));
-		if (num_pages > 1)
-			gtk_notebook_set_current_page (GTK_NOTEBOOK (priv->notebook), WACOM_PAGE);
-	}
-}
-
-static void
-add_known_device (CcWacomPanel *self,
-		  GdkDevice    *gdk_device)
-{
-	CcWacomPanelPrivate *priv;
-	GsdWacomDevice *device;
-
-	priv = self->priv;
-
-	device = gsd_wacom_device_new (gdk_device);
-	if (gsd_wacom_device_get_device_type (device) == WACOM_TYPE_INVALID) {
-		g_object_unref (device);
-		return;
-	}
-	g_debug ("Adding device '%s' (type: '%s') to known devices list",
-		 gsd_wacom_device_get_tool_name (device),
-		 gsd_wacom_device_type_to_string (gsd_wacom_device_get_device_type (device)));
-	g_hash_table_insert (priv->devices, (gpointer) gdk_device, device);
-}
-
-static void
-device_removed_cb (GdkDeviceManager *manager,
-		   GdkDevice        *gdk_device,
-		   CcWacomPanel     *self)
-{
-	g_hash_table_remove (self->priv->devices, gdk_device);
-	update_current_page (self);
-}
-
-static void
-device_added_cb (GdkDeviceManager *manager,
-		 GdkDevice        *device,
-		 CcWacomPanel     *self)
-{
-	add_known_device (self, device);
-	update_current_page (self);
-}
-
-static gboolean
-link_activated (GtkLinkButton *button,
-		CcWacomPanel  *self)
-{
-	cc_wacom_panel_switch_to_panel (self, "bluetooth");
-	return TRUE;
-}
-
-void
-cc_wacom_panel_switch_to_panel (CcWacomPanel *self,
-				const char   *panel)
-{
-	CcShell *shell;
-	GError *error = NULL;
-
-	shell = cc_panel_get_shell (CC_PANEL (self));
-	if (cc_shell_set_active_panel_from_id (shell, panel, NULL, &error) == FALSE)
-	{
-		g_warning ("Failed to activate '%s' panel: %s", panel, error->message);
-		g_error_free (error);
-	}
-}
-
-static void
-enbiggen_label (GtkLabel *label)
-{
-	const char *str;
-	char *new_str;
-
-	str = gtk_label_get_text (label);
-	new_str = g_strdup_printf ("<big>%s</big>", str);
-	gtk_label_set_markup (label, new_str);
-	g_free (new_str);
-}
-
-static void
-cc_wacom_panel_init (CcWacomPanel *self)
-{
-	CcWacomPanelPrivate *priv;
-	GtkNotebook *notebook;
-	GtkWidget *widget;
-	GList *devices, *l;
-	GError *error = NULL;
-	char *objects[] = {
-		"main-box",
-		NULL
-	};
-
-	priv = self->priv = WACOM_PANEL_PRIVATE (self);
-
-	priv->builder = gtk_builder_new ();
-
-	gtk_builder_add_objects_from_file (priv->builder,
-					   GNOMECC_UI_DIR "/gnome-wacom-properties.ui",
-					   objects,
-					   &error);
-	if (error != NULL)
-	{
-		g_warning ("Error loading UI file: %s", error->message);
-		g_object_unref (priv->builder);
-		g_error_free (error);
-		return;
-	}
-
-	/* Notebook */
-	notebook = GTK_NOTEBOOK (gtk_notebook_new ());
-	priv->notebook = GTK_WIDGET (notebook);
-
-	gtk_notebook_set_show_tabs (notebook, FALSE);
-	gtk_widget_set_vexpand (GTK_WIDGET (notebook), TRUE);
-	gtk_container_set_border_width (GTK_CONTAINER (notebook), 0);
-	g_object_set (G_OBJECT (notebook),
-		      "margin-top", 0,
-		      "margin-right", 24,
-		      "margin-left", 24,
-		      "margin-bottom", 24,
-		      NULL);
-
-	gtk_container_add (GTK_CONTAINER (self), GTK_WIDGET (notebook));
-	gtk_widget_show (priv->notebook);
-
-	/* No tablets page */
-	widget = WID ("main-box");
-	enbiggen_label (GTK_LABEL (WID ("advice-label1")));
-	gtk_notebook_append_page (notebook, widget, NULL);
-
-	g_signal_connect (G_OBJECT (WID ("linkbutton")), "activate-link",
-			  G_CALLBACK (link_activated), self);
-
-	priv->devices = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
-	priv->pages = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
-
-	priv->manager = gdk_display_get_device_manager (gdk_display_get_default ());
-	priv->device_added_id = g_signal_connect (G_OBJECT (priv->manager), "device-added",
-						  G_CALLBACK (device_added_cb), self);
-	priv->device_removed_id = g_signal_connect (G_OBJECT (priv->manager), "device-removed",
-						    G_CALLBACK (device_removed_cb), self);
-
-	devices = gdk_device_manager_list_devices (priv->manager, GDK_DEVICE_TYPE_SLAVE);
-	for (l = devices; l ; l = l->next)
-		add_known_device (self, l->data);
-	g_list_free (devices);
-
-	update_current_page (self);
-}
-
-void
-cc_wacom_panel_register (GIOModule *module)
-{
-	cc_wacom_panel_register_type (G_TYPE_MODULE (module));
-	g_io_extension_point_implement (CC_SHELL_PANEL_EXTENSION_POINT,
-					CC_TYPE_WACOM_PANEL, "wacom", 0);
-}
-
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-panel.h gnome-control-center-3.3.90/panels/wacom/cc-wacom-panel.h
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-panel.h	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-panel.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,77 +0,0 @@
-/*
- * Copyright © 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- */
-
-
-#ifndef _CC_WACOM_PANEL_H
-#define _CC_WACOM_PANEL_H
-
-#include <shell/cc-panel.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_PANEL cc_wacom_panel_get_type()
-
-#define CC_WACOM_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_PANEL, CcWacomPanel))
-
-#define CC_WACOM_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_PANEL, CcWacomPanelClass))
-
-#define CC_IS_WACOM_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_PANEL))
-
-#define CC_IS_WACOM_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_PANEL))
-
-#define CC_WACOM_PANEL_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_PANEL, CcWacomPanelClass))
-
-typedef struct _CcWacomPanel CcWacomPanel;
-typedef struct _CcWacomPanelClass CcWacomPanelClass;
-typedef struct _CcWacomPanelPrivate CcWacomPanelPrivate;
-
-struct _CcWacomPanel
-{
-  CcPanel parent;
-
-  CcWacomPanelPrivate *priv;
-};
-
-struct _CcWacomPanelClass
-{
-  CcPanelClass parent_class;
-};
-
-GType cc_wacom_panel_get_type (void) G_GNUC_CONST;
-
-void  cc_wacom_panel_register (GIOModule *module);
-
-void  cc_wacom_panel_switch_to_panel (CcWacomPanel *self,
-				      const char   *panel);
-
-G_END_DECLS
-
-#endif /* _CC_WACOM_PANEL_H */
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-stylus-page.c gnome-control-center-3.3.90/panels/wacom/cc-wacom-stylus-page.c
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-stylus-page.c	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-stylus-page.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,510 +0,0 @@
-/*
- * Copyright © 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include <config.h>
-
-#include <glib/gi18n.h>
-#include "cc-wacom-stylus-page.h"
-#include "cc-wacom-nav-button.h"
-#include <gtk/gtk.h>
-
-#include <string.h>
-
-#define WID(x) (GtkWidget *) gtk_builder_get_object (priv->builder, x)
-#define CWID(x) (GtkContainer *) gtk_builder_get_object (priv->builder, x)
-
-G_DEFINE_TYPE (CcWacomStylusPage, cc_wacom_stylus_page, GTK_TYPE_BOX)
-
-#define WACOM_STYLUS_PAGE_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_STYLUS_PAGE, CcWacomStylusPagePrivate))
-
-struct _CcWacomStylusPagePrivate
-{
-	GsdWacomStylus *stylus, *eraser;
-	GtkBuilder     *builder;
-	GtkWidget      *nav;
-	GSettings      *stylus_settings, *eraser_settings;
-};
-
-/* Button combo box storage columns */
-enum {
-	BUTTONNUMBER_COLUMN,
-	BUTTONNAME_COLUMN,
-	N_BUTTONCOLUMNS
-};
-
-/* GSettings stores pressurecurve as 4 values like the driver. We map slider
- * scale to these values given the array below. These settings were taken from
- * wacomcpl, where they've been around for years.
- */
-#define N_PRESSURE_CURVES 7
-static const gint32 PRESSURE_CURVES[N_PRESSURE_CURVES][4] = {
-		{	0,	75,	25,	100	},	/* soft */
-		{	0,	50,	50,	100	},
-		{	0,	25,	75,	100	},
-		{	0,	0,	100,	100	},	/* neutral */
-		{	25,	0,	100,	75	},
-		{	50,	0,	100,	50	},
-		{	75,	0,	100,	25	}	/* firm */
-};
-
-static void
-set_pressurecurve (GtkRange *range, GSettings *settings)
-{
-	gint		slider_val = gtk_range_get_value (range);
-	GVariant	*values[4],
-			*array;
-	int		i;
-
-	for (i = 0; i < G_N_ELEMENTS (values); i++)
-		values[i] = g_variant_new_int32 (PRESSURE_CURVES[slider_val][i]);
-
-	array = g_variant_new_array (G_VARIANT_TYPE_INT32, values, G_N_ELEMENTS (values));
-
-	g_settings_set_value (settings, "pressurecurve", array);
-}
-
-static void
-tip_feel_value_changed_cb (GtkRange *range, gpointer user_data)
-{
-    set_pressurecurve (range, CC_WACOM_STYLUS_PAGE(user_data)->priv->stylus_settings);
-}
-
-static void
-eraser_feel_value_changed_cb (GtkRange *range, gpointer user_data)
-{
-    set_pressurecurve (range, CC_WACOM_STYLUS_PAGE(user_data)->priv->eraser_settings);
-}
-
-static void
-set_feel_from_gsettings (GtkAdjustment *adjustment, GSettings *settings)
-{
-	GVariant	*variant;
-	const gint32	*values;
-	gsize		nvalues;
-	int		i;
-
-	variant = g_settings_get_value (settings, "pressurecurve");
-	values = g_variant_get_fixed_array (variant, &nvalues, sizeof (gint32));
-
-	if (nvalues != 4) {
-		g_warning ("Invalid pressure curve format, expected 4 values (got %"G_GSIZE_FORMAT")", nvalues);
-		return;
-	}
-
-	for (i = 0; i < N_PRESSURE_CURVES; i++) {
-		if (memcmp (PRESSURE_CURVES[i], values, sizeof (gint32) * 4) == 0) {
-			gtk_adjustment_set_value (adjustment, i);
-			break;
-		}
-	}
-}
-
-static void
-set_button_mapping_from_gsettings (GtkComboBox *combo, GSettings* settings, gint current_button)
-{
-	GVariant	*current;
-	gsize		 nvalues;
-	const gint	*values;
-	GtkTreeModel	*model;
-	GtkTreeIter	 iter;
-	gboolean	 valid;
-
-	current = g_settings_get_value (settings, "buttonmapping");
-	values = g_variant_get_fixed_array (current, &nvalues, sizeof (gint32));
-	model = gtk_combo_box_get_model (combo);
-	valid = gtk_tree_model_get_iter_first (model, &iter);
-
-	while (valid) {
-		gint button;
-
-		gtk_tree_model_get (model, &iter,
-				    BUTTONNUMBER_COLUMN, &button,
-				    -1);
-
-		/* Currently button values match logical X buttons. If we
-		 * introduce things like double-click, this code must
-		 * change. Recommendation: use negative buttons numbers for
-		 * special ones.
-		 */
-
-		/* 0 vs 1-indexed array/button numbers */
-		if (button == values[current_button - 1]) {
-			gtk_combo_box_set_active_iter (combo, &iter);
-			break;
-		}
-
-		valid = gtk_tree_model_iter_next (model, &iter);
-	}
-}
-
-static void
-map_button (GSettings *settings, int button2, int button3)
-{
-	GVariant	*current; /* current mapping */
-	GVariant	*array;   /* new mapping */
-	GVariant	**tmp;
-	gsize		 nvalues;
-	const gint	*values;
-	gint		 i;
-
-	current = g_settings_get_value (settings, "buttonmapping");
-	values = g_variant_get_fixed_array (current, &nvalues, sizeof (gint32));
-
-	tmp = g_malloc (nvalues * sizeof (GVariant*));
-	for (i = 0; i < nvalues; i++) {
-		if (i == 1) /* zero indexed array vs one-indexed buttons */
-			tmp[i] = g_variant_new_int32 (button2);
-		else if (i == 2)
-			tmp[i] = g_variant_new_int32 (button3);
-		else
-			tmp[i] = g_variant_new_int32 (values[i]);
-	}
-
-	array = g_variant_new_array (G_VARIANT_TYPE_INT32, tmp, nvalues);
-	g_settings_set_value (settings, "buttonmapping", array);
-
-	g_free (tmp);
-}
-
-static void
-button_changed_cb (GtkComboBox *combo, gpointer user_data)
-{
-	CcWacomStylusPagePrivate	*priv = CC_WACOM_STYLUS_PAGE(user_data)->priv;
-	GtkTreeIter		iter;
-	GtkListStore		*liststore;
-	gint			mapping_b2,
-				mapping_b3;
-
-	if (!gtk_combo_box_get_active_iter (GTK_COMBO_BOX (WID ("combo-bottombutton")), &iter))
-		return;
-
-	liststore = GTK_LIST_STORE (WID ("liststore-buttons"));
-	gtk_tree_model_get (GTK_TREE_MODEL (liststore), &iter,
-			    BUTTONNUMBER_COLUMN, &mapping_b2,
-			    -1);
-
-	if (!gtk_combo_box_get_active_iter (GTK_COMBO_BOX (WID ("combo-topbutton")), &iter))
-		return;
-
-	gtk_tree_model_get (GTK_TREE_MODEL (liststore), &iter,
-			    BUTTONNUMBER_COLUMN, &mapping_b3,
-			    -1);
-
-	map_button (priv->stylus_settings, mapping_b2, mapping_b3);
-}
-
-static void
-combobox_text_cellrenderer (GtkComboBox *combo, int name_column)
-{
-	GtkCellRenderer	*renderer;
-
-	renderer = gtk_cell_renderer_text_new ();
-	gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo), renderer, TRUE);
-	gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo), renderer,
-					"text", BUTTONNAME_COLUMN, NULL);
-}
-
-/* Boilerplate code goes below */
-
-static void
-cc_wacom_stylus_page_get_property (GObject    *object,
-                             guint       property_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_stylus_page_set_property (GObject      *object,
-                             guint         property_id,
-                             const GValue *value,
-                             GParamSpec   *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_stylus_page_dispose (GObject *object)
-{
-	CcWacomStylusPagePrivate *priv = CC_WACOM_STYLUS_PAGE (object)->priv;
-
-	if (priv->builder) {
-		g_object_unref (priv->builder);
-		priv->builder = NULL;
-	}
-
-
-	G_OBJECT_CLASS (cc_wacom_stylus_page_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_stylus_page_class_init (CcWacomStylusPageClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomStylusPagePrivate));
-
-	object_class->get_property = cc_wacom_stylus_page_get_property;
-	object_class->set_property = cc_wacom_stylus_page_set_property;
-	object_class->dispose = cc_wacom_stylus_page_dispose;
-}
-
-static void
-cc_wacom_stylus_page_init (CcWacomStylusPage *self)
-{
-	CcWacomStylusPagePrivate *priv;
-	GError *error = NULL;
-	GtkComboBox *combo;
-	GtkWidget *box;
-	char *objects[] = {
-		"stylus-grid",
-		"liststore-buttons",
-		"adjustment-tip-feel",
-		"adjustment-eraser-feel",
-		NULL
-	};
-
-	priv = self->priv = WACOM_STYLUS_PAGE_PRIVATE (self);
-
-	priv->builder = gtk_builder_new ();
-
-	gtk_builder_add_objects_from_file (priv->builder,
-					   GNOMECC_UI_DIR "/wacom-stylus-page.ui",
-					   objects,
-					   &error);
-	if (error != NULL) {
-		g_warning ("Error loading UI file: %s", error->message);
-		g_object_unref (priv->builder);
-		g_error_free (error);
-		return;
-	}
-
-	box = WID ("stylus-grid");
-	gtk_container_add (GTK_CONTAINER (self), box);
-	gtk_widget_set_vexpand (GTK_WIDGET (box), TRUE);
-
-	g_signal_connect (WID ("scale-tip-feel"), "value-changed",
-			  G_CALLBACK (tip_feel_value_changed_cb), self);
-	g_signal_connect (WID ("scale-eraser-feel"), "value-changed",
-			  G_CALLBACK (eraser_feel_value_changed_cb), self);
-
-	combo = GTK_COMBO_BOX (WID ("combo-topbutton"));
-	combobox_text_cellrenderer (combo, BUTTONNAME_COLUMN);
-	g_signal_connect (G_OBJECT (combo), "changed",
-			  G_CALLBACK (button_changed_cb), self);
-
-	combo = GTK_COMBO_BOX (WID ("combo-bottombutton"));
-	combobox_text_cellrenderer (combo, BUTTONNAME_COLUMN);
-	g_signal_connect (G_OBJECT (combo), "changed",
-			  G_CALLBACK (button_changed_cb), self);
-
-	priv->nav = cc_wacom_nav_button_new ();
-        gtk_widget_set_halign (priv->nav, GTK_ALIGN_END);
-        gtk_widget_set_margin_right (priv->nav, 10);
-	gtk_grid_attach (GTK_GRID (box), priv->nav, 0, 0, 1, 1);
-}
-
-static void
-set_icon_name (CcWacomStylusPage *page,
-	       const char  *widget_name,
-	       const char  *icon_name)
-{
-	CcWacomStylusPagePrivate *priv;
-	char *filename, *path;
-
-	priv = page->priv;
-
-	filename = g_strdup_printf ("%s.svg", icon_name);
-	path = g_build_filename (GNOMECC_UI_DIR, filename, NULL);
-	g_free (filename);
-
-	gtk_image_set_from_file (GTK_IMAGE (WID (widget_name)), path);
-	g_free (path);
-}
-
-/* Different types of layout for the stylus config */
-enum {
-	LAYOUT_NORMAL,   /* eraser, 2 buttons, tip */
-	LAYOUT_INKING,   /* tip */
-	LAYOUT_AIRBRUSH, /* eraser, 1 button, tip */
-	LAYOUT_OTHER
-};
-
-static void
-remove_buttons (CcWacomStylusPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("combo-topbutton"));
-	gtk_widget_destroy (WID ("combo-bottombutton"));
-	gtk_widget_destroy (WID ("label-top-button"));
-	gtk_widget_destroy (WID ("label-lower-button"));
-}
-
-static void
-remove_button (CcWacomStylusPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("combo-topbutton"));
-	gtk_widget_destroy (WID ("label-top-button"));
-	gtk_label_set_text (GTK_LABEL (WID ("label-lower-button")), _("Button"));
-}
-
-static void
-remove_eraser (CcWacomStylusPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("eraser-box"));
-	gtk_widget_destroy (WID ("label-eraser-feel"));
-}
-
-static void
-update_stylus_ui (CcWacomStylusPage *page,
-		  int                layout)
-{
-	CcWacomStylusPagePrivate *priv = page->priv;
-
-	switch (layout) {
-	case LAYOUT_NORMAL:
-		/* easy! */
-		break;
-	case LAYOUT_INKING:
-		remove_buttons (page->priv);
-		remove_eraser (page->priv);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("label-tip-feel"),
-					 "top_attach", 0, NULL);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("box-tip-feel"),
-					 "top_attach", 0, NULL);
-		break;
-	case LAYOUT_AIRBRUSH:
-		remove_button (page->priv);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("label-lower-button"),
-					 "top_attach", 1, NULL);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("combo-bottombutton"),
-					 "top_attach", 1, NULL);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("label-tip-feel"),
-					 "top_attach", 2, NULL);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("box-tip-feel"),
-					 "top_attach", 2, NULL);
-	case LAYOUT_OTHER:
-		/* We already warn about it in cc_wacom_stylus_page_new () */
-		break;
-	}
-}
-
-GtkWidget *
-cc_wacom_stylus_page_new (GsdWacomStylus *stylus,
-			  GsdWacomStylus *eraser)
-{
-	CcWacomStylusPage *page;
-	CcWacomStylusPagePrivate *priv;
-	int num_buttons;
-	int layout;
-
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	page = g_object_new (CC_TYPE_WACOM_STYLUS_PAGE, NULL);
-
-	priv = page->priv;
-	priv->stylus = stylus;
-	priv->eraser = eraser;
-
-	/* Icon */
-	set_icon_name (page, "image-stylus", gsd_wacom_stylus_get_icon_name (stylus));
-
-	/* Settings */
-	priv->stylus_settings = gsd_wacom_stylus_get_settings (stylus);
-	if (eraser != NULL)
-		priv->eraser_settings = gsd_wacom_stylus_get_settings (eraser);
-
-	/* Stylus name */
-	gtk_label_set_text (GTK_LABEL (WID ("label-stylus")), gsd_wacom_stylus_get_name (stylus));
-
-	num_buttons = gsd_wacom_stylus_get_num_buttons (stylus);
-	if (num_buttons == 0 && eraser == NULL)
-		layout = LAYOUT_INKING;
-	else if (num_buttons == 2 && eraser != NULL)
-		layout = LAYOUT_NORMAL;
-	else if (num_buttons == 1 && eraser != NULL)
-		layout = LAYOUT_AIRBRUSH;
-	else {
-		layout = LAYOUT_OTHER;
-		if (num_buttons == 0)
-			remove_buttons (priv);
-		else if (num_buttons == 1)
-			remove_button (priv);
-
-		if (eraser == NULL)
-			remove_eraser (priv);
-
-		g_warning ("The layout of this page is not known, %d buttons, %s eraser",
-			   num_buttons, eraser ? "with" : "without");
-	}
-
-	update_stylus_ui (page, layout);
-
-	if (num_buttons == 2)
-		set_button_mapping_from_gsettings (GTK_COMBO_BOX (WID ("combo-topbutton")), priv->stylus_settings, 3);
-	if (num_buttons >= 1)
-		set_button_mapping_from_gsettings (GTK_COMBO_BOX (WID ("combo-bottombutton")), priv->stylus_settings, 2);
-	set_feel_from_gsettings (GTK_ADJUSTMENT (WID ("adjustment-tip-feel")), priv->stylus_settings);
-
-	if (eraser != NULL)
-		set_feel_from_gsettings (GTK_ADJUSTMENT (WID ("adjustment-eraser-feel")), priv->eraser_settings);
-
-	g_object_set (G_OBJECT (page), "margin-top", 16, NULL);
-
-	return GTK_WIDGET (page);
-}
-
-GsdWacomStylus *
-cc_wacom_stylus_page_get_stylus (CcWacomStylusPage *page)
-{
-	return page->priv->stylus;
-}
-
-void
-cc_wacom_stylus_page_set_navigation (CcWacomStylusPage *page,
-				     GtkNotebook *notebook)
-{
-	CcWacomStylusPagePrivate *priv;
-
-	g_return_if_fail (CC_IS_WACOM_STYLUS_PAGE (page));
-
-	priv = page->priv;
-
-	g_object_set (G_OBJECT (priv->nav),
-		      "notebook", notebook,
-		      NULL);
-}
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-stylus-page.h gnome-control-center-3.3.90/panels/wacom/cc-wacom-stylus-page.h
--- gnome-control-center-3.3.90.orig/panels/wacom/cc-wacom-stylus-page.h	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/cc-wacom-stylus-page.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,81 +0,0 @@
-/*
- * Copyright © 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- */
-
-
-#ifndef _CC_WACOM_STYLUS_PAGE_H
-#define _CC_WACOM_STYLUS_PAGE_H
-
-#include <gtk/gtk.h>
-#include "gsd-wacom-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_STYLUS_PAGE cc_wacom_stylus_page_get_type()
-
-#define CC_WACOM_STYLUS_PAGE(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_STYLUS_PAGE, CcWacomStylusPage))
-
-#define CC_WACOM_STYLUS_PAGE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_STYLUS_PAGE, CcWacomStylusPageClass))
-
-#define CC_IS_WACOM_STYLUS_PAGE(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_STYLUS_PAGE))
-
-#define CC_IS_WACOM_STYLUS_PAGE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_STYLUS_PAGE))
-
-#define CC_WACOM_STYLUS_PAGE_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_STYLUS_PAGE, CcWacomStylusPageClass))
-
-typedef struct _CcWacomStylusPage CcWacomStylusPage;
-typedef struct _CcWacomStylusPageClass CcWacomStylusPageClass;
-typedef struct _CcWacomStylusPagePrivate CcWacomStylusPagePrivate;
-
-struct _CcWacomStylusPage
-{
-  GtkBox parent;
-
-  CcWacomStylusPagePrivate *priv;
-};
-
-struct _CcWacomStylusPageClass
-{
-  GtkBoxClass parent_class;
-};
-
-GType cc_wacom_stylus_page_get_type (void) G_GNUC_CONST;
-
-GtkWidget * cc_wacom_stylus_page_new (GsdWacomStylus *stylus,
-				      GsdWacomStylus *eraser);
-
-GsdWacomStylus * cc_wacom_stylus_page_get_stylus (CcWacomStylusPage *page);
-
-void cc_wacom_stylus_page_set_navigation (CcWacomStylusPage *page,
-					  GtkNotebook *notebook);
-
-G_END_DECLS
-
-#endif /* _CC_WACOM_STYLUS_PAGE_H */
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/gnome-wacom-properties.ui gnome-control-center-3.3.90/panels/wacom/gnome-wacom-properties.ui
--- gnome-control-center-3.3.90.orig/panels/wacom/gnome-wacom-properties.ui	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/gnome-wacom-properties.ui	1969-12-31 19:00:00.000000000 -0500
@@ -1,407 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <!-- interface-requires gtk+ 3.0 -->
-  <object class="GtkListStore" id="liststore-tabletmode">
-    <columns>
-      <!-- column-name tabletmode -->
-      <column type="guint"/>
-      <!-- column-name tabletmode-label -->
-      <column type="gchararray"/>
-    </columns>
-    <data>
-      <row>
-        <col id="0">0</col>
-        <col id="1" translatable="yes">Tablet (absolute)</col>
-      </row>
-      <row>
-        <col id="0">1</col>
-        <col id="1" translatable="yes">Touchpad (relative)</col>
-      </row>
-    </data>
-  </object>
-  <object class="GtkDialog" id="wacom_properties_dialog">
-    <property name="can_focus">False</property>
-    <property name="vexpand">True</property>
-    <property name="border_width">5</property>
-    <property name="title" translatable="yes">Tablet Preferences</property>
-    <property name="resizable">False</property>
-    <property name="default_width">675</property>
-    <property name="default_height">460</property>
-    <property name="icon_name">input-tablet</property>
-    <property name="type_hint">dialog</property>
-    <child internal-child="vbox">
-      <object class="GtkBox" id="dialog-vbox1">
-        <property name="can_focus">False</property>
-        <property name="orientation">vertical</property>
-        <property name="spacing">2</property>
-        <child internal-child="action_area">
-          <object class="GtkButtonBox" id="dialog-action_area1">
-            <property name="can_focus">False</property>
-            <property name="layout_style">end</property>
-            <child>
-              <object class="GtkButton" id="helpbutton1">
-                <property name="label">gtk-help</property>
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="can_default">True</property>
-                <property name="receives_default">False</property>
-                <property name="use_action_appearance">False</property>
-                <property name="use_stock">True</property>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">False</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkButton" id="closebutton1">
-                <property name="label">gtk-close</property>
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="can_default">True</property>
-                <property name="receives_default">False</property>
-                <property name="use_action_appearance">False</property>
-                <property name="use_stock">True</property>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">False</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">False</property>
-            <property name="fill">True</property>
-            <property name="pack_type">end</property>
-            <property name="position">0</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkNotebook" id="main-notebook">
-            <property name="visible">True</property>
-            <property name="can_focus">True</property>
-            <property name="vexpand">True</property>
-            <property name="show_tabs">False</property>
-            <child>
-              <object class="GtkBox" id="main-box">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="vexpand">True</property>
-                <property name="orientation">vertical</property>
-                <child>
-                  <placeholder/>
-                </child>
-                <child>
-                  <object class="GtkLabel" id="advice-label1">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="vexpand">True</property>
-                    <property name="yalign">1</property>
-                    <property name="label" translatable="yes">No tablet detected</property>
-                    <property name="justify">center</property>
-                    <property name="use_markup">True</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">True</property>
-                    <property name="position">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkLabel" id="advice-label2">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="vexpand">True</property>
-                    <property name="yalign">0</property>
-                    <property name="label" translatable="yes">Please plug in or turn on your Wacom tablet</property>
-                    <property name="justify">center</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">True</property>
-                    <property name="position">3</property>
-                  </packing>
-                </child>
-                <child>
-                  <placeholder/>
-                </child>
-                <child>
-                  <object class="GtkLinkButton" id="linkbutton">
-                    <property name="label" translatable="yes">Bluetooth Settings</property>
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="receives_default">True</property>
-                    <property name="has_tooltip">True</property>
-                    <property name="halign">end</property>
-                    <property name="valign">end</property>
-                    <property name="use_action_appearance">False</property>
-                    <property name="relief">none</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">True</property>
-                    <property name="position">5</property>
-                  </packing>
-                </child>
-              </object>
-              <packing>
-                <property name="tab_expand">True</property>
-              </packing>
-            </child>
-            <child type="tab">
-              <object class="GtkLabel" id="label4">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label">Plugin</property>
-              </object>
-              <packing>
-                <property name="tab_fill">False</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkGrid" id="main-grid">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="column_spacing">10</property>
-                <property name="row_spacing">10</property>
-                <child>
-                  <object class="GtkLabel" id="label-tabletmodel">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="halign">start</property>
-                    <property name="valign">center</property>
-                    <property name="label" translatable="yes">Wacom Tablet</property>
-                    <attributes>
-                      <attribute name="weight" value="bold"/>
-                    </attributes>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="top_attach">0</property>
-                    <property name="width">1</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkImage" id="image-tablet">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="pixbuf">wacom-tablet.svg</property>
-                    <property name="valign">start</property>
-                    <property name="halign">center</property>
-                  </object>
-                  <packing>
-                    <property name="left_attach">0</property>
-                    <property name="top_attach">1</property>
-                    <property name="width">1</property>
-                    <property name="height">3</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkBox" id="tablet-buttons-box">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="orientation">horizontal</property>
-                    <property name="spacing">10</property>
-                    <property name="hexpand">True</property>
-                    <child>
-                      <object class="GtkButton" id="button-calibrate">
-                        <property name="label" translatable="yes">Calibrate...</property>
-                        <property name="use_action_appearance">False</property>
-                        <property name="can_focus">True</property>
-                        <property name="receives_default">True</property>
-                        <property name="use_action_appearance">False</property>
-                        <property name="valign">center</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">True</property>
-                        <property name="position">0</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkButton" id="map-buttons-button">
-                        <property name="label" translatable="yes">Map Buttons...</property>
-                        <property name="use_action_appearance">False</property>
-                        <property name="sensitive">True</property>
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="receives_default">True</property>
-                        <property name="use_action_appearance">False</property>
-                        <property name="valign">center</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">True</property>
-                        <property name="position">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkButton" id="display-mapping-button">
-                        <property name="label" translatable="yes">Map to Monitor...</property>
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="receives_default">True</property>
-                        <property name="use_action_appearance">False</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">True</property>
-                        <property name="position">2</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="top_attach">1</property>
-                    <property name="width">1</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-                <child>
-                 <object class="GtkLinkButton" id="display-link">
-                   <property name="label" translatable="yes">Adjust display resolution</property>
-                   <property name="visible">False</property>
-                   <property name="can_focus">True</property>
-                   <property name="receives_default">True</property>
-                   <property name="has_tooltip">True</property>
-                   <property name="use_action_appearance">False</property>
-                   <property name="relief">none</property>
-                   <property name="halign">start</property>
-                   <property name="valign">center</property>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="top_attach">2</property>
-                    <property name="width">1</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkGrid" id="main-controls-grid">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="orientation">vertical</property>
-                    <property name="margin_left">16</property>
-                    <property name="row_spacing">10</property>
-                    <property name="column_spacing">10</property>
-                    <child>
-                      <object class="GtkLabel" id="label-trackingmode">
-                        <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="halign">end</property>
-                        <property name="valign">center</property>
-                        <property name="label" translatable="yes">Tracking Mode</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left_attach">0</property>
-                        <property name="top_attach">0</property>
-                        <property name="width">1</property>
-                        <property name="height">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkComboBox" id="combo-tabletmode">
-                        <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="hexpand">True</property>
-                        <property name="model">liststore-tabletmode</property>
-                      </object>
-                      <packing>
-                        <property name="left_attach">1</property>
-                        <property name="top_attach">0</property>
-                        <property name="width">1</property>
-                        <property name="height">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="label-left-handed">
-                        <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="halign">end</property>
-                        <property name="valign">center</property>
-                        <property name="label" translatable="yes">Left-Handed Orientation</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left_attach">0</property>
-                        <property name="top_attach">1</property>
-                        <property name="width">1</property>
-                        <property name="height">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkSwitch" id="switch-left-handed">
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="halign">start</property>
-                        <property name="valign">center</property>
-                        <property name="use_action_appearance">False</property>
-                      </object>
-                      <packing>
-                        <property name="left_attach">1</property>
-                        <property name="top_attach">1</property>
-                        <property name="width">1</property>
-                        <property name="height">1</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="top_attach">3</property>
-                    <property name="width">1</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkNotebook" id="stylus-notebook">
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="vexpand">True</property>
-                    <property name="show_tabs">False</property>
-                  </object>
-                  <packing>
-                    <property name="left_attach">0</property>
-                    <property name="top_attach">4</property>
-                    <property name="width">2</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-              </object>
-              <packing>
-                <property name="position">1</property>
-              </packing>
-            </child>
-            <child type="tab">
-              <object class="GtkLabel" id="label1">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label">Wacom</property>
-              </object>
-              <packing>
-                <property name="position">1</property>
-                <property name="tab_fill">False</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">True</property>
-            <property name="fill">True</property>
-            <property name="position">1</property>
-          </packing>
-        </child>
-      </object>
-    </child>
-    <action-widgets>
-      <action-widget response="0">helpbutton1</action-widget>
-      <action-widget response="0">closebutton1</action-widget>
-    </action-widgets>
-  </object>
-</interface>
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/gsd-enums.h gnome-control-center-3.3.90/panels/wacom/gsd-enums.h
--- gnome-control-center-3.3.90.orig/panels/wacom/gsd-enums.h	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/gsd-enums.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,7 +0,0 @@
-/* We copy gsd-wacom-device from gnome-settings-daemon.
- * It include "gsd-enums.h" because the include directory
- * is known. As gnome-settings-daemon's pkg-config file
- * prefixes this, we need a little help to avoid this
- * one line difference */
-
-#include <gnome-settings-daemon/gsd-enums.h>
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/gsd-wacom-device.c gnome-control-center-3.3.90/panels/wacom/gsd-wacom-device.c
--- gnome-control-center-3.3.90.orig/panels/wacom/gsd-wacom-device.c	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/gsd-wacom-device.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1701 +0,0 @@
-/*
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include "config.h"
-
-#include <glib.h>
-#include <glib/gi18n-lib.h>
-#include <gtk/gtk.h>
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include <X11/Xatom.h>
-#define GNOME_DESKTOP_USE_UNSTABLE_API
-#include <libgnome-desktop/gnome-rr.h>
-#include <libgnome-desktop/gnome-rr-config.h>
-
-#include <libwacom/libwacom.h>
-#include <X11/extensions/XInput.h>
-#include <X11/extensions/XInput2.h>
-
-#include "gsd-input-helper.h"
-
-#include "gsd-enums.h"
-#include "gsd-wacom-device.h"
-
-#define GSD_WACOM_STYLUS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusPrivate))
-
-#define WACOM_TABLET_SCHEMA "org.gnome.settings-daemon.peripherals.wacom"
-#define WACOM_DEVICE_CONFIG_BASE "/org/gnome/settings-daemon/peripherals/wacom/%s/"
-#define WACOM_STYLUS_SCHEMA "org.gnome.settings-daemon.peripherals.wacom.stylus"
-#define WACOM_ERASER_SCHEMA "org.gnome.settings-daemon.peripherals.wacom.eraser"
-#define WACOM_BUTTON_SCHEMA "org.gnome.settings-daemon.peripherals.wacom.tablet-button"
-
-static WacomDeviceDatabase *db = NULL;
-
-struct GsdWacomStylusPrivate
-{
-	GsdWacomDevice *device;
-	int id;
-	WacomStylusType type;
-	char *name;
-	const char *icon_name;
-	GSettings *settings;
-	gboolean has_eraser;
-	int num_buttons;
-};
-
-static void     gsd_wacom_stylus_class_init  (GsdWacomStylusClass *klass);
-static void     gsd_wacom_stylus_init        (GsdWacomStylus      *wacom_stylus);
-static void     gsd_wacom_stylus_finalize    (GObject              *object);
-
-G_DEFINE_TYPE (GsdWacomStylus, gsd_wacom_stylus, G_TYPE_OBJECT)
-
-static void
-gsd_wacom_stylus_class_init (GsdWacomStylusClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->finalize = gsd_wacom_stylus_finalize;
-
-        g_type_class_add_private (klass, sizeof (GsdWacomStylusPrivate));
-}
-
-static void
-gsd_wacom_stylus_init (GsdWacomStylus *stylus)
-{
-        stylus->priv = GSD_WACOM_STYLUS_GET_PRIVATE (stylus);
-}
-
-static void
-gsd_wacom_stylus_finalize (GObject *object)
-{
-        GsdWacomStylus *stylus;
-        GsdWacomStylusPrivate *p;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSD_IS_WACOM_STYLUS (object));
-
-        stylus = GSD_WACOM_STYLUS (object);
-
-        g_return_if_fail (stylus->priv != NULL);
-
-	p = stylus->priv;
-
-        if (p->settings != NULL) {
-                g_object_unref (p->settings);
-                p->settings = NULL;
-        }
-
-        g_free (p->name);
-        p->name = NULL;
-
-        G_OBJECT_CLASS (gsd_wacom_stylus_parent_class)->finalize (object);
-}
-
-static const char *
-get_icon_name_from_type (WacomStylusType type)
-{
-	switch (type) {
-	case WSTYLUS_INKING:
-	case WSTYLUS_STROKE:
-		/* The stroke pen is the same as the inking pen with
-		 * a different nib */
-		return "wacom-stylus-inking";
-	case WSTYLUS_AIRBRUSH:
-		return "wacom-stylus-airbrush";
-	case WSTYLUS_MARKER:
-		return "wacom-stylus-art-pen";
-	case WSTYLUS_CLASSIC:
-		return "wacom-stylus-classic";
-	default:
-		return "wacom-stylus";
-	}
-}
-
-static GsdWacomStylus *
-gsd_wacom_stylus_new (GsdWacomDevice    *device,
-		      const WacomStylus *wstylus,
-		      GSettings         *settings)
-{
-	GsdWacomStylus *stylus;
-
-	g_return_val_if_fail (G_IS_SETTINGS (settings), NULL);
-	g_return_val_if_fail (wstylus != NULL, NULL);
-
-	stylus = GSD_WACOM_STYLUS (g_object_new (GSD_TYPE_WACOM_STYLUS,
-						 NULL));
-	stylus->priv->device = device;
-	stylus->priv->id = libwacom_stylus_get_id (wstylus);
-	stylus->priv->name = g_strdup (libwacom_stylus_get_name (wstylus));
-	stylus->priv->settings = settings;
-	stylus->priv->type = libwacom_stylus_get_type (wstylus);
-	stylus->priv->icon_name = get_icon_name_from_type (stylus->priv->type);
-	stylus->priv->has_eraser = libwacom_stylus_has_eraser (wstylus);
-	stylus->priv->num_buttons = libwacom_stylus_get_num_buttons (wstylus);
-
-	return stylus;
-}
-
-GSettings *
-gsd_wacom_stylus_get_settings (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	return stylus->priv->settings;
-}
-
-const char *
-gsd_wacom_stylus_get_name (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	return stylus->priv->name;
-}
-
-const char *
-gsd_wacom_stylus_get_icon_name (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	return stylus->priv->icon_name;
-}
-
-GsdWacomDevice *
-gsd_wacom_stylus_get_device (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	return stylus->priv->device;
-}
-
-gboolean
-gsd_wacom_stylus_get_has_eraser (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), FALSE);
-
-	return stylus->priv->has_eraser;
-}
-
-guint
-gsd_wacom_stylus_get_num_buttons (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), -1);
-
-	return stylus->priv->num_buttons;
-}
-
-GsdWacomStylusType
-gsd_wacom_stylus_get_stylus_type (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), WACOM_STYLUS_TYPE_UNKNOWN);
-
-	switch (stylus->priv->type) {
-	case WSTYLUS_UNKNOWN:
-		return WACOM_STYLUS_TYPE_UNKNOWN;
-	case WSTYLUS_GENERAL:
-		return WACOM_STYLUS_TYPE_GENERAL;
-	case WSTYLUS_INKING:
-		return WACOM_STYLUS_TYPE_INKING;
-	case WSTYLUS_AIRBRUSH:
-		return WACOM_STYLUS_TYPE_AIRBRUSH;
-	case WSTYLUS_CLASSIC:
-		return WACOM_STYLUS_TYPE_CLASSIC;
-	case WSTYLUS_MARKER:
-		return WACOM_STYLUS_TYPE_MARKER;
-	case WSTYLUS_STROKE:
-		return WACOM_STYLUS_TYPE_STROKE;
-	case WSTYLUS_PUCK:
-		return WACOM_STYLUS_TYPE_PUCK;
-	default:
-		g_assert_not_reached ();
-	}
-
-	return WACOM_STYLUS_TYPE_UNKNOWN;
-}
-
-int
-gsd_wacom_stylus_get_id (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), -1);
-
-	return stylus->priv->id;
-}
-
-/* Tablet buttons */
-static GsdWacomTabletButton *
-gsd_wacom_tablet_button_new (const char               *name,
-			     const char               *id,
-			     const char               *settings_path,
-			     GsdWacomTabletButtonType  type,
-			     int                       group_id)
-{
-	GsdWacomTabletButton *ret;
-
-	ret = g_new0 (GsdWacomTabletButton, 1);
-	ret->name = g_strdup (name);
-	ret->id = g_strdup (id);
-	if (type != WACOM_TABLET_BUTTON_TYPE_HARDCODED) {
-		char *button_settings_path;
-
-		button_settings_path = g_strdup_printf ("%s%s/", settings_path, id);
-		ret->settings = g_settings_new_with_path (WACOM_BUTTON_SCHEMA, button_settings_path);
-		g_free (button_settings_path);
-	}
-	ret->group_id = group_id;
-	ret->type = type;
-
-	return ret;
-}
-
-void
-gsd_wacom_tablet_button_free (GsdWacomTabletButton *button)
-{
-	g_return_if_fail (button != NULL);
-
-	if (button->settings != NULL)
-		g_object_unref (button->settings);
-	g_free (button->name);
-	g_free (button->id);
-	g_free (button);
-}
-
-GsdWacomTabletButton *
-gsd_wacom_tablet_button_copy (GsdWacomTabletButton *button)
-{
-	GsdWacomTabletButton *ret;
-
-	g_return_val_if_fail (button != NULL, NULL);
-
-	ret = g_new0 (GsdWacomTabletButton, 1);
-	ret->name = g_strdup (button->name);
-	if (button->settings != NULL)
-		ret->settings = g_object_ref (button->settings);
-	ret->id = button->id;
-	ret->type = button->type;
-	ret->group_id = button->group_id;
-
-	return ret;
-}
-
-#define GSD_WACOM_DEVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDevicePrivate))
-
-/* we support two types of settings:
- * Tablet-wide settings: applied to each tool on the tablet. e.g. rotation
- * Tool-specific settings: applied to one tool only.
- */
-#define SETTINGS_WACOM_DIR         "org.gnome.settings-daemon.peripherals.wacom"
-#define SETTINGS_STYLUS_DIR        "stylus"
-#define SETTINGS_ERASER_DIR        "eraser"
-
-struct GsdWacomDevicePrivate
-{
-	GdkDevice *gdk_device;
-	int device_id;
-	int opcode;
-
-	GsdWacomDeviceType type;
-	char *name;
-	char *icon_name;
-	char *tool_name;
-	gboolean reversible;
-	gboolean is_screen_tablet;
-	GList *styli;
-	GsdWacomStylus *last_stylus;
-	GList *buttons;
-	GSettings *wacom_settings;
-};
-
-enum {
-	PROP_0,
-	PROP_GDK_DEVICE,
-	PROP_LAST_STYLUS
-};
-
-static void     gsd_wacom_device_class_init  (GsdWacomDeviceClass *klass);
-static void     gsd_wacom_device_init        (GsdWacomDevice      *wacom_device);
-static void     gsd_wacom_device_finalize    (GObject              *object);
-
-G_DEFINE_TYPE (GsdWacomDevice, gsd_wacom_device, G_TYPE_OBJECT)
-
-static GdkFilterReturn
-filter_events (XEvent         *xevent,
-               GdkEvent       *event,
-               GsdWacomDevice *device)
-{
-	XIEvent             *xiev;
-	XIPropertyEvent     *pev;
-	XGenericEventCookie *cookie;
-	char                *name;
-	int                  tool_id;
-
-        /* verify we have a property event */
-	if (xevent->type != GenericEvent)
-		return GDK_FILTER_CONTINUE;
-
-	cookie = &xevent->xcookie;
-	if (cookie->extension != device->priv->opcode)
-		return GDK_FILTER_CONTINUE;
-
-	xiev = (XIEvent *) xevent->xcookie.data;
-
-	if (xiev->evtype != XI_PropertyEvent)
-		return GDK_FILTER_CONTINUE;
-
-	pev = (XIPropertyEvent *) xiev;
-
-	/* Is the event for us? */
-	if (pev->deviceid != device->priv->device_id)
-		return GDK_FILTER_CONTINUE;
-
-	name = XGetAtomName (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), pev->property);
-	if (name == NULL ||
-	    g_strcmp0 (name, WACOM_SERIAL_IDS_PROP) != 0) {
-		return GDK_FILTER_CONTINUE;
-	}
-	XFree (name);
-
-	tool_id = xdevice_get_last_tool_id (device->priv->device_id);
-	if (tool_id == -1) {
-		g_warning ("Failed to get value for changed stylus ID on device '%d", device->priv->device_id);
-		return GDK_FILTER_CONTINUE;
-	}
-	gsd_wacom_device_set_current_stylus (device, tool_id);
-
-	return GDK_FILTER_CONTINUE;
-}
-
-static gboolean
-setup_property_notify (GsdWacomDevice *device)
-{
-	Display *dpy;
-	XIEventMask evmask;
-	int tool_id;
-
-	evmask.deviceid = device->priv->device_id;
-	evmask.mask_len = XIMaskLen (XI_PropertyEvent);
-	evmask.mask = g_malloc0(evmask.mask_len * sizeof(char));
-	XISetMask (evmask.mask, XI_PropertyEvent);
-
-	dpy = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-	XISelectEvents (dpy, DefaultRootWindow(dpy), &evmask, 1);
-
-	g_free (evmask.mask);
-
-	gdk_window_add_filter (NULL,
-			       (GdkFilterFunc) filter_events,
-			       device);
-
-	tool_id = xdevice_get_last_tool_id (device->priv->device_id);
-	if (tool_id == -1) {
-		g_warning ("Failed to get value for changed stylus ID on device '%d", device->priv->device_id);
-		return TRUE;
-	}
-	gsd_wacom_device_set_current_stylus (device, tool_id);
-
-	return TRUE;
-}
-
-static GsdWacomDeviceType
-get_device_type (XDeviceInfo *dev)
-{
-	GsdWacomDeviceType ret;
-        static Atom stylus, cursor, eraser, pad, touch, prop;
-        XDevice *device;
-        Atom realtype;
-        int realformat;
-        unsigned long nitems, bytes_after;
-        unsigned char *data = NULL;
-        int rc;
-
-        ret = WACOM_TYPE_INVALID;
-
-        if ((dev->use == IsXPointer) || (dev->use == IsXKeyboard))
-                return ret;
-
-        if (!stylus)
-                stylus = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "STYLUS", False);
-        if (!eraser)
-                eraser = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "ERASER", False);
-        if (!cursor)
-                cursor = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "CURSOR", False);
-        if (!pad)
-                pad = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "PAD", False);
-        if (!touch)
-                touch = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "TOUCH", False);
-        if (!prop)
-		prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Wacom Tool Type", False);
-
-	if (dev->type == stylus)
-		ret = WACOM_TYPE_STYLUS;
-	else if (dev->type == eraser)
-		ret = WACOM_TYPE_ERASER;
-	else if (dev->type == cursor)
-		ret = WACOM_TYPE_CURSOR;
-	else if (dev->type == pad)
-		ret = WACOM_TYPE_PAD;
-	else if (dev->type == touch)
-		ret = WACOM_TYPE_TOUCH;
-
-	if (ret == WACOM_TYPE_INVALID)
-		return ret;
-
-        /* There is currently no good way of detecting the driver for a device
-         * other than checking for a driver-specific property.
-         * Wacom Tool Type exists on all tools
-         */
-        gdk_error_trap_push ();
-        device = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), dev->id);
-        if (gdk_error_trap_pop () || (device == NULL))
-                return ret;
-
-        gdk_error_trap_push ();
-
-        rc = XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                                 device, prop, 0, 1, False,
-                                 XA_ATOM, &realtype, &realformat, &nitems,
-                                 &bytes_after, &data);
-        if (gdk_error_trap_pop () || rc != Success || realtype == None) {
-                XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device);
-                ret = WACOM_TYPE_INVALID;
-        }
-
-        XFree (data);
-
-	return ret;
-}
-
-/* Finds an output which matches the given EDID information. Any NULL
- * parameter will be interpreted to match any value.
- */
-static GnomeRROutputInfo*
-find_output_by_edid (const gchar *vendor, const gchar *product, const gchar *serial)
-{
-	GError *error = NULL;
-	GnomeRRScreen *rr_screen;
-	GnomeRRConfig *rr_config;
-	GnomeRROutputInfo **rr_output_info;
-        GnomeRROutputInfo *retval = NULL;
-
-	rr_screen = gnome_rr_screen_new (gdk_screen_get_default (), &error);
-	if (rr_screen == NULL) {
-		g_warning ("Failed to create GnomeRRScreen: %s", error->message);
-		g_error_free (error);
-		return NULL;
-	}
-	rr_config = gnome_rr_config_new_current (rr_screen, &error);
-	if (rr_config == NULL) {
-		g_warning ("Failed to get current screen configuration: %s", error->message);
-		g_error_free (error);
-		g_object_unref (rr_screen);
-		return NULL;
-	}
-	rr_output_info = gnome_rr_config_get_outputs (rr_config);
-
-	for (; *rr_output_info != NULL; rr_output_info++) {
-		gchar *o_vendor;
-		gchar *o_product;
-		gchar *o_serial;
-		gboolean match;
-
-		o_vendor = g_malloc0 (4);
-		gnome_rr_output_info_get_vendor (*rr_output_info, o_vendor);
-		o_product = g_strdup_printf ("%d", gnome_rr_output_info_get_product (*rr_output_info));
-		o_serial  = g_strdup_printf ("%d", gnome_rr_output_info_get_serial  (*rr_output_info));
-
-		g_debug ("Checking for match between '%s','%s','%s' and '%s','%s','%s'", \
-		         vendor,product,serial, o_vendor,o_product,o_serial);
-
-		match = (vendor  == NULL || g_strcmp0 (vendor,  o_vendor)  == 0) && \
-		        (product == NULL || g_strcmp0 (product, o_product) == 0) && \
-		        (serial  == NULL || g_strcmp0 (serial,  o_serial)  == 0);
-
-		g_free (o_vendor);
-		g_free (o_product);
-		g_free (o_serial);
-
-		if (match) {
-			retval = g_object_ref (*rr_output_info);
-			break;
-		}
-	}
-
-	g_object_unref (rr_config);
-	g_object_unref (rr_screen);
-
-	if (retval == NULL)
-		g_debug ("Did not find a matching output for EDID '%s,%s,%s'",
-			 vendor, product, serial);
-
-	return retval;
-}
-
-static GnomeRROutputInfo*
-find_output_by_heuristic (GsdWacomDevice *device)
-{
-	GnomeRROutputInfo *rr_output_info;
-
-	/* TODO: This heuristic will fail for non-Wacom display
-	 * tablets and may give the wrong result if multiple Wacom
-	 * display tablets are connected.
-	 */
-	rr_output_info = find_output_by_edid("WAC", NULL, NULL);
-	return rr_output_info;
-}
-
-static GnomeRROutputInfo*
-find_output_by_display (GsdWacomDevice *device)
-{
-	gsize n;
-	GSettings *tablet;
-	GVariant *display;
-	const gchar **edid;
-
-	if (device == NULL)
-		return NULL;
-
-	tablet   = device->priv->wacom_settings;
-	display  = g_settings_get_value (tablet, "display");
-	edid     = g_variant_get_strv (display, &n);
-
-	if (n != 3) {
-		g_critical ("Expected 'display' key to store %d values; got %"G_GSIZE_FORMAT".", 3, n);
-		return NULL;
-	}
-
-	if (strlen(edid[0]) == 0 || strlen(edid[1]) == 0 || strlen(edid[2]) == 0)
-		return NULL;
-
-	return find_output_by_edid (edid[0], edid[1], edid[2]);
-}
-
-static GnomeRROutputInfo*
-find_output_by_monitor (GdkScreen *screen,
-			int        monitor)
-{
-	GError *error = NULL;
-	GnomeRRScreen *rr_screen;
-	GnomeRRConfig *rr_config;
-	GnomeRROutputInfo **rr_output_infos;
-	GnomeRROutputInfo *ret;
-	guint i;
-
-	ret = NULL;
-
-	rr_screen = gnome_rr_screen_new (screen, &error);
-	if (rr_screen == NULL) {
-		g_warning ("gnome_rr_screen_new() failed: %s", error->message);
-		g_error_free (error);
-		return NULL;
-	}
-
-	rr_config = gnome_rr_config_new_current (rr_screen, &error);
-	if (rr_screen == NULL) {
-		g_warning ("gnome_rr_config_new_current() failed: %s", error->message);
-		g_error_free (error);
-		g_object_unref (rr_screen);
-		return NULL;
-	}
-
-	rr_output_infos = gnome_rr_config_get_outputs (rr_config);
-
-	for (i = 0; rr_output_infos[i] != NULL; i++) {
-		GnomeRROutputInfo *info;
-		int x, y, w, h;
-
-		info = rr_output_infos[i];
-
-		if (!gnome_rr_output_info_is_active (info))
-			continue;
-
-		gnome_rr_output_info_get_geometry (info, &x, &y, &w, &h);
-		if (monitor == gdk_screen_get_monitor_at_point (screen, x, y)) {
-			ret = g_object_ref (info);
-			break;
-		}
-	}
-
-	g_object_unref (rr_config);
-	g_object_unref (rr_screen);
-
-	if (ret == NULL)
-		g_warning ("No output found for monitor %d.", monitor);
-
-	return ret;
-}
-
-static void
-set_display_by_output (GsdWacomDevice    *device,
-                       GnomeRROutputInfo *rr_output_info)
-{
-	GSettings   *tablet;
-	GVariant    *c_array;
-	GVariant    *n_array;
-	gsize        nvalues;
-	gchar       *o_vendor, *o_product, *o_serial;
-	const gchar *values[3];
-
-	tablet  = gsd_wacom_device_get_settings (device);
-	c_array = g_settings_get_value (tablet, "display");
-	g_variant_get_strv (c_array, &nvalues);
-	if (nvalues != 3) {
-		g_warning("Unable set set display property. Got %"G_GSIZE_FORMAT" items; expected %d items.\n", nvalues, 4);
-		return;
-	}
-
-	if (rr_output_info == NULL)
-	{
-		o_vendor  = g_strdup ("");
-		o_product = g_strdup ("");
-		o_serial  = g_strdup ("");
-	}
-	else
-	{
-		o_vendor = g_malloc0 (4);
-		gnome_rr_output_info_get_vendor (rr_output_info, o_vendor);
-		o_product = g_strdup_printf ("%d", gnome_rr_output_info_get_product (rr_output_info));
-		o_serial  = g_strdup_printf ("%d", gnome_rr_output_info_get_serial  (rr_output_info));
-	}
-
-	values[0] = o_vendor;
-	values[1] = o_product;
-	values[2] = o_serial;
-	n_array = g_variant_new_strv((const gchar * const *) &values, 3);
-	g_settings_set_value (tablet, "display", n_array);
-
-	g_free (o_vendor);
-	g_free (o_product);
-	g_free (o_serial);
-}
-
-
-void
-gsd_wacom_device_set_display (GsdWacomDevice *device,
-                              int             monitor)
-{
-	GnomeRROutputInfo *output;
-
-        g_return_if_fail (GSD_IS_WACOM_DEVICE (device));
-        g_return_if_fail (monitor >= 0);
-
-	output = find_output_by_monitor (gdk_screen_get_default (), monitor);
-	if (output != NULL)
-		set_display_by_output (device, output);
-}
-
-static GnomeRROutputInfo*
-find_output (GsdWacomDevice *device)
-{
-	GnomeRROutputInfo *rr_output_info;
-
-	rr_output_info = find_output_by_display(device);
-
-	if (rr_output_info == NULL) {
-		if (gsd_wacom_device_is_screen_tablet (device)) {
-			rr_output_info = find_output_by_heuristic (device);
-			if (rr_output_info == NULL) {
-				g_warning ("No fuzzy match based on heuristics was found.");
-			} else {
-				g_warning("Automatically mapping tablet to heuristically-found display.");
-				set_display_by_output (device, rr_output_info);
-			}
-		}
-	}
-
-	return rr_output_info;
-}
-
-static void
-calculate_transformation_matrix (const GdkRectangle mapped, const GdkRectangle desktop, float matrix[NUM_ELEMS_MATRIX])
-{
-	float x_scale = (float)mapped.x / desktop.width;
-	float y_scale = (float)mapped.y / desktop.height;
-	float width_scale  = (float)mapped.width / desktop.width;
-	float height_scale = (float)mapped.height / desktop.height;
-
-	matrix[0] = width_scale;
-	matrix[1] = 0.0f;
-	matrix[2] = x_scale;
-
-	matrix[3] = 0.0f;
-	matrix[4] = height_scale;
-	matrix[5] = y_scale;
-
-	matrix[6] = 0.0f;
-	matrix[7] = 0.0f;
-	matrix[8] = 1.0f;
-
-	g_debug ("Matrix is %f,%f,%f,%f,%f,%f,%f,%f,%f.",
-	         matrix[0], matrix[1], matrix[2],
-	         matrix[3], matrix[4], matrix[5],
-	         matrix[6], matrix[7], matrix[8]);
-
-	return;
-}
-
-int
-gsd_wacom_device_get_display_monitor (GsdWacomDevice *device)
-{
-	gint area[4];
-	gboolean is_active;
-	GnomeRROutputInfo *rr_output_info;
-
-        g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), -1);
-
-	rr_output_info = find_output(device);
-	if (rr_output_info == NULL)
-		return -1;
-
-	is_active = gnome_rr_output_info_is_active (rr_output_info);
-	gnome_rr_output_info_get_geometry (rr_output_info, &area[0], &area[1], &area[2], &area[3]);
-
-	g_object_unref (rr_output_info);
-
-	if (!is_active)
-	{
-		g_warning ("Output is not active.");
-		return -1;
-	}
-
-	if (area[2] <= 0 || area[3] <= 0)
-	{
-		g_warning ("Output has non-positive area.");
-		return -1;
-	}
-
-	g_debug ("Area: %d,%d %dx%d", area[0], area[1], area[2], area[3]);
-	return gdk_screen_get_monitor_at_point (gdk_screen_get_default (), area[0], area[1]);
-}
-
-gboolean
-gsd_wacom_device_get_display_matrix (GsdWacomDevice *device, float matrix[NUM_ELEMS_MATRIX])
-{
-	int monitor;
-	GdkRectangle display;
-	GdkRectangle desktop;
-	GdkScreen *screen = gdk_screen_get_default ();
-
-	matrix[0] = 1.0f;
-	matrix[1] = 0.0f;
-	matrix[2] = 0.0f;
-	matrix[3] = 0.0f;
-	matrix[4] = 1.0f;
-	matrix[5] = 0.0f;
-	matrix[6] = 0.0f;
-	matrix[7] = 0.0f;
-	matrix[8] = 1.0f;
-
-	monitor = gsd_wacom_device_get_display_monitor (device);
-	if (monitor < 0)
-		return FALSE;
-
-	desktop.x = 0;
-	desktop.y = 0;
-	desktop.width = gdk_screen_get_width (screen);
-	desktop.height = gdk_screen_get_height (screen);
-
-	gdk_screen_get_monitor_geometry (screen, monitor, &display);
-	calculate_transformation_matrix (display, desktop, matrix);
-	return TRUE;
-}
-
-static void
-add_stylus_to_device (GsdWacomDevice *device,
-		      const char     *settings_path,
-		      int             id)
-{
-	const WacomStylus *wstylus;
-
-	wstylus = libwacom_stylus_get_for_id (db, id);
-	if (wstylus) {
-		GsdWacomStylus *stylus;
-		char *stylus_settings_path;
-		GSettings *settings;
-
-		if (device->priv->type == WACOM_TYPE_STYLUS &&
-		    libwacom_stylus_is_eraser (wstylus))
-			return;
-		if (device->priv->type == WACOM_TYPE_ERASER &&
-		    libwacom_stylus_is_eraser (wstylus) == FALSE)
-			return;
-
-		stylus_settings_path = g_strdup_printf ("%s0x%x/", settings_path, id);
-		if (device->priv->type == WACOM_TYPE_STYLUS) {
-			settings = g_settings_new_with_path (WACOM_STYLUS_SCHEMA, stylus_settings_path);
-			stylus = gsd_wacom_stylus_new (device, wstylus, settings);
-		} else {
-			settings = g_settings_new_with_path (WACOM_ERASER_SCHEMA, stylus_settings_path);
-			stylus = gsd_wacom_stylus_new (device, wstylus, settings);
-		}
-		g_free (stylus_settings_path);
-		device->priv->styli = g_list_prepend (device->priv->styli, stylus);
-	}
-}
-
-static int
-flags_to_group (WacomButtonFlags flags)
-{
-	if (flags & WACOM_BUTTON_RING_MODESWITCH)
-		return 1;
-	if (flags & WACOM_BUTTON_RING2_MODESWITCH)
-		return 2;
-	if (flags & WACOM_BUTTON_TOUCHSTRIP_MODESWITCH)
-		return 3;
-	if (flags & WACOM_BUTTON_TOUCHSTRIP2_MODESWITCH)
-		return 4;
-
-	return 0;
-}
-
-static GList *
-gsd_wacom_device_add_ring_modes (WacomDevice      *wacom_device,
-				 const char       *settings_path,
-				 WacomButtonFlags  direction)
-{
-	GList *l;
-	guint num_modes;
-	guint i;
-	char *name, *id;
-
-	l = NULL;
-
-	if ((direction & WACOM_BUTTON_POSITION_LEFT) && libwacom_has_ring (wacom_device)) {
-		num_modes = libwacom_get_ring_num_modes (wacom_device);
-		for (i = 1; i <= num_modes; i++) {
-			name = g_strdup_printf (_("Left Ring Mode #%d"), i);
-			id = g_strdup_printf ("left-ring-mode-%d", i);
-			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_ELEVATOR, flags_to_group (WACOM_BUTTON_RING_MODESWITCH)));
-		}
-	} else if ((direction & WACOM_BUTTON_POSITION_RIGHT) && libwacom_has_ring2 (wacom_device)) {
-		num_modes = libwacom_get_ring2_num_modes (wacom_device);
-		for (i = 1; i <= num_modes; i++) {
-			name = g_strdup_printf (_("Right Ring Mode #%d"), i);
-			id = g_strdup_printf ("right-ring-mode-%d", i);
-			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_ELEVATOR, flags_to_group (WACOM_BUTTON_RING2_MODESWITCH)));
-		}
-	}
-
-	return l;
-}
-
-static GList *
-gsd_wacom_device_add_strip_modes (WacomDevice      *wacom_device,
-				  const char       *settings_path,
-				  WacomButtonFlags  direction)
-{
-	GList *l;
-	guint num_modes;
-	guint num_strips;
-	guint i;
-	char *name, *id;
-
-	l = NULL;
-	num_strips = libwacom_get_num_strips (wacom_device);
-	if (num_strips > 2)
-		g_warning ("Unhandled number of touchstrips: %d", num_strips);
-
-	if ((direction & WACOM_BUTTON_POSITION_LEFT) && num_strips >= 1) {
-		num_modes = libwacom_get_strips_num_modes (wacom_device);
-		for (i = 1; i <= num_modes; i++) {
-			name = g_strdup_printf (_("Left Touchstrip Mode #%d"), i);
-			id = g_strdup_printf ("left-strip-mode-%d", i);
-			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_ELEVATOR, flags_to_group (WACOM_BUTTON_TOUCHSTRIP_MODESWITCH)));
-		}
-	} else if ((direction & WACOM_BUTTON_POSITION_RIGHT) && num_strips >= 2) {
-		num_modes = libwacom_get_strips_num_modes (wacom_device);
-		for (i = 1; i <= num_modes; i++) {
-			name = g_strdup_printf (_("Right Touchstrip Mode #%d"), i);
-			id = g_strdup_printf ("right-strip-mode-%d", i);
-			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_ELEVATOR, flags_to_group (WACOM_BUTTON_TOUCHSTRIP2_MODESWITCH)));
-		}
-	}
-
-	return l;
-}
-
-static char *
-gsd_wacom_device_modeswitch_name (WacomButtonFlags flags,
-				  guint button_num)
-{
-	if (flags & WACOM_BUTTON_RINGS_MODESWITCH) {
-		if (flags & WACOM_BUTTON_POSITION_LEFT)
-			return g_strdup_printf (_("Left Touchring Mode Switch"));
-		else
-			return g_strdup_printf (_("Right Touchring Mode Switch"));
-	} else if (flags & WACOM_BUTTON_TOUCHSTRIPS_MODESWITCH) {
-		if (flags & WACOM_BUTTON_POSITION_LEFT)
-			return g_strdup_printf (_("Left Touchstrip Mode Switch"));
-		else
-			return g_strdup_printf (_("Right Touchstrip Mode Switch"));
-	}
-
-	g_warning ("Unhandled modeswitch and direction combination");
-
-	return g_strdup_printf (_("Mode Switch #%d"), button_num);
-}
-
-static GList *
-gsd_wacom_device_add_buttons_dir (WacomDevice      *wacom_device,
-				  const char       *settings_path,
-				  WacomButtonFlags  direction,
-				  const char       *button_str,
-				  const char       *button_str_id)
-{
-	GList *l;
-	guint num_buttons, i, button_num;
-	char *name, *id;
-
-	l = NULL;
-	button_num = 1;
-	num_buttons = libwacom_get_num_buttons (wacom_device);
-	for (i = 'A'; i < 'A' + num_buttons; i++) {
-		WacomButtonFlags flags;
-
-		flags = libwacom_get_button_flag (wacom_device, i);
-		if (!(flags & direction))
-			continue;
-		/* Ignore mode switches */
-		if (flags & WACOM_BUTTON_MODESWITCH)
-			continue;
-
-		name = g_strdup_printf (button_str, button_num++);
-		id = g_strdup_printf ("%s%c", button_str_id, i);
-		l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_NORMAL, flags_to_group (flags)));
-		g_free (name);
-		g_free (id);
-	}
-
-	/* Handle modeswitches */
-	for (i = 'A'; i < 'A' + num_buttons; i++) {
-		WacomButtonFlags flags;
-
-		flags = libwacom_get_button_flag (wacom_device, i);
-		if (!(flags & direction))
-			continue;
-		/* Ignore non-mode switches */
-		if (flags & WACOM_BUTTON_MODESWITCH) {
-			char *name, *id;
-
-			name = gsd_wacom_device_modeswitch_name (flags, button_num++);
-			id = g_strdup_printf ("%s%c", button_str_id, i);
-			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_HARDCODED, flags_to_group (flags)));
-			g_free (name);
-			g_free (id);
-
-			if (flags & WACOM_BUTTON_RINGS_MODESWITCH)
-				l = g_list_concat (l, gsd_wacom_device_add_ring_modes (wacom_device, settings_path, direction));
-			else if (flags & WACOM_BUTTON_TOUCHSTRIPS_MODESWITCH)
-				l = g_list_concat (l, gsd_wacom_device_add_strip_modes (wacom_device, settings_path, direction));
-			else
-				g_warning ("Unhandled modeswitches");
-		}
-	}
-
-	return l;
-}
-
-static void
-gsd_wacom_device_add_buttons (GsdWacomDevice *device,
-			      WacomDevice    *wacom_device,
-			      const char     *settings_path)
-{
-	GList *l, *ret;
-
-	ret = NULL;
-
-	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_LEFT, _("Left Button #%d"), "button");
-	if (l)
-		ret = l;
-	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_RIGHT, _("Right Button #%d"), "button");
-	if (l)
-		ret = g_list_concat (ret, l);
-	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_TOP, _("Top Button #%d"), "button");
-	if (l)
-		ret = g_list_concat (ret, l);
-	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_BOTTOM, _("Bottom Button #%d"), "button");
-	if (l)
-		ret = g_list_concat (ret, l);
-
-	device->priv->buttons = ret;
-}
-
-static void
-gsd_wacom_device_update_from_db (GsdWacomDevice *device,
-				 WacomDevice    *wacom_device,
-				 const char     *identifier)
-{
-	char *settings_path;
-
-	settings_path = g_strdup_printf (WACOM_DEVICE_CONFIG_BASE, libwacom_get_match (wacom_device));
-	device->priv->wacom_settings = g_settings_new_with_path (WACOM_TABLET_SCHEMA,
-								 settings_path);
-
-	device->priv->name = g_strdup (libwacom_get_name (wacom_device));
-	device->priv->reversible = libwacom_is_reversible (wacom_device);
-	device->priv->is_screen_tablet = libwacom_is_builtin (wacom_device);
-	if (device->priv->is_screen_tablet) {
-		if (libwacom_get_class (wacom_device) == WCLASS_CINTIQ)
-			device->priv->icon_name = g_strdup ("wacom-tablet-cintiq");
-		else
-			device->priv->icon_name = g_strdup ("wacom-tablet-pc");
-	} else {
-		device->priv->icon_name = g_strdup ("wacom-tablet");
-	}
-
-	if (device->priv->type == WACOM_TYPE_PAD)
-		gsd_wacom_device_add_buttons (device, wacom_device, settings_path);
-
-	if (device->priv->type == WACOM_TYPE_STYLUS ||
-	    device->priv->type == WACOM_TYPE_ERASER) {
-		int *ids;
-		int num_styli;
-		guint i;
-
-		ids = libwacom_get_supported_styli(wacom_device, &num_styli);
-		for (i = 0; i < num_styli; i++)
-			add_stylus_to_device (device, settings_path, ids[i]);
-		/* Create a fallback stylus if we don't have one */
-		if (num_styli == 0)
-			add_stylus_to_device (device, settings_path,
-					      device->priv->type == WACOM_TYPE_STYLUS ?
-					      WACOM_STYLUS_FALLBACK_ID : WACOM_ERASER_FALLBACK_ID);
-
-		device->priv->styli = g_list_reverse (device->priv->styli);
-	}
-	g_free (settings_path);
-}
-
-static GObject *
-gsd_wacom_device_constructor (GType                     type,
-                              guint                      n_construct_properties,
-                              GObjectConstructParam     *construct_properties)
-{
-        GsdWacomDevice *device;
-        GdkDeviceManager *device_manager;
-        XDeviceInfo *device_info;
-        WacomDevice *wacom_device;
-        int n_devices;
-        guint i;
-        char *path;
-
-        device = GSD_WACOM_DEVICE (G_OBJECT_CLASS (gsd_wacom_device_parent_class)->constructor (type,
-												n_construct_properties,
-												construct_properties));
-
-	if (device->priv->gdk_device == NULL)
-		return G_OBJECT (device);
-
-	device_manager = gdk_display_get_device_manager (gdk_display_get_default ());
-	g_object_get (device_manager, "opcode", &device->priv->opcode, NULL);
-
-        g_object_get (device->priv->gdk_device, "device-id", &device->priv->device_id, NULL);
-
-        device_info = XListInputDevices (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &n_devices);
-        if (device_info == NULL) {
-		g_warning ("Could not list any input devices through XListInputDevices()");
-		goto end;
-	}
-
-        for (i = 0; i < n_devices; i++) {
-		if (device_info[i].id == device->priv->device_id) {
-			device->priv->type = get_device_type (&device_info[i]);
-			device->priv->tool_name = g_strdup (device_info[i].name);
-			break;
-		}
-	}
-
-	XFreeDeviceList (device_info);
-
-	if (device->priv->type == WACOM_TYPE_INVALID)
-		goto end;
-
-	path = xdevice_get_device_node (device->priv->device_id);
-	if (path == NULL) {
-		g_warning ("Could not get the device node path for ID '%d'", device->priv->device_id);
-		device->priv->type = WACOM_TYPE_INVALID;
-		goto end;
-	}
-
-	if (db == NULL)
-		db = libwacom_database_new ();
-
-	wacom_device = libwacom_new_from_path (db, path, FALSE, NULL);
-	if (!wacom_device) {
-		WacomError *wacom_error;
-
-		g_debug ("Creating fallback driver for wacom tablet '%s' ('%s')",
-			 gdk_device_get_name (device->priv->gdk_device),
-			 path);
-
-		wacom_error = libwacom_error_new ();
-		wacom_device = libwacom_new_from_path (db, path, TRUE, wacom_error);
-		if (wacom_device == NULL) {
-			g_warning ("Failed to create fallback wacom device for '%s': %s (%d)",
-				   path,
-				   libwacom_error_get_message (wacom_error),
-				   libwacom_error_get_code (wacom_error));
-			g_free (path);
-			libwacom_error_free (&wacom_error);
-			device->priv->type = WACOM_TYPE_INVALID;
-			goto end;
-		}
-	}
-
-	gsd_wacom_device_update_from_db (device, wacom_device, path);
-	libwacom_destroy (wacom_device);
-	g_free (path);
-
-	if (device->priv->type == WACOM_TYPE_STYLUS ||
-	    device->priv->type == WACOM_TYPE_ERASER) {
-		setup_property_notify (device);
-	}
-
-end:
-        return G_OBJECT (device);
-}
-
-static void
-gsd_wacom_device_set_property (GObject        *object,
-                               guint           prop_id,
-                               const GValue   *value,
-                               GParamSpec     *pspec)
-{
-        GsdWacomDevice *device;
-
-        device = GSD_WACOM_DEVICE (object);
-
-        switch (prop_id) {
-	case PROP_GDK_DEVICE:
-		device->priv->gdk_device = g_value_get_pointer (value);
-		break;
-	case PROP_LAST_STYLUS:
-		device->priv->last_stylus = g_value_get_pointer (value);
-		break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsd_wacom_device_get_property (GObject        *object,
-                               guint           prop_id,
-                               GValue         *value,
-                               GParamSpec     *pspec)
-{
-        GsdWacomDevice *device;
-
-        device = GSD_WACOM_DEVICE (object);
-
-        switch (prop_id) {
-	case PROP_GDK_DEVICE:
-		g_value_set_pointer (value, device->priv->gdk_device);
-		break;
-	case PROP_LAST_STYLUS:
-		g_value_set_pointer (value, device->priv->last_stylus);
-		break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsd_wacom_device_class_init (GsdWacomDeviceClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->constructor = gsd_wacom_device_constructor;
-        object_class->finalize = gsd_wacom_device_finalize;
-        object_class->set_property = gsd_wacom_device_set_property;
-        object_class->get_property = gsd_wacom_device_get_property;
-
-        g_type_class_add_private (klass, sizeof (GsdWacomDevicePrivate));
-
-	g_object_class_install_property (object_class, PROP_GDK_DEVICE,
-					 g_param_spec_pointer ("gdk-device", "gdk-device", "gdk-device",
-							       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (object_class, PROP_LAST_STYLUS,
-					 g_param_spec_pointer ("last-stylus", "last-stylus", "last-stylus",
-							       G_PARAM_READWRITE));
-}
-
-static void
-gsd_wacom_device_init (GsdWacomDevice *device)
-{
-        device->priv = GSD_WACOM_DEVICE_GET_PRIVATE (device);
-        device->priv->type = WACOM_TYPE_INVALID;
-}
-
-static void
-gsd_wacom_device_finalize (GObject *object)
-{
-        GsdWacomDevice *device;
-        GsdWacomDevicePrivate *p;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSD_IS_WACOM_DEVICE (object));
-
-        device = GSD_WACOM_DEVICE (object);
-
-        g_return_if_fail (device->priv != NULL);
-
-	p = device->priv;
-
-        if (p->wacom_settings != NULL) {
-                g_object_unref (p->wacom_settings);
-                p->wacom_settings = NULL;
-        }
-
-        g_list_foreach (p->buttons, (GFunc) gsd_wacom_tablet_button_free, NULL);
-        g_list_free (p->buttons);
-
-        g_free (p->name);
-        p->name = NULL;
-
-        g_free (p->tool_name);
-        p->tool_name = NULL;
-
-        g_free (p->icon_name);
-        p->icon_name = NULL;
-
-	gdk_window_remove_filter (NULL,
-				  (GdkFilterFunc) filter_events,
-				  device);
-
-        G_OBJECT_CLASS (gsd_wacom_device_parent_class)->finalize (object);
-}
-
-GsdWacomDevice *
-gsd_wacom_device_new (GdkDevice *device)
-{
-	return GSD_WACOM_DEVICE (g_object_new (GSD_TYPE_WACOM_DEVICE,
-					       "gdk-device", device,
-					       NULL));
-}
-
-GList *
-gsd_wacom_device_list_styli (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return g_list_copy (device->priv->styli);
-}
-
-GsdWacomStylus *
-gsd_wacom_device_get_stylus_for_type (GsdWacomDevice     *device,
-				      GsdWacomStylusType  type)
-{
-	GList *l;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	for (l = device->priv->styli; l != NULL; l = l->next) {
-		GsdWacomStylus *stylus = l->data;
-
-		if (gsd_wacom_stylus_get_stylus_type (stylus) == type)
-			return stylus;
-	}
-	return NULL;
-}
-
-const char *
-gsd_wacom_device_get_name (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->name;
-}
-
-const char *
-gsd_wacom_device_get_icon_name (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->icon_name;
-}
-
-const char *
-gsd_wacom_device_get_tool_name (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->tool_name;
-}
-
-gboolean
-gsd_wacom_device_reversible (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), FALSE);
-
-	return device->priv->reversible;
-}
-
-gboolean
-gsd_wacom_device_is_screen_tablet (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), FALSE);
-
-	return device->priv->is_screen_tablet;
-}
-
-GSettings *
-gsd_wacom_device_get_settings (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->wacom_settings;
-}
-
-void
-gsd_wacom_device_set_current_stylus (GsdWacomDevice *device,
-				     int             stylus_id)
-{
-	GList *l;
-	GsdWacomStylus *stylus;
-
-	g_return_if_fail (GSD_IS_WACOM_DEVICE (device));
-
-	/* Don't change anything if the stylus is already set */
-	if (device->priv->last_stylus != NULL) {
-		GsdWacomStylus *stylus = device->priv->last_stylus;
-		if (stylus->priv->id == stylus_id)
-			return;
-	}
-
-	for (l = device->priv->styli; l; l = l->next) {
-		stylus = l->data;
-
-		/* Set a nice default if 0x0 */
-		if (stylus_id == 0x0 &&
-		    stylus->priv->type == WSTYLUS_GENERAL) {
-			g_object_set (device, "last-stylus", stylus, NULL);
-			return;
-		}
-
-		if (stylus->priv->id == stylus_id) {
-			g_object_set (device, "last-stylus", stylus, NULL);
-			return;
-		}
-	}
-
-	/* Setting the default stylus to be the generic one */
-	for (l = device->priv->styli; l; l = l->next) {
-		stylus = l->data;
-
-		/* Set a nice default if 0x0 */
-		if (stylus->priv->type == WSTYLUS_GENERAL) {
-			g_debug ("Could not find stylus ID 0x%x for tablet '%s', setting general pen ID 0x%x instead",
-				 stylus_id, device->priv->name, stylus->priv->id);
-			g_object_set (device, "last-stylus", stylus, NULL);
-			return;
-		}
-	}
-
-	g_warning ("Could not set the current stylus ID 0x%x for tablet '%s', no general pen found",
-		   stylus_id, device->priv->name);
-
-	/* Setting the default stylus to be the first one */
-	g_assert (device->priv->styli);
-
-	stylus = device->priv->styli->data;
-	g_object_set (device, "last-stylus", stylus, NULL);
-}
-
-GsdWacomDeviceType
-gsd_wacom_device_get_device_type (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), WACOM_TYPE_INVALID);
-
-	return device->priv->type;
-}
-
-gint *
-gsd_wacom_device_get_area (GsdWacomDevice *device)
-{
-	int i, id;
-	XDevice *xdevice;
-	Atom area, realtype;
-	int rc, realformat;
-	unsigned long nitems, bytes_after;
-	unsigned char *data = NULL;
-	gint *device_area;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	g_object_get (device->priv->gdk_device, "device-id", &id, NULL);
-
-	area = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Wacom Tablet Area", False);
-
-	gdk_error_trap_push ();
-	xdevice = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), id);
-	if (gdk_error_trap_pop () || (device == NULL))
-		return NULL;
-
-	gdk_error_trap_push ();
-	rc = XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-				 xdevice, area, 0, 4, False,
-				 XA_INTEGER, &realtype, &realformat, &nitems,
-				 &bytes_after, &data);
-	if (gdk_error_trap_pop () || rc != Success || realtype == None || bytes_after != 0 || nitems != 4) {
-		XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdevice);
-		return NULL;
-	}
-
-	device_area = g_new0 (int, nitems);
-	for (i = 0; i < nitems; i++)
-		device_area[i] = ((long*)data)[i];
-
-	XFree (data);
-	XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdevice);
-
-	return device_area;
-}
-
-const char *
-gsd_wacom_device_type_to_string (GsdWacomDeviceType type)
-{
-	switch (type) {
-	case WACOM_TYPE_INVALID:
-		return "Invalid";
-	case WACOM_TYPE_STYLUS:
-		return "Stylus";
-	case WACOM_TYPE_ERASER:
-		return "Eraser";
-	case WACOM_TYPE_CURSOR:
-		return "Cursor";
-	case WACOM_TYPE_PAD:
-		return "Pad";
-	case WACOM_TYPE_TOUCH:
-		return "Touch";
-	default:
-		return "Unknown type";
-	}
-}
-
-GList *
-gsd_wacom_device_get_buttons (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return g_list_copy (device->priv->buttons);
-}
-
-static GsdWacomTabletButton *
-find_button_with_id (GsdWacomDevice *device,
-		     const char     *id)
-{
-	GList *l;
-
-	for (l = device->priv->buttons; l != NULL; l = l->next) {
-		GsdWacomTabletButton *button = l->data;
-
-		if (g_strcmp0 (button->id, id) == 0)
-			return button;
-	}
-	return NULL;
-}
-
-GsdWacomTabletButton *
-gsd_wacom_device_get_button (GsdWacomDevice   *device,
-			     int               button,
-			     GtkDirectionType *dir)
-{
-	if (button <= 26) {
-		char *id;
-		GsdWacomTabletButton *ret;
-		int physical_button;
-
-		/* mouse_button = physical_button < 4 ? physical_button : physical_button + 4 */
-		if (button > 4)
-			physical_button = button - 4;
-		else
-			physical_button = button;
-
-		id = g_strdup_printf ("button%c", 'A' + physical_button - 1);
-		ret = find_button_with_id (device, id);
-		g_free (id);
-
-		return ret;
-	}
-
-	switch (button) {
-	case 90:
-	case 92:
-	case 94:
-	case 96:
-		*dir = GTK_DIR_UP;
-		break;
-	case 91:
-	case 93:
-	case 95:
-	case 97:
-		*dir = GTK_DIR_DOWN;
-		break;
-	default:
-		;;
-	}
-
-	/* FIXME handle the mode */
-	switch (button) {
-	case 90:
-	case 91:
-		return find_button_with_id (device, "left-ring-mode-1");
-	case 92:
-	case 93:
-		return find_button_with_id (device, "right-ring-mode-1");
-	case 94:
-	case 95:
-		return find_button_with_id (device, "left-strip-mode-1");
-	case 96:
-	case 97:
-		return find_button_with_id (device, "right-strip-mode-1");
-	default:
-		return NULL;
-	}
-}
-
-GsdWacomDevice *
-gsd_wacom_device_create_fake (GsdWacomDeviceType  type,
-			      const char         *name,
-			      const char         *tool_name)
-{
-	GsdWacomDevice *device;
-	GsdWacomDevicePrivate *priv;
-	WacomDevice *wacom_device;
-
-	device = GSD_WACOM_DEVICE (g_object_new (GSD_TYPE_WACOM_DEVICE, NULL));
-
-	if (db == NULL)
-		db = libwacom_database_new ();
-
-	wacom_device = libwacom_new_from_name (db, name, NULL);
-	if (wacom_device == NULL)
-		return NULL;
-
-	priv = device->priv;
-	priv->type = type;
-	priv->tool_name = g_strdup (tool_name);
-	gsd_wacom_device_update_from_db (device, wacom_device, name);
-	libwacom_destroy (wacom_device);
-
-	return device;
-}
-
-GList *
-gsd_wacom_device_create_fake_cintiq (void)
-{
-	GsdWacomDevice *device;
-	GList *devices;
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
-					       "Wacom Cintiq 21UX2",
-					       "Wacom Cintiq 21UX2 stylus");
-	devices = g_list_prepend (NULL, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
-					       "Wacom Cintiq 21UX2",
-					       "Wacom Cintiq 21UX2 eraser");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
-					       "Wacom Cintiq 21UX2",
-					       "Wacom Cintiq 21UX2 pad");
-	devices = g_list_prepend (devices, device);
-
-	return devices;
-}
-
-GList *
-gsd_wacom_device_create_fake_bt (void)
-{
-	GsdWacomDevice *device;
-	GList *devices;
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
-					       "Wacom Graphire Wireless",
-					       "Graphire Wireless stylus");
-	devices = g_list_prepend (NULL, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
-					       "Wacom Graphire Wireless",
-					       "Graphire Wireless eraser");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
-					       "Wacom Graphire Wireless",
-					       "Graphire Wireless pad");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_CURSOR,
-					       "Wacom Graphire Wireless",
-					       "Graphire Wireless cursor");
-	devices = g_list_prepend (devices, device);
-
-	return devices;
-}
-
-GList *
-gsd_wacom_device_create_fake_x201 (void)
-{
-	GsdWacomDevice *device;
-	GList *devices;
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
-					       "Wacom Serial Tablet WACf004",
-					       "Wacom Serial Tablet WACf004 stylus");
-	devices = g_list_prepend (NULL, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
-					       "Wacom Serial Tablet WACf004",
-					       "Wacom Serial Tablet WACf004 eraser");
-	devices = g_list_prepend (devices, device);
-
-	return devices;
-}
-
-GList *
-gsd_wacom_device_create_fake_intuos4 (void)
-{
-	GsdWacomDevice *device;
-	GList *devices;
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
-					       "Wacom Intuos4 6x9",
-					       "Wacom Intuos4 6x9 stylus");
-	devices = g_list_prepend (NULL, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
-					       "Wacom Intuos4 6x9",
-					       "Wacom Intuos4 6x9 eraser");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
-					       "Wacom Intuos4 6x9",
-					       "Wacom Intuos4 6x9 pad");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_CURSOR,
-					       "Wacom Intuos4 6x9",
-					       "Wacom Intuos4 6x9 cursor");
-	devices = g_list_prepend (devices, device);
-
-	return devices;
-}
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/gsd-wacom-device.h gnome-control-center-3.3.90/panels/wacom/gsd-wacom-device.h
--- gnome-control-center-3.3.90.orig/panels/wacom/gsd-wacom-device.h	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/gsd-wacom-device.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#ifndef __GSD_WACOM_DEVICE_MANAGER_H
-#define __GSD_WACOM_DEVICE_MANAGER_H
-
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-#define NUM_ELEMS_MATRIX 9
-
-#define GSD_TYPE_WACOM_DEVICE         (gsd_wacom_device_get_type ())
-#define GSD_WACOM_DEVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDevice))
-#define GSD_WACOM_DEVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_WACOM_DEVICE, GsdWacomDeviceClass))
-#define GSD_IS_WACOM_DEVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_WACOM_DEVICE))
-#define GSD_IS_WACOM_DEVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_WACOM_DEVICE))
-#define GSD_WACOM_DEVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDeviceClass))
-
-typedef struct GsdWacomDevicePrivate GsdWacomDevicePrivate;
-
-typedef struct
-{
-        GObject                parent;
-        GsdWacomDevicePrivate *priv;
-} GsdWacomDevice;
-
-typedef struct
-{
-        GObjectClass   parent_class;
-} GsdWacomDeviceClass;
-
-#define GSD_TYPE_WACOM_STYLUS         (gsd_wacom_stylus_get_type ())
-#define GSD_WACOM_STYLUS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylus))
-#define GSD_WACOM_STYLUS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusClass))
-#define GSD_IS_WACOM_STYLUS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_WACOM_STYLUS))
-#define GSD_IS_WACOM_STYLUS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_WACOM_STYLUS))
-#define GSD_WACOM_STYLUS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusClass))
-
-typedef struct GsdWacomStylusPrivate GsdWacomStylusPrivate;
-
-typedef struct
-{
-        GObject                parent;
-        GsdWacomStylusPrivate *priv;
-} GsdWacomStylus;
-
-typedef struct
-{
-        GObjectClass   parent_class;
-} GsdWacomStylusClass;
-
-typedef enum {
-	WACOM_STYLUS_TYPE_UNKNOWN,
-	WACOM_STYLUS_TYPE_GENERAL,
-	WACOM_STYLUS_TYPE_INKING,
-	WACOM_STYLUS_TYPE_AIRBRUSH,
-	WACOM_STYLUS_TYPE_CLASSIC,
-	WACOM_STYLUS_TYPE_MARKER,
-	WACOM_STYLUS_TYPE_STROKE,
-	WACOM_STYLUS_TYPE_PUCK
-} GsdWacomStylusType;
-
-GType            gsd_wacom_stylus_get_type       (void);
-GSettings      * gsd_wacom_stylus_get_settings   (GsdWacomStylus *stylus);
-const char     * gsd_wacom_stylus_get_name       (GsdWacomStylus *stylus);
-const char     * gsd_wacom_stylus_get_icon_name  (GsdWacomStylus *stylus);
-GsdWacomDevice * gsd_wacom_stylus_get_device     (GsdWacomStylus *stylus);
-gboolean         gsd_wacom_stylus_get_has_eraser (GsdWacomStylus *stylus);
-guint            gsd_wacom_stylus_get_num_buttons(GsdWacomStylus *stylus);
-int              gsd_wacom_stylus_get_id         (GsdWacomStylus *stylus);
-GsdWacomStylusType gsd_wacom_stylus_get_stylus_type (GsdWacomStylus *stylus);
-
-/* Tablet Buttons */
-typedef enum {
-	WACOM_TABLET_BUTTON_TYPE_NORMAL,
-	WACOM_TABLET_BUTTON_TYPE_ELEVATOR,
-	WACOM_TABLET_BUTTON_TYPE_HARDCODED
-} GsdWacomTabletButtonType;
-
-#define MAX_GROUP_ID 4
-
-typedef struct
-{
-	char                     *name;
-	char                     *id;
-	GSettings                *settings;
-	GsdWacomTabletButtonType  type;
-	int                       group_id;
-} GsdWacomTabletButton;
-
-void                  gsd_wacom_tablet_button_free (GsdWacomTabletButton *button);
-GsdWacomTabletButton *gsd_wacom_tablet_button_copy (GsdWacomTabletButton *button);
-
-/* Device types to apply a setting to */
-typedef enum {
-	WACOM_TYPE_INVALID =     0,
-        WACOM_TYPE_STYLUS  =     (1 << 1),
-        WACOM_TYPE_ERASER  =     (1 << 2),
-        WACOM_TYPE_CURSOR  =     (1 << 3),
-        WACOM_TYPE_PAD     =     (1 << 4),
-        WACOM_TYPE_TOUCH   =     (1 << 5),
-        WACOM_TYPE_ALL     =     WACOM_TYPE_STYLUS | WACOM_TYPE_ERASER | WACOM_TYPE_CURSOR | WACOM_TYPE_PAD | WACOM_TYPE_TOUCH
-} GsdWacomDeviceType;
-
-GType gsd_wacom_device_get_type     (void);
-
-void     gsd_wacom_device_set_display         (GsdWacomDevice    *device,
-                                               int                monitor);
-gint     gsd_wacom_device_get_display_monitor (GsdWacomDevice *device);
-gboolean gsd_wacom_device_get_display_matrix  (GsdWacomDevice *device,
-                                               float           matrix[NUM_ELEMS_MATRIX]);
-
-GsdWacomDevice * gsd_wacom_device_new              (GdkDevice *device);
-GList          * gsd_wacom_device_list_styli       (GsdWacomDevice *device);
-const char     * gsd_wacom_device_get_name         (GsdWacomDevice *device);
-const char     * gsd_wacom_device_get_icon_name    (GsdWacomDevice *device);
-const char     * gsd_wacom_device_get_tool_name    (GsdWacomDevice *device);
-gboolean         gsd_wacom_device_reversible       (GsdWacomDevice *device);
-gboolean         gsd_wacom_device_is_screen_tablet (GsdWacomDevice *device);
-GSettings      * gsd_wacom_device_get_settings     (GsdWacomDevice *device);
-void             gsd_wacom_device_set_current_stylus (GsdWacomDevice *device,
-						      int             stylus_id);
-GsdWacomStylus * gsd_wacom_device_get_stylus_for_type (GsdWacomDevice     *device,
-						       GsdWacomStylusType  type);
-
-GsdWacomDeviceType gsd_wacom_device_get_device_type (GsdWacomDevice *device);
-gint           * gsd_wacom_device_get_area          (GsdWacomDevice *device);
-const char     * gsd_wacom_device_type_to_string    (GsdWacomDeviceType type);
-GList          * gsd_wacom_device_get_buttons       (GsdWacomDevice *device);
-GsdWacomTabletButton *gsd_wacom_device_get_button   (GsdWacomDevice   *device,
-						     int               button,
-						     GtkDirectionType *dir);
-
-/* Helper and debug functions */
-GsdWacomDevice * gsd_wacom_device_create_fake (GsdWacomDeviceType  type,
-					       const char         *name,
-					       const char         *tool_name);
-
-GList * gsd_wacom_device_create_fake_cintiq   (void);
-GList * gsd_wacom_device_create_fake_bt       (void);
-GList * gsd_wacom_device_create_fake_x201     (void);
-GList * gsd_wacom_device_create_fake_intuos4  (void);
-
-G_END_DECLS
-
-#endif /* __GSD_WACOM_DEVICE_MANAGER_H */
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/Makefile.am gnome-control-center-3.3.90/panels/wacom/Makefile.am
--- gnome-control-center-3.3.90.orig/panels/wacom/Makefile.am	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/Makefile.am	1969-12-31 19:00:00.000000000 -0500
@@ -1,93 +0,0 @@
-# This is used in PANEL_CFLAGS
-cappletname = wacom
-
-SUBDIRS = calibrator
-
-INCLUDES = 						\
-	$(PANEL_CFLAGS)					\
-	$(WACOM_PANEL_CFLAGS)				\
-	-I$(srcdir)/calibrator				\
-	-DGNOMELOCALEDIR="\"$(datadir)/locale\""	\
-	-DGNOMECC_DATA_DIR="\"$(pkgdatadir)\""		\
-	-DGNOMECC_UI_DIR="\"$(uidir)\""			\
-	$(NULL)
-
-
-ccpanelsdir = $(PANELS_DIR)
-ccpanels_LTLIBRARIES = libwacom-properties.la
-
-libwacom_properties_la_SOURCES =	\
-	wacom-module.c			\
-	cc-wacom-panel.c		\
-	cc-wacom-panel.h		\
-	cc-wacom-page.c			\
-	cc-wacom-page.h			\
-	cc-wacom-stylus-page.c		\
-	cc-wacom-stylus-page.h		\
-	gsd-wacom-device.c		\
-	gsd-wacom-device.h		\
-	gsd-input-helper.c		\
-	gsd-input-helper.h		\
-	cc-wacom-nav-button.c		\
-	cc-wacom-nav-button.h		\
-	cc-wacom-mapping-panel.c	\
-	cc-wacom-mapping-panel.h	\
-	gsd-enums.h
-
-libwacom_properties_la_LIBADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS) $(builddir)/calibrator/libwacom-calibrator.la
-libwacom_properties_la_LDFLAGS = $(PANEL_LDFLAGS)
-
-noinst_PROGRAMS = test-wacom
-
-test_wacom_SOURCES =			\
-	test-wacom.c			\
-	cc-wacom-page.c			\
-	cc-wacom-page.h			\
-	cc-wacom-stylus-page.c		\
-	cc-wacom-stylus-page.h		\
-	cc-wacom-nav-button.c		\
-	cc-wacom-nav-button.h		\
-	cc-wacom-mapping-panel.c	\
-	cc-wacom-mapping-panel.h	\
-	gsd-wacom-device.c		\
-	gsd-wacom-device.h		\
-	gsd-input-helper.c		\
-	gsd-input-helper.h		\
-	gsd-enums.h
-
-test_wacom_CPPFLAGS = $(INCLUDES)
-test_wacom_LDADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS) $(builddir)/calibrator/libwacom-calibrator.la
-
-@INTLTOOL_DESKTOP_RULE@
-
-pixmapdir = $(pkgdatadir)/ui
-pixmap_DATA =				\
-	wacom-tablet.svg		\
-	wacom-stylus.svg		\
-	wacom-stylus-airbrush.svg	\
-	wacom-stylus-inking.svg		\
-	wacom-stylus-art-pen.svg	\
-	wacom-stylus-classic.svg	\
-	wacom-tablet-cintiq.svg		\
-	wacom-tablet-pc.svg
-
-uidir   = $(pkgdatadir)/ui
-ui_DATA = gnome-wacom-properties.ui wacom-stylus-page.ui button-mapping.ui
-
-desktopdir = $(datadir)/applications
-desktop_in_files = gnome-wacom-panel.desktop.in
-desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)
-
-WACOMDIR=$(top_srcdir)/../gnome-settings-daemon/plugins/wacom/
-WACOMFILES=gsd-wacom-device.c gsd-wacom-device.h
-COMMONDIR=$(top_srcdir)/../gnome-settings-daemon/plugins/common/
-COMMONFILES=gsd-input-helper.c gsd-input-helper.h
-update-from-gsd:
-	FILES="$(WACOMFILES)" DIR="$(WACOMDIR)" $(srcdir)/update-from-gsd.sh && changed=true ; \
-	FILES="$(COMMONFILES)" DIR="$(COMMONDIR)" $(srcdir)/update-from-gsd.sh && changed=true ; \
-	git commit -m "wacom: Update from gnome-settings-daemon" $(WACOMFILES) $(COMMONFILES)
-
-CLEANFILES = $(Desktop_in_files) $(desktop_DATA)
-EXTRA_DIST = $(ui_DATA) $(pixmap_DATA)
-
--include $(top_srcdir)/git.mk
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/Makefile.in gnome-control-center-3.3.90/panels/wacom/Makefile.in
--- gnome-control-center-3.3.90.orig/panels/wacom/Makefile.in	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/Makefile.in	1969-12-31 19:00:00.000000000 -0500
@@ -1,1087 +0,0 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-
-
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-noinst_PROGRAMS = test-wacom$(EXEEXT)
-subdir = panels/wacom
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(srcdir)/gnome-wacom-panel.desktop.in.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/gnome-doc-utils.m4 \
-	$(top_srcdir)/m4/intltool.m4 $(top_srcdir)/m4/libtool.m4 \
-	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
-	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES = gnome-wacom-panel.desktop.in
-CONFIG_CLEAN_VPATH_FILES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__uninstall_files_from_dir = { \
-  test -z "$$files" \
-    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
-    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
-         $(am__cd) "$$dir" && rm -f $$files; }; \
-  }
-am__installdirs = "$(DESTDIR)$(ccpanelsdir)" "$(DESTDIR)$(desktopdir)" \
-	"$(DESTDIR)$(pixmapdir)" "$(DESTDIR)$(uidir)"
-LTLIBRARIES = $(ccpanels_LTLIBRARIES)
-am__DEPENDENCIES_1 =
-libwacom_properties_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) \
-	$(builddir)/calibrator/libwacom-calibrator.la
-am_libwacom_properties_la_OBJECTS = wacom-module.lo cc-wacom-panel.lo \
-	cc-wacom-page.lo cc-wacom-stylus-page.lo gsd-wacom-device.lo \
-	gsd-input-helper.lo cc-wacom-nav-button.lo \
-	cc-wacom-mapping-panel.lo
-libwacom_properties_la_OBJECTS = $(am_libwacom_properties_la_OBJECTS)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-libwacom_properties_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
-	$(AM_CFLAGS) $(CFLAGS) $(libwacom_properties_la_LDFLAGS) \
-	$(LDFLAGS) -o $@
-PROGRAMS = $(noinst_PROGRAMS)
-am_test_wacom_OBJECTS = test_wacom-test-wacom.$(OBJEXT) \
-	test_wacom-cc-wacom-page.$(OBJEXT) \
-	test_wacom-cc-wacom-stylus-page.$(OBJEXT) \
-	test_wacom-cc-wacom-nav-button.$(OBJEXT) \
-	test_wacom-cc-wacom-mapping-panel.$(OBJEXT) \
-	test_wacom-gsd-wacom-device.$(OBJEXT) \
-	test_wacom-gsd-input-helper.$(OBJEXT)
-test_wacom_OBJECTS = $(am_test_wacom_OBJECTS)
-test_wacom_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(builddir)/calibrator/libwacom-calibrator.la
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-AM_V_CC = $(am__v_CC_@AM_V@)
-am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-CCLD = $(CC)
-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CCLD = $(am__v_CCLD_@AM_V@)
-am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
-SOURCES = $(libwacom_properties_la_SOURCES) $(test_wacom_SOURCES)
-DIST_SOURCES = $(libwacom_properties_la_SOURCES) $(test_wacom_SOURCES)
-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
-	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
-DATA = $(desktop_DATA) $(pixmap_DATA) $(ui_DATA)
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
-AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
-	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
-	distdir
-ETAGS = etags
-CTAGS = ctags
-DIST_SUBDIRS = $(SUBDIRS)
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-am__relativize = \
-  dir0=`pwd`; \
-  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
-  sed_rest='s,^[^/]*/*,,'; \
-  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
-  sed_butlast='s,/*[^/]*$$,,'; \
-  while test -n "$$dir1"; do \
-    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
-    if test "$$first" != "."; then \
-      if test "$$first" = ".."; then \
-        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
-        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
-      else \
-        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
-        if test "$$first2" = "$$first"; then \
-          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
-        else \
-          dir2="../$$dir2"; \
-        fi; \
-        dir0="$$dir0"/"$$first"; \
-      fi; \
-    fi; \
-    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
-  done; \
-  reldir="$$dir2"
-ACLOCAL = @ACLOCAL@
-ALL_LINGUAS = @ALL_LINGUAS@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-BACKGROUND_PANEL_CFLAGS = @BACKGROUND_PANEL_CFLAGS@
-BACKGROUND_PANEL_LIBS = @BACKGROUND_PANEL_LIBS@
-BLUETOOTH_CFLAGS = @BLUETOOTH_CFLAGS@
-BLUETOOTH_LIBS = @BLUETOOTH_LIBS@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CHEESE_CFLAGS = @CHEESE_CFLAGS@
-CHEESE_LIBS = @CHEESE_LIBS@
-COLOR_PANEL_CFLAGS = @COLOR_PANEL_CFLAGS@
-COLOR_PANEL_LIBS = @COLOR_PANEL_LIBS@
-CONTROL_CENTER_VERSION = @CONTROL_CENTER_VERSION@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CUPS_CFLAGS = @CUPS_CFLAGS@
-CUPS_CONFIG = @CUPS_CONFIG@
-CUPS_LIBS = @CUPS_LIBS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DATETIME_PANEL_CFLAGS = @DATETIME_PANEL_CFLAGS@
-DATETIME_PANEL_LIBS = @DATETIME_PANEL_LIBS@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DISPLAY_PANEL_CFLAGS = @DISPLAY_PANEL_CFLAGS@
-DISPLAY_PANEL_LIBS = @DISPLAY_PANEL_LIBS@
-DISTCHECK_CONFIGURE_FLAGS = @DISTCHECK_CONFIGURE_FLAGS@
-DLLTOOL = @DLLTOOL@
-DOC_USER_FORMATS = @DOC_USER_FORMATS@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GDESKTOP_PREFIX = @GDESKTOP_PREFIX@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
-GLIB_MKENUMS = @GLIB_MKENUMS@
-GMSGFMT = @GMSGFMT@
-GREP = @GREP@
-HELP_DIR = @HELP_DIR@
-INFO_PANEL_CFLAGS = @INFO_PANEL_CFLAGS@
-INFO_PANEL_LIBS = @INFO_PANEL_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
-INTLTOOL_MERGE = @INTLTOOL_MERGE@
-INTLTOOL_PERL = @INTLTOOL_PERL@
-INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
-ISOCODES_CFLAGS = @ISOCODES_CFLAGS@
-ISOCODES_LIBS = @ISOCODES_LIBS@
-KEYBOARD_PANEL_CFLAGS = @KEYBOARD_PANEL_CFLAGS@
-KEYBOARD_PANEL_LIBS = @KEYBOARD_PANEL_LIBS@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBGNOMECONTROLCENTER_AGE = @LIBGNOMECONTROLCENTER_AGE@
-LIBGNOMECONTROLCENTER_CURRENT = @LIBGNOMECONTROLCENTER_CURRENT@
-LIBGNOMECONTROLCENTER_REVISION = @LIBGNOMECONTROLCENTER_REVISION@
-LIBGNOME_CONTROL_CENTER_CFLAGS = @LIBGNOME_CONTROL_CENTER_CFLAGS@
-LIBGNOME_CONTROL_CENTER_LIBS = @LIBGNOME_CONTROL_CENTER_LIBS@
-LIBLANGUAGE_CFLAGS = @LIBLANGUAGE_CFLAGS@
-LIBLANGUAGE_LIBS = @LIBLANGUAGE_LIBS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBSHORTCUTS_CFLAGS = @LIBSHORTCUTS_CFLAGS@
-LIBSHORTCUTS_LIBS = @LIBSHORTCUTS_LIBS@
-LIBTOOL = @LIBTOOL@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MEDIA_PANEL_CFLAGS = @MEDIA_PANEL_CFLAGS@
-MEDIA_PANEL_LIBS = @MEDIA_PANEL_LIBS@
-MKDIR_P = @MKDIR_P@
-MOUSE_PANEL_CFLAGS = @MOUSE_PANEL_CFLAGS@
-MOUSE_PANEL_LIBS = @MOUSE_PANEL_LIBS@
-MSGFMT = @MSGFMT@
-MSGMERGE = @MSGMERGE@
-NETWORK_MANAGER_CFLAGS = @NETWORK_MANAGER_CFLAGS@
-NETWORK_MANAGER_LIBS = @NETWORK_MANAGER_LIBS@
-NETWORK_PANEL_CFLAGS = @NETWORK_PANEL_CFLAGS@
-NETWORK_PANEL_LIBS = @NETWORK_PANEL_LIBS@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OMF_DIR = @OMF_DIR@
-ONLINE_ACCOUNTS_PANEL_CFLAGS = @ONLINE_ACCOUNTS_PANEL_CFLAGS@
-ONLINE_ACCOUNTS_PANEL_LIBS = @ONLINE_ACCOUNTS_PANEL_LIBS@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PANELS_DIR = @PANELS_DIR@
-PANEL_CFLAGS = @PANEL_CFLAGS@
-PANEL_LDFLAGS = @PANEL_LDFLAGS@
-PANEL_LIBS = @PANEL_LIBS@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-POWER_PANEL_CFLAGS = @POWER_PANEL_CFLAGS@
-POWER_PANEL_LIBS = @POWER_PANEL_LIBS@
-PRINTERS_PANEL_CFLAGS = @PRINTERS_PANEL_CFLAGS@
-PRINTERS_PANEL_LIBS = @PRINTERS_PANEL_LIBS@
-RANLIB = @RANLIB@
-REGION_PANEL_CFLAGS = @REGION_PANEL_CFLAGS@
-REGION_PANEL_LIBS = @REGION_PANEL_LIBS@
-SCREEN_PANEL_CFLAGS = @SCREEN_PANEL_CFLAGS@
-SCREEN_PANEL_LIBS = @SCREEN_PANEL_LIBS@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-SHELL_CFLAGS = @SHELL_CFLAGS@
-SHELL_LIBS = @SHELL_LIBS@
-SOCIALWEB_CFLAGS = @SOCIALWEB_CFLAGS@
-SOCIALWEB_LIBS = @SOCIALWEB_LIBS@
-SOUND_PANEL_CFLAGS = @SOUND_PANEL_CFLAGS@
-SOUND_PANEL_LIBS = @SOUND_PANEL_LIBS@
-STRIP = @STRIP@
-UNIVERSAL_ACCESS_PANEL_CFLAGS = @UNIVERSAL_ACCESS_PANEL_CFLAGS@
-UNIVERSAL_ACCESS_PANEL_LIBS = @UNIVERSAL_ACCESS_PANEL_LIBS@
-UPDATE_MIME_DATABASE = @UPDATE_MIME_DATABASE@
-USER_ACCOUNTS_PANEL_CFLAGS = @USER_ACCOUNTS_PANEL_CFLAGS@
-USER_ACCOUNTS_PANEL_LIBS = @USER_ACCOUNTS_PANEL_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-WACOM_PANEL_CFLAGS = @WACOM_PANEL_CFLAGS@
-WACOM_PANEL_LIBS = @WACOM_PANEL_LIBS@
-WARN_CFLAGS = @WARN_CFLAGS@
-XF86MISC_LIBS = @XF86MISC_LIBS@
-XGETTEXT = @XGETTEXT@
-XMKMF = @XMKMF@
-X_CFLAGS = @X_CFLAGS@
-X_EXTRA_LIBS = @X_EXTRA_LIBS@
-X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-
-# This is used in PANEL_CFLAGS
-cappletname = wacom
-SUBDIRS = calibrator
-INCLUDES = \
-	$(PANEL_CFLAGS)					\
-	$(WACOM_PANEL_CFLAGS)				\
-	-I$(srcdir)/calibrator				\
-	-DGNOMELOCALEDIR="\"$(datadir)/locale\""	\
-	-DGNOMECC_DATA_DIR="\"$(pkgdatadir)\""		\
-	-DGNOMECC_UI_DIR="\"$(uidir)\""			\
-	$(NULL)
-
-ccpanelsdir = $(PANELS_DIR)
-ccpanels_LTLIBRARIES = libwacom-properties.la
-libwacom_properties_la_SOURCES = \
-	wacom-module.c			\
-	cc-wacom-panel.c		\
-	cc-wacom-panel.h		\
-	cc-wacom-page.c			\
-	cc-wacom-page.h			\
-	cc-wacom-stylus-page.c		\
-	cc-wacom-stylus-page.h		\
-	gsd-wacom-device.c		\
-	gsd-wacom-device.h		\
-	gsd-input-helper.c		\
-	gsd-input-helper.h		\
-	cc-wacom-nav-button.c		\
-	cc-wacom-nav-button.h		\
-	cc-wacom-mapping-panel.c	\
-	cc-wacom-mapping-panel.h	\
-	gsd-enums.h
-
-libwacom_properties_la_LIBADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS) $(builddir)/calibrator/libwacom-calibrator.la
-libwacom_properties_la_LDFLAGS = $(PANEL_LDFLAGS)
-test_wacom_SOURCES = \
-	test-wacom.c			\
-	cc-wacom-page.c			\
-	cc-wacom-page.h			\
-	cc-wacom-stylus-page.c		\
-	cc-wacom-stylus-page.h		\
-	cc-wacom-nav-button.c		\
-	cc-wacom-nav-button.h		\
-	cc-wacom-mapping-panel.c	\
-	cc-wacom-mapping-panel.h	\
-	gsd-wacom-device.c		\
-	gsd-wacom-device.h		\
-	gsd-input-helper.c		\
-	gsd-input-helper.h		\
-	gsd-enums.h
-
-test_wacom_CPPFLAGS = $(INCLUDES)
-test_wacom_LDADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS) $(builddir)/calibrator/libwacom-calibrator.la
-pixmapdir = $(pkgdatadir)/ui
-pixmap_DATA = \
-	wacom-tablet.svg		\
-	wacom-stylus.svg		\
-	wacom-stylus-airbrush.svg	\
-	wacom-stylus-inking.svg		\
-	wacom-stylus-art-pen.svg	\
-	wacom-stylus-classic.svg	\
-	wacom-tablet-cintiq.svg		\
-	wacom-tablet-pc.svg
-
-uidir = $(pkgdatadir)/ui
-ui_DATA = gnome-wacom-properties.ui wacom-stylus-page.ui button-mapping.ui
-desktopdir = $(datadir)/applications
-desktop_in_files = gnome-wacom-panel.desktop.in
-desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)
-WACOMDIR = $(top_srcdir)/../gnome-settings-daemon/plugins/wacom/
-WACOMFILES = gsd-wacom-device.c gsd-wacom-device.h
-COMMONDIR = $(top_srcdir)/../gnome-settings-daemon/plugins/common/
-COMMONFILES = gsd-input-helper.c gsd-input-helper.h
-CLEANFILES = $(Desktop_in_files) $(desktop_DATA)
-EXTRA_DIST = $(ui_DATA) $(pixmap_DATA)
-all: all-recursive
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu panels/wacom/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu panels/wacom/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-gnome-wacom-panel.desktop.in: $(top_builddir)/config.status $(srcdir)/gnome-wacom-panel.desktop.in.in
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
-install-ccpanelsLTLIBRARIES: $(ccpanels_LTLIBRARIES)
-	@$(NORMAL_INSTALL)
-	test -z "$(ccpanelsdir)" || $(MKDIR_P) "$(DESTDIR)$(ccpanelsdir)"
-	@list='$(ccpanels_LTLIBRARIES)'; test -n "$(ccpanelsdir)" || list=; \
-	list2=; for p in $$list; do \
-	  if test -f $$p; then \
-	    list2="$$list2 $$p"; \
-	  else :; fi; \
-	done; \
-	test -z "$$list2" || { \
-	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(ccpanelsdir)'"; \
-	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(ccpanelsdir)"; \
-	}
-
-uninstall-ccpanelsLTLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@list='$(ccpanels_LTLIBRARIES)'; test -n "$(ccpanelsdir)" || list=; \
-	for p in $$list; do \
-	  $(am__strip_dir) \
-	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(ccpanelsdir)/$$f'"; \
-	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(ccpanelsdir)/$$f"; \
-	done
-
-clean-ccpanelsLTLIBRARIES:
-	-test -z "$(ccpanels_LTLIBRARIES)" || rm -f $(ccpanels_LTLIBRARIES)
-	@list='$(ccpanels_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
-libwacom-properties.la: $(libwacom_properties_la_OBJECTS) $(libwacom_properties_la_DEPENDENCIES) $(EXTRA_libwacom_properties_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(libwacom_properties_la_LINK) -rpath $(ccpanelsdir) $(libwacom_properties_la_OBJECTS) $(libwacom_properties_la_LIBADD) $(LIBS)
-
-clean-noinstPROGRAMS:
-	@list='$(noinst_PROGRAMS)'; test -n "$$list" || exit 0; \
-	echo " rm -f" $$list; \
-	rm -f $$list || exit $$?; \
-	test -n "$(EXEEXT)" || exit 0; \
-	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
-	echo " rm -f" $$list; \
-	rm -f $$list
-test-wacom$(EXEEXT): $(test_wacom_OBJECTS) $(test_wacom_DEPENDENCIES) $(EXTRA_test_wacom_DEPENDENCIES) 
-	@rm -f test-wacom$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(test_wacom_OBJECTS) $(test_wacom_LDADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cc-wacom-mapping-panel.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cc-wacom-nav-button.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cc-wacom-page.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cc-wacom-panel.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cc-wacom-stylus-page.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gsd-input-helper.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gsd-wacom-device.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_wacom-cc-wacom-mapping-panel.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_wacom-cc-wacom-nav-button.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_wacom-cc-wacom-page.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_wacom-cc-wacom-stylus-page.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_wacom-gsd-input-helper.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_wacom-gsd-wacom-device.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_wacom-test-wacom.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wacom-module.Plo@am__quote@
-
-.c.o:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c $<
-
-.c.obj:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
-
-test_wacom-test-wacom.o: test-wacom.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-test-wacom.o -MD -MP -MF $(DEPDIR)/test_wacom-test-wacom.Tpo -c -o test_wacom-test-wacom.o `test -f 'test-wacom.c' || echo '$(srcdir)/'`test-wacom.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-test-wacom.Tpo $(DEPDIR)/test_wacom-test-wacom.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='test-wacom.c' object='test_wacom-test-wacom.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-test-wacom.o `test -f 'test-wacom.c' || echo '$(srcdir)/'`test-wacom.c
-
-test_wacom-test-wacom.obj: test-wacom.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-test-wacom.obj -MD -MP -MF $(DEPDIR)/test_wacom-test-wacom.Tpo -c -o test_wacom-test-wacom.obj `if test -f 'test-wacom.c'; then $(CYGPATH_W) 'test-wacom.c'; else $(CYGPATH_W) '$(srcdir)/test-wacom.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-test-wacom.Tpo $(DEPDIR)/test_wacom-test-wacom.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='test-wacom.c' object='test_wacom-test-wacom.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-test-wacom.obj `if test -f 'test-wacom.c'; then $(CYGPATH_W) 'test-wacom.c'; else $(CYGPATH_W) '$(srcdir)/test-wacom.c'; fi`
-
-test_wacom-cc-wacom-page.o: cc-wacom-page.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-cc-wacom-page.o -MD -MP -MF $(DEPDIR)/test_wacom-cc-wacom-page.Tpo -c -o test_wacom-cc-wacom-page.o `test -f 'cc-wacom-page.c' || echo '$(srcdir)/'`cc-wacom-page.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-cc-wacom-page.Tpo $(DEPDIR)/test_wacom-cc-wacom-page.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cc-wacom-page.c' object='test_wacom-cc-wacom-page.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-cc-wacom-page.o `test -f 'cc-wacom-page.c' || echo '$(srcdir)/'`cc-wacom-page.c
-
-test_wacom-cc-wacom-page.obj: cc-wacom-page.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-cc-wacom-page.obj -MD -MP -MF $(DEPDIR)/test_wacom-cc-wacom-page.Tpo -c -o test_wacom-cc-wacom-page.obj `if test -f 'cc-wacom-page.c'; then $(CYGPATH_W) 'cc-wacom-page.c'; else $(CYGPATH_W) '$(srcdir)/cc-wacom-page.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-cc-wacom-page.Tpo $(DEPDIR)/test_wacom-cc-wacom-page.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cc-wacom-page.c' object='test_wacom-cc-wacom-page.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-cc-wacom-page.obj `if test -f 'cc-wacom-page.c'; then $(CYGPATH_W) 'cc-wacom-page.c'; else $(CYGPATH_W) '$(srcdir)/cc-wacom-page.c'; fi`
-
-test_wacom-cc-wacom-stylus-page.o: cc-wacom-stylus-page.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-cc-wacom-stylus-page.o -MD -MP -MF $(DEPDIR)/test_wacom-cc-wacom-stylus-page.Tpo -c -o test_wacom-cc-wacom-stylus-page.o `test -f 'cc-wacom-stylus-page.c' || echo '$(srcdir)/'`cc-wacom-stylus-page.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-cc-wacom-stylus-page.Tpo $(DEPDIR)/test_wacom-cc-wacom-stylus-page.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cc-wacom-stylus-page.c' object='test_wacom-cc-wacom-stylus-page.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-cc-wacom-stylus-page.o `test -f 'cc-wacom-stylus-page.c' || echo '$(srcdir)/'`cc-wacom-stylus-page.c
-
-test_wacom-cc-wacom-stylus-page.obj: cc-wacom-stylus-page.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-cc-wacom-stylus-page.obj -MD -MP -MF $(DEPDIR)/test_wacom-cc-wacom-stylus-page.Tpo -c -o test_wacom-cc-wacom-stylus-page.obj `if test -f 'cc-wacom-stylus-page.c'; then $(CYGPATH_W) 'cc-wacom-stylus-page.c'; else $(CYGPATH_W) '$(srcdir)/cc-wacom-stylus-page.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-cc-wacom-stylus-page.Tpo $(DEPDIR)/test_wacom-cc-wacom-stylus-page.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cc-wacom-stylus-page.c' object='test_wacom-cc-wacom-stylus-page.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-cc-wacom-stylus-page.obj `if test -f 'cc-wacom-stylus-page.c'; then $(CYGPATH_W) 'cc-wacom-stylus-page.c'; else $(CYGPATH_W) '$(srcdir)/cc-wacom-stylus-page.c'; fi`
-
-test_wacom-cc-wacom-nav-button.o: cc-wacom-nav-button.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-cc-wacom-nav-button.o -MD -MP -MF $(DEPDIR)/test_wacom-cc-wacom-nav-button.Tpo -c -o test_wacom-cc-wacom-nav-button.o `test -f 'cc-wacom-nav-button.c' || echo '$(srcdir)/'`cc-wacom-nav-button.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-cc-wacom-nav-button.Tpo $(DEPDIR)/test_wacom-cc-wacom-nav-button.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cc-wacom-nav-button.c' object='test_wacom-cc-wacom-nav-button.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-cc-wacom-nav-button.o `test -f 'cc-wacom-nav-button.c' || echo '$(srcdir)/'`cc-wacom-nav-button.c
-
-test_wacom-cc-wacom-nav-button.obj: cc-wacom-nav-button.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-cc-wacom-nav-button.obj -MD -MP -MF $(DEPDIR)/test_wacom-cc-wacom-nav-button.Tpo -c -o test_wacom-cc-wacom-nav-button.obj `if test -f 'cc-wacom-nav-button.c'; then $(CYGPATH_W) 'cc-wacom-nav-button.c'; else $(CYGPATH_W) '$(srcdir)/cc-wacom-nav-button.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-cc-wacom-nav-button.Tpo $(DEPDIR)/test_wacom-cc-wacom-nav-button.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cc-wacom-nav-button.c' object='test_wacom-cc-wacom-nav-button.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-cc-wacom-nav-button.obj `if test -f 'cc-wacom-nav-button.c'; then $(CYGPATH_W) 'cc-wacom-nav-button.c'; else $(CYGPATH_W) '$(srcdir)/cc-wacom-nav-button.c'; fi`
-
-test_wacom-cc-wacom-mapping-panel.o: cc-wacom-mapping-panel.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-cc-wacom-mapping-panel.o -MD -MP -MF $(DEPDIR)/test_wacom-cc-wacom-mapping-panel.Tpo -c -o test_wacom-cc-wacom-mapping-panel.o `test -f 'cc-wacom-mapping-panel.c' || echo '$(srcdir)/'`cc-wacom-mapping-panel.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-cc-wacom-mapping-panel.Tpo $(DEPDIR)/test_wacom-cc-wacom-mapping-panel.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cc-wacom-mapping-panel.c' object='test_wacom-cc-wacom-mapping-panel.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-cc-wacom-mapping-panel.o `test -f 'cc-wacom-mapping-panel.c' || echo '$(srcdir)/'`cc-wacom-mapping-panel.c
-
-test_wacom-cc-wacom-mapping-panel.obj: cc-wacom-mapping-panel.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-cc-wacom-mapping-panel.obj -MD -MP -MF $(DEPDIR)/test_wacom-cc-wacom-mapping-panel.Tpo -c -o test_wacom-cc-wacom-mapping-panel.obj `if test -f 'cc-wacom-mapping-panel.c'; then $(CYGPATH_W) 'cc-wacom-mapping-panel.c'; else $(CYGPATH_W) '$(srcdir)/cc-wacom-mapping-panel.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-cc-wacom-mapping-panel.Tpo $(DEPDIR)/test_wacom-cc-wacom-mapping-panel.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cc-wacom-mapping-panel.c' object='test_wacom-cc-wacom-mapping-panel.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-cc-wacom-mapping-panel.obj `if test -f 'cc-wacom-mapping-panel.c'; then $(CYGPATH_W) 'cc-wacom-mapping-panel.c'; else $(CYGPATH_W) '$(srcdir)/cc-wacom-mapping-panel.c'; fi`
-
-test_wacom-gsd-wacom-device.o: gsd-wacom-device.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-gsd-wacom-device.o -MD -MP -MF $(DEPDIR)/test_wacom-gsd-wacom-device.Tpo -c -o test_wacom-gsd-wacom-device.o `test -f 'gsd-wacom-device.c' || echo '$(srcdir)/'`gsd-wacom-device.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-gsd-wacom-device.Tpo $(DEPDIR)/test_wacom-gsd-wacom-device.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gsd-wacom-device.c' object='test_wacom-gsd-wacom-device.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-gsd-wacom-device.o `test -f 'gsd-wacom-device.c' || echo '$(srcdir)/'`gsd-wacom-device.c
-
-test_wacom-gsd-wacom-device.obj: gsd-wacom-device.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-gsd-wacom-device.obj -MD -MP -MF $(DEPDIR)/test_wacom-gsd-wacom-device.Tpo -c -o test_wacom-gsd-wacom-device.obj `if test -f 'gsd-wacom-device.c'; then $(CYGPATH_W) 'gsd-wacom-device.c'; else $(CYGPATH_W) '$(srcdir)/gsd-wacom-device.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-gsd-wacom-device.Tpo $(DEPDIR)/test_wacom-gsd-wacom-device.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gsd-wacom-device.c' object='test_wacom-gsd-wacom-device.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-gsd-wacom-device.obj `if test -f 'gsd-wacom-device.c'; then $(CYGPATH_W) 'gsd-wacom-device.c'; else $(CYGPATH_W) '$(srcdir)/gsd-wacom-device.c'; fi`
-
-test_wacom-gsd-input-helper.o: gsd-input-helper.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-gsd-input-helper.o -MD -MP -MF $(DEPDIR)/test_wacom-gsd-input-helper.Tpo -c -o test_wacom-gsd-input-helper.o `test -f 'gsd-input-helper.c' || echo '$(srcdir)/'`gsd-input-helper.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-gsd-input-helper.Tpo $(DEPDIR)/test_wacom-gsd-input-helper.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gsd-input-helper.c' object='test_wacom-gsd-input-helper.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-gsd-input-helper.o `test -f 'gsd-input-helper.c' || echo '$(srcdir)/'`gsd-input-helper.c
-
-test_wacom-gsd-input-helper.obj: gsd-input-helper.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_wacom-gsd-input-helper.obj -MD -MP -MF $(DEPDIR)/test_wacom-gsd-input-helper.Tpo -c -o test_wacom-gsd-input-helper.obj `if test -f 'gsd-input-helper.c'; then $(CYGPATH_W) 'gsd-input-helper.c'; else $(CYGPATH_W) '$(srcdir)/gsd-input-helper.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_wacom-gsd-input-helper.Tpo $(DEPDIR)/test_wacom-gsd-input-helper.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gsd-input-helper.c' object='test_wacom-gsd-input-helper.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_wacom_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_wacom-gsd-input-helper.obj `if test -f 'gsd-input-helper.c'; then $(CYGPATH_W) 'gsd-input-helper.c'; else $(CYGPATH_W) '$(srcdir)/gsd-input-helper.c'; fi`
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-install-desktopDATA: $(desktop_DATA)
-	@$(NORMAL_INSTALL)
-	test -z "$(desktopdir)" || $(MKDIR_P) "$(DESTDIR)$(desktopdir)"
-	@list='$(desktop_DATA)'; test -n "$(desktopdir)" || list=; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  echo "$$d$$p"; \
-	done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(desktopdir)'"; \
-	  $(INSTALL_DATA) $$files "$(DESTDIR)$(desktopdir)" || exit $$?; \
-	done
-
-uninstall-desktopDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(desktop_DATA)'; test -n "$(desktopdir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	dir='$(DESTDIR)$(desktopdir)'; $(am__uninstall_files_from_dir)
-install-pixmapDATA: $(pixmap_DATA)
-	@$(NORMAL_INSTALL)
-	test -z "$(pixmapdir)" || $(MKDIR_P) "$(DESTDIR)$(pixmapdir)"
-	@list='$(pixmap_DATA)'; test -n "$(pixmapdir)" || list=; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  echo "$$d$$p"; \
-	done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(pixmapdir)'"; \
-	  $(INSTALL_DATA) $$files "$(DESTDIR)$(pixmapdir)" || exit $$?; \
-	done
-
-uninstall-pixmapDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(pixmap_DATA)'; test -n "$(pixmapdir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	dir='$(DESTDIR)$(pixmapdir)'; $(am__uninstall_files_from_dir)
-install-uiDATA: $(ui_DATA)
-	@$(NORMAL_INSTALL)
-	test -z "$(uidir)" || $(MKDIR_P) "$(DESTDIR)$(uidir)"
-	@list='$(ui_DATA)'; test -n "$(uidir)" || list=; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  echo "$$d$$p"; \
-	done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(uidir)'"; \
-	  $(INSTALL_DATA) $$files "$(DESTDIR)$(uidir)" || exit $$?; \
-	done
-
-uninstall-uiDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(ui_DATA)'; test -n "$(uidir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	dir='$(DESTDIR)$(uidir)'; $(am__uninstall_files_from_dir)
-
-# This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    dot_seen=yes; \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done; \
-	if test "$$dot_seen" = "no"; then \
-	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
-	fi; test -z "$$fail"
-
-$(RECURSIVE_CLEAN_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test "$$subdir" = "."; then :; else \
-	    rev="$$subdir $$rev"; \
-	  fi; \
-	done; \
-	rev="$$rev ."; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done && test -z "$$fail"
-tags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
-	done
-ctags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
-	done
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	set x; \
-	here=`pwd`; \
-	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
-	  include_option=--etags-include; \
-	  empty_fix=.; \
-	else \
-	  include_option=--include; \
-	  empty_fix=; \
-	fi; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    test ! -f $$subdir/TAGS || \
-	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
-	  fi; \
-	done; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: CTAGS
-CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
-	    $(am__relativize); \
-	    new_distdir=$$reldir; \
-	    dir1=$$subdir; dir2="$(top_distdir)"; \
-	    $(am__relativize); \
-	    new_top_distdir=$$reldir; \
-	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
-	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
-	    ($(am__cd) $$subdir && \
-	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir="$$new_top_distdir" \
-	        distdir="$$new_distdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
-		am__skip_mode_fix=: \
-	        distdir) \
-	      || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-recursive
-all-am: Makefile $(LTLIBRARIES) $(PROGRAMS) $(DATA)
-installdirs: installdirs-recursive
-installdirs-am:
-	for dir in "$(DESTDIR)$(ccpanelsdir)" "$(DESTDIR)$(desktopdir)" "$(DESTDIR)$(pixmapdir)" "$(DESTDIR)$(uidir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-recursive
-install-exec: install-exec-recursive
-install-data: install-data-recursive
-uninstall: uninstall-recursive
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-recursive
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-recursive
-
-clean-am: clean-ccpanelsLTLIBRARIES clean-generic clean-libtool \
-	clean-noinstPROGRAMS mostlyclean-am
-
-distclean: distclean-recursive
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-recursive
-
-dvi-am:
-
-html: html-recursive
-
-html-am:
-
-info: info-recursive
-
-info-am:
-
-install-data-am: install-ccpanelsLTLIBRARIES install-desktopDATA \
-	install-pixmapDATA install-uiDATA
-
-install-dvi: install-dvi-recursive
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-recursive
-
-install-html-am:
-
-install-info: install-info-recursive
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-recursive
-
-install-pdf-am:
-
-install-ps: install-ps-recursive
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-recursive
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-recursive
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-recursive
-
-pdf-am:
-
-ps: ps-recursive
-
-ps-am:
-
-uninstall-am: uninstall-ccpanelsLTLIBRARIES uninstall-desktopDATA \
-	uninstall-pixmapDATA uninstall-uiDATA
-
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
-	install-am install-strip tags-recursive
-
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-am clean clean-ccpanelsLTLIBRARIES \
-	clean-generic clean-libtool clean-noinstPROGRAMS ctags \
-	ctags-recursive distclean distclean-compile distclean-generic \
-	distclean-libtool distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am \
-	install-ccpanelsLTLIBRARIES install-data install-data-am \
-	install-desktopDATA install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-pixmapDATA install-ps install-ps-am install-strip \
-	install-uiDATA installcheck installcheck-am installdirs \
-	installdirs-am maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
-	uninstall uninstall-am uninstall-ccpanelsLTLIBRARIES \
-	uninstall-desktopDATA uninstall-pixmapDATA uninstall-uiDATA
-
-
-@INTLTOOL_DESKTOP_RULE@
-update-from-gsd:
-	FILES="$(WACOMFILES)" DIR="$(WACOMDIR)" $(srcdir)/update-from-gsd.sh && changed=true ; \
-	FILES="$(COMMONFILES)" DIR="$(COMMONDIR)" $(srcdir)/update-from-gsd.sh && changed=true ; \
-	git commit -m "wacom: Update from gnome-settings-daemon" $(WACOMFILES) $(COMMONFILES)
-
--include $(top_srcdir)/git.mk
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/test-wacom.c gnome-control-center-3.3.90/panels/wacom/test-wacom.c
--- gnome-control-center-3.3.90.orig/panels/wacom/test-wacom.c	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/test-wacom.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,103 +0,0 @@
-
-#include "config.h"
-
-#include <glib/gi18n.h>
-
-#include "cc-wacom-page.h"
-#include "gsd-wacom-device.h"
-
-#define FIXED_WIDTH 675
-
-void
-cc_wacom_panel_switch_to_panel (CcWacomPanel *self, const char *panel)
-{
-	g_message ("Should launch display preferences here");
-}
-
-static void
-add_page (GList *devices,
-	  GtkWidget *notebook)
-{
-	GtkWidget *widget;
-	GsdWacomDevice *stylus, *eraser, *pad;
-	GList *l;
-
-	if (devices == NULL)
-		return;
-
-	stylus = eraser = pad = NULL;
-	for (l = devices; l ; l = l->next) {
-		switch (gsd_wacom_device_get_device_type (l->data)) {
-		case WACOM_TYPE_ERASER:
-			eraser = l->data;
-			break;
-		case WACOM_TYPE_STYLUS:
-			stylus = l->data;
-			break;
-		case WACOM_TYPE_PAD:
-			pad = l->data;
-			break;
-		default:
-			/* Nothing */
-			;
-		}
-	}
-	g_list_free (devices);
-
-	widget = cc_wacom_page_new (NULL, stylus, eraser, pad);
-	cc_wacom_page_set_navigation (CC_WACOM_PAGE (widget), GTK_NOTEBOOK (notebook), FALSE);
-	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), widget, NULL);
-	gtk_widget_show (widget);
-}
-
-static gboolean
-delete_event_cb (GtkWidget *widget,
-		 GdkEvent  *event,
-		 gpointer   user_data)
-{
-	gtk_main_quit ();
-
-	return FALSE;
-}
-
-int main (int argc, char **argv)
-{
-	GtkWidget *window, *notebook;
-	GList *devices;
-
-	bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
-	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-	textdomain (GETTEXT_PACKAGE);
-
-	gtk_init (&argc, &argv);
-
-	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-	gtk_window_set_resizable (GTK_WINDOW (window), FALSE);
-	gtk_widget_set_size_request (window, FIXED_WIDTH, -1);
-	g_signal_connect (G_OBJECT (window), "delete-event",
-			  G_CALLBACK (delete_event_cb), NULL);
-	notebook = gtk_notebook_new ();
-	gtk_notebook_set_show_tabs (GTK_NOTEBOOK (notebook), FALSE);
-	gtk_widget_set_vexpand (notebook, TRUE);
-	gtk_container_set_border_width (GTK_CONTAINER (notebook), 24);
-	gtk_container_add (GTK_CONTAINER (window), notebook);
-	gtk_widget_show (notebook);
-
-	devices = gsd_wacom_device_create_fake_intuos4 ();
-	add_page (devices, notebook);
-
-	devices = gsd_wacom_device_create_fake_cintiq ();
-	add_page (devices, notebook);
-
-	devices = gsd_wacom_device_create_fake_bt ();
-	add_page (devices, notebook);
-
-	devices = gsd_wacom_device_create_fake_x201 ();
-	add_page (devices, notebook);
-
-	gtk_widget_show (window);
-
-	gtk_main ();
-
-	return 0;
-}
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/wacom-module.c gnome-control-center-3.3.90/panels/wacom/wacom-module.c
--- gnome-control-center-3.3.90.orig/panels/wacom/wacom-module.c	2012-03-02 12:23:42.443720925 -0500
+++ gnome-control-center-3.3.90/panels/wacom/wacom-module.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,41 +0,0 @@
-/*
- * Copyright © Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Peter Hutterer <peter.hutterer@redhat.com>
- *
- */
-
-#include <config.h>
-
-#include "cc-wacom-panel.h"
-
-#include <glib/gi18n-lib.h>
-
-void
-g_io_module_load (GIOModule *module)
-{
-  bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
-  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-
-  /* register the panel */
-  cc_wacom_panel_register (module);
-}
-
-void
-g_io_module_unload (GIOModule *module)
-{
-}
diff -Nru gnome-control-center-3.3.90.orig/panels/wacom/wacom-stylus-page.ui gnome-control-center-3.3.90/panels/wacom/wacom-stylus-page.ui
--- gnome-control-center-3.3.90.orig/panels/wacom/wacom-stylus-page.ui	2012-03-02 12:23:42.447054258 -0500
+++ gnome-control-center-3.3.90/panels/wacom/wacom-stylus-page.ui	1969-12-31 19:00:00.000000000 -0500
@@ -1,351 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <!-- interface-requires gtk+ 3.0 -->
-  <object class="GtkAdjustment" id="adjustment-eraser-feel">
-    <property name="upper">6</property>
-    <property name="step_increment">1</property>
-    <property name="page_increment">3</property>
-  </object>
-  <object class="GtkAdjustment" id="adjustment-tip-feel">
-    <property name="upper">6</property>
-    <property name="step_increment">1</property>
-    <property name="page_increment">3</property>
-  </object>
-  <object class="GtkListStore" id="liststore-buttons">
-    <columns>
-      <!-- column-name button -->
-      <column type="gint"/>
-      <!-- column-name button-label -->
-      <column type="gchararray"/>
-    </columns>
-    <data>
-      <row>
-        <col id="0">0</col>
-        <col id="1" translatable="yes">No Action</col>
-      </row>
-      <row>
-        <col id="0">1</col>
-        <col id="1" translatable="yes">Left Mouse Button Click</col>
-      </row>
-      <row>
-        <col id="0">2</col>
-        <col id="1" translatable="yes">Middle Mouse Button Click</col>
-      </row>
-      <row>
-        <col id="0">3</col>
-        <col id="1" translatable="yes">Right Mouse Button Click</col>
-      </row>
-      <row>
-        <col id="0">4</col>
-        <col id="1" translatable="yes">Scroll Up</col>
-      </row>
-      <row>
-        <col id="0">5</col>
-        <col id="1" translatable="yes">Scroll Down</col>
-      </row>
-      <row>
-        <col id="0">6</col>
-        <col id="1" translatable="yes">Scroll Left</col>
-      </row>
-      <row>
-        <col id="0">7</col>
-        <col id="1" translatable="yes">Scroll Right</col>
-      </row>
-      <row>
-        <col id="0">7</col>
-        <col id="1" translatable="yes">Back</col>
-      </row>
-      <row>
-        <col id="0">8</col>
-        <col id="1" translatable="yes">Forward</col>
-      </row>
-    </data>
-  </object>
-  <object class="GtkGrid" id="stylus-grid">
-    <property name="visible">True</property>
-    <property name="can_focus">False</property>
-    <property name="column_spacing">10</property>
-    <property name="row_spacing">10</property>
-    <child>
-      <object class="GtkLabel" id="label-stylus">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="halign">start</property>
-        <property name="valign">center</property>
-        <property name="label" translatable="yes">Stylus</property>
-        <attributes>
-          <attribute name="weight" value="bold"/>
-        </attributes>
-      </object>
-      <packing>
-        <property name="left_attach">1</property>
-        <property name="top_attach">0</property>
-        <property name="width">1</property>
-        <property name="height">1</property>
-      </packing>
-    </child>
-    <child>
-      <object class="GtkImage" id="image-stylus">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="halign">end</property>
-        <property name="valign">start</property>
-        <property name="pixbuf">wacom-stylus.svg</property>
-      </object>
-      <packing>
-        <property name="left_attach">0</property>
-        <property name="top_attach">1</property>
-        <property name="width">1</property>
-        <property name="height">1</property>
-      </packing>
-    </child>
-    <child>
-      <object class="GtkGrid" id="stylus-controls-grid">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="orientation">vertical</property>
-        <property name="margin_left">16</property>
-        <property name="margin_top">6</property>
-        <property name="row_spacing">10</property>
-        <property name="column_spacing">10</property>
-        <child>
-          <object class="GtkLabel" id="label-eraser-feel">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">end</property>
-            <property name="valign">center</property>
-            <property name="label" translatable="yes">Eraser Pressure Feel</property>
-            <property name="justify">right</property>
-            <style>
-              <class name="dim-label"/>
-            </style>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">0</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkBox" id="eraser-box">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="spacing">10</property>
-            <child>
-              <object class="GtkLabel" id="label-eraser-soft">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Soft</property>
-                <attributes>
-                  <attribute name="scale" value="0.82999999999999996"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkScale" id="scale-eraser-feel">
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="valign">center</property>
-                <property name="adjustment">adjustment-eraser-feel</property>
-                <property name="digits">0</property>
-                <property name="draw_value">False</property>
-              </object>
-              <packing>
-                <property name="expand">True</property>
-                <property name="fill">True</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkLabel" id="label-eraser-firm">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Firm</property>
-                <attributes>
-                  <attribute name="scale" value="0.82999999999999996"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">2</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="left_attach">1</property>
-            <property name="top_attach">0</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkLabel" id="label-top-button">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">end</property>
-            <property name="valign">center</property>
-            <property name="label" translatable="yes">Top Button</property>
-            <property name="justify">right</property>
-            <style>
-              <class name="dim-label"/>
-            </style>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">1</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkComboBox" id="combo-topbutton">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="valign">center</property>
-            <property name="model">liststore-buttons</property>
-          </object>
-          <packing>
-            <property name="left_attach">1</property>
-            <property name="top_attach">1</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkLabel" id="label-lower-button">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">end</property>
-            <property name="valign">center</property>
-            <property name="label" translatable="yes">Lower Button</property>
-            <property name="justify">right</property>
-            <style>
-              <class name="dim-label"/>
-            </style>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">2</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkComboBox" id="combo-bottombutton">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="valign">center</property>
-            <property name="model">liststore-buttons</property>
-          </object>
-          <packing>
-            <property name="left_attach">1</property>
-            <property name="top_attach">2</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkLabel" id="label-tip-feel">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">end</property>
-            <property name="valign">center</property>
-            <property name="label" translatable="yes">Tip Pressure Feel</property>
-            <property name="justify">right</property>
-            <style>
-              <class name="dim-label"/>
-            </style>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">3</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkBox" id="box-tip-feel">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="spacing">10</property>
-            <child>
-              <object class="GtkLabel" id="label-tip-soft">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Soft</property>
-                <attributes>
-                  <attribute name="scale" value="0.82999999999999996"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkScale" id="scale-tip-feel">
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="adjustment">adjustment-tip-feel</property>
-                <property name="digits">0</property>
-                <property name="draw_value">False</property>
-              </object>
-              <packing>
-                <property name="expand">True</property>
-                <property name="fill">True</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkLabel" id="label-tip-firm">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Firm</property>
-                <attributes>
-                  <attribute name="scale" value="0.82999999999999996"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">2</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="left_attach">1</property>
-            <property name="top_attach">3</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-      </object>
-      <packing>
-        <property name="left_attach">1</property>
-        <property name="top_attach">1</property>
-        <property name="width">1</property>
-        <property name="height">1</property>
-      </packing>
-    </child>
-    <child>
-      <placeholder/>
-    </child>
-    <child>
-      <placeholder/>
-    </child>
-    <child>
-      <placeholder/>
-    </child>
-    <child>
-      <placeholder/>
-    </child>
-  </object>
-</interface>
