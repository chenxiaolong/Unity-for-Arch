diff -Nru gnome-control-center-3.6.0.orig/configure.ac gnome-control-center-3.6.0/configure.ac
--- gnome-control-center-3.6.0.orig/configure.ac	2012-09-28 19:07:33.507746032 -0400
+++ gnome-control-center-3.6.0/configure.ac	2012-09-28 19:08:52.457641730 -0400
@@ -425,6 +425,9 @@
 panels/online-accounts/icons/32x32/Makefile
 panels/online-accounts/icons/48x48/Makefile
 panels/online-accounts/icons/256x256/Makefile
+panels/sound-nua/Makefile
+panels/sound-nua/data/Makefile
+panels/sound-nua/data/gnome-sound-nua-panel.desktop.in
 panels/sound/Makefile
 panels/sound/data/Makefile
 panels/sound/data/gnome-sound-panel.desktop.in
diff -Nru gnome-control-center-3.6.0.orig/panels/Makefile.am gnome-control-center-3.6.0/panels/Makefile.am
--- gnome-control-center-3.6.0.orig/panels/Makefile.am	2012-09-28 19:07:33.117746485 -0400
+++ gnome-control-center-3.6.0/panels/Makefile.am	2012-09-28 19:08:52.459641726 -0400
@@ -10,6 +10,7 @@
 	region \
 	info \
 	sound \
+	sound-nua \
 	keyboard \
 	universal-access \
 	user-accounts \
diff -Nru gnome-control-center-3.6.0.orig/panels/sound/data/gnome-sound-panel.desktop.in.in gnome-control-center-3.6.0/panels/sound/data/gnome-sound-panel.desktop.in.in
--- gnome-control-center-3.6.0.orig/panels/sound/data/gnome-sound-panel.desktop.in.in	2012-09-28 19:07:33.347746216 -0400
+++ gnome-control-center-3.6.0/panels/sound/data/gnome-sound-panel.desktop.in.in	2012-09-28 19:08:52.462641729 -0400
@@ -7,7 +7,7 @@
 Type=Application
 StartupNotify=true
 Categories=GNOME;GTK;Settings;HardwareSettings;X-GNOME-Settings-Panel;
-OnlyShowIn=GNOME;Unity;
+OnlyShowIn=GNOME;
 X-GNOME-Bugzilla-Bugzilla=GNOME
 X-GNOME-Bugzilla-Product=gnome-control-center
 X-GNOME-Bugzilla-Component=sound
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/applet-main.c gnome-control-center-3.6.0/panels/sound-nua/applet-main.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/applet-main.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/applet-main.c	2012-09-28 19:08:52.465641724 -0400
@@ -0,0 +1,110 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include <libintl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <glib/gi18n.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <gio/gio.h>
+
+#include "gvc-applet.h"
+#include "gvc-log.h"
+
+#define GVCA_DBUS_NAME "org.gnome.VolumeControlApplet"
+
+static gboolean show_version = FALSE;
+static gboolean debug = FALSE;
+
+int
+main (int argc, char **argv)
+{
+        GError             *error;
+        GvcApplet          *applet;
+        GApplication       *app = NULL;
+        static GOptionEntry entries[] = {
+                { "debug", 0, 0, G_OPTION_ARG_NONE, &debug, N_("Enable debugging code"), NULL },
+                { "version", 0, 0, G_OPTION_ARG_NONE, &show_version, N_("Version of this application"), NULL },
+                { NULL, 0, 0, 0, NULL, NULL, NULL }
+        };
+
+        bindtextdomain (GETTEXT_PACKAGE, LOCALE_DIR);
+        bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+        textdomain (GETTEXT_PACKAGE);
+
+        gvc_log_init ();
+
+        error = NULL;
+        gtk_init_with_args (&argc, &argv,
+                            (char *) _(" â€” GNOME Volume Control Applet"),
+                            entries, GETTEXT_PACKAGE,
+                            &error);
+
+        if (error != NULL) {
+                g_warning ("%s", error->message);
+                exit (1);
+        }
+
+        if (show_version) {
+                g_print ("%s %s\n", argv [0], VERSION);
+                exit (1);
+        }
+
+        gvc_log_set_debug (debug);
+
+        if (debug == FALSE) {
+                GError *error = NULL;
+
+                app = g_application_new (GVCA_DBUS_NAME,
+                                         G_APPLICATION_FLAGS_NONE);
+                if (!g_application_register (app, NULL, &error)) {
+                       g_warning ("%s", error->message);
+                       g_error_free (error);
+                       return 1;
+                }
+                if (g_application_get_is_remote (app)) {
+                        g_warning ("Applet is already running, exiting");
+                        return 0;
+                }
+        }
+
+        gtk_icon_theme_append_search_path (gtk_icon_theme_get_default (),
+                                           ICON_DATA_DIR);
+
+        applet = gvc_applet_new ();
+        gvc_applet_start (applet);
+
+        gtk_main ();
+
+        if (applet != NULL) {
+                g_object_unref (applet);
+        }
+        if (app != NULL) {
+                g_object_unref (app);
+        }
+
+        return 0;
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/cc-sound-panel.c gnome-control-center-3.6.0/panels/sound-nua/cc-sound-panel.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/cc-sound-panel.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/cc-sound-panel.c	2012-09-28 19:08:52.468641720 -0400
@@ -0,0 +1,141 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include <libintl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <glib/gi18n-lib.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "cc-sound-panel.h"
+#include "gvc-mixer-dialog.h"
+
+G_DEFINE_DYNAMIC_TYPE (CcSoundNuaPanel, cc_sound_panel, CC_TYPE_PANEL)
+
+enum {
+        PROP_0,
+        PROP_ARGV
+};
+
+static void cc_sound_panel_finalize (GObject *object);
+
+static void
+cc_sound_panel_set_property (GObject      *object,
+                             guint         property_id,
+                             const GValue *value,
+                             GParamSpec   *pspec)
+{
+        CcSoundNuaPanel *self = CC_SOUND_PANEL (object);
+
+        switch (property_id) {
+        case PROP_ARGV: {
+                gchar **args;
+
+                args = g_value_get_boxed (value);
+
+                if (args && args[0]) {
+                        gvc_mixer_dialog_set_page (self->dialog, args[0]);
+                }
+                break;
+        }
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+        }
+}
+
+static void
+cc_sound_panel_class_init (CcSoundNuaPanelClass *klass)
+{
+        GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = cc_sound_panel_finalize;
+        object_class->set_property = cc_sound_panel_set_property;
+
+        g_object_class_override_property (object_class, PROP_ARGV, "argv");
+}
+
+static void
+cc_sound_panel_class_finalize (CcSoundNuaPanelClass *klass)
+{
+}
+
+static void
+cc_sound_panel_finalize (GObject *object)
+{
+        CcSoundNuaPanel *panel = CC_SOUND_PANEL (object);
+
+        if (panel->dialog != NULL)
+                panel->dialog = NULL;
+        if (panel->connecting_label != NULL)
+                panel->connecting_label = NULL;
+        if (panel->control != NULL) {
+                g_object_unref (panel->control);
+                panel->control = NULL;
+        }
+
+        G_OBJECT_CLASS (cc_sound_panel_parent_class)->finalize (object);
+}
+
+static void
+cc_sound_panel_init (CcSoundNuaPanel *self)
+{
+        gtk_icon_theme_append_search_path (gtk_icon_theme_get_default (),
+                                           ICON_DATA_DIR);
+        gtk_window_set_default_icon_name ("multimedia-volume-control");
+
+        self->control = gvc_mixer_control_new ("GNOME Volume Control Dialog");
+        gvc_mixer_control_open (self->control);
+        self->dialog = gvc_mixer_dialog_new (self->control);
+        gtk_container_add (GTK_CONTAINER (self), GTK_WIDGET (self->dialog));
+        gtk_widget_show (GTK_WIDGET (self->dialog));
+}
+
+void
+cc_sound_panel_register (GIOModule *module)
+{
+        cc_sound_panel_register_type (G_TYPE_MODULE (module));
+        g_io_extension_point_implement (CC_SHELL_PANEL_EXTENSION_POINT,
+                                        CC_TYPE_SOUND_PANEL,
+                                        "sound-nua", 0);
+}
+
+/* GIO extension stuff */
+void
+g_io_module_load (GIOModule *module)
+{
+        bindtextdomain (GETTEXT_PACKAGE, LOCALE_DIR);
+        bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+
+        /* register the panel */
+        cc_sound_panel_register (module);
+}
+
+void
+g_io_module_unload (GIOModule *module)
+{
+}
+
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/cc-sound-panel.h gnome-control-center-3.6.0/panels/sound-nua/cc-sound-panel.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/cc-sound-panel.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/cc-sound-panel.h	2012-09-28 19:08:52.469641721 -0400
@@ -0,0 +1,60 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef _CC_SOUND_PANEL_H
+#define _CC_SOUND_PANEL_H
+
+#include <shell/cc-panel.h>
+#include "gvc-mixer-control.h"
+#include "gvc-mixer-dialog.h"
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_SOUND_PANEL cc_sound_panel_get_type()
+#define CC_SOUND_PANEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CC_TYPE_SOUND_PANEL, CcSoundNuaPanel))
+#define CC_SOUND_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CC_TYPE_SOUND_PANEL, CcSoundNuaPanelClass))
+#define CC_IS_SOUND_PANEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CC_TYPE_SOUND_PANEL))
+#define CC_IS_SOUND_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CC_TYPE_SOUND_PANEL))
+#define CC_SOUND_PANEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CC_TYPE_SOUND_PANEL, CcSoundNuaPanelClass))
+
+typedef struct _CcSoundNuaPanel CcSoundNuaPanel;
+typedef struct _CcSoundNuaPanelClass CcSoundNuaPanelClass;
+typedef struct _CcSoundNuaPanelPrivate CcSoundNuaPanelPrivate;
+
+struct _CcSoundNuaPanel {
+	CcPanel parent;
+
+	GvcMixerControl *control;
+	GvcMixerDialog  *dialog;
+	GtkWidget       *connecting_label;
+};
+
+struct _CcSoundNuaPanelClass {
+	CcPanelClass parent_class;
+};
+
+GType cc_sound_panel_get_type (void) G_GNUC_CONST;
+
+void  cc_sound_panel_register (GIOModule *module);
+
+G_END_DECLS
+
+#endif /* _CC_SOUND_PANEL_H */
+
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/data/gnome-sound-nua-panel.desktop.in.in gnome-control-center-3.6.0/panels/sound-nua/data/gnome-sound-nua-panel.desktop.in.in
--- gnome-control-center-3.6.0.orig/panels/sound-nua/data/gnome-sound-nua-panel.desktop.in.in	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/data/gnome-sound-nua-panel.desktop.in.in	2012-09-28 19:08:52.470641721 -0400
@@ -0,0 +1,17 @@
+[Desktop Entry]
+_Name=Sound
+_Comment=Change sound volume and sound events
+Exec=gnome-control-center sound-nua
+Icon=multimedia-volume-control
+Terminal=false
+Type=Application
+StartupNotify=true
+Categories=GNOME;GTK;Settings;HardwareSettings;X-GNOME-Settings-Panel;
+OnlyShowIn=Unity;
+X-GNOME-Bugzilla-Bugzilla=GNOME
+X-GNOME-Bugzilla-Product=gnome-control-center
+X-GNOME-Bugzilla-Component=sound
+X-GNOME-Bugzilla-Version=@VERSION@
+X-GNOME-Settings-Panel=sound-nua
+# Translators: those are keywords for the sound control-center panel
+_Keywords=Card;Microphone;Volume;Fade;Balance;Bluetooth;Headset;
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/data/Makefile.am gnome-control-center-3.6.0/panels/sound-nua/data/Makefile.am
--- gnome-control-center-3.6.0.orig/panels/sound-nua/data/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/data/Makefile.am	2012-09-28 19:08:52.470641721 -0400
@@ -0,0 +1,17 @@
+NULL =
+
+@INTLTOOL_DESKTOP_RULE@
+
+appsdir = $(datadir)/applications
+apps_in_files = gnome-sound-nua-panel.desktop.in
+apps_DATA = $(apps_in_files:.desktop.in=.desktop)
+
+EXTRA_DIST =					\
+	gnome-sound-nua-panel.desktop.in.in		\
+	$(NULL)
+
+CLEANFILES =					\
+	gnome-sound-nua-panel.desktop		\
+	$(NULL)
+
+-include $(top_srcdir)/git.mk
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-applet.c gnome-control-center-3.6.0/panels/sound-nua/gvc-applet.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-applet.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-applet.c	2012-09-28 19:08:52.471641720 -0400
@@ -0,0 +1,305 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <gtk/gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-applet.h"
+#include "gvc-mixer-control.h"
+#include "gvc-stream-status-icon.h"
+
+#define GVC_APPLET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_APPLET, GvcAppletPrivate))
+
+#define SCALE_SIZE 128
+
+static const char *output_icon_names[] = {
+        "audio-volume-muted-symbolic",
+        "audio-volume-low-symbolic",
+        "audio-volume-medium-symbolic",
+        "audio-volume-high-symbolic",
+        NULL
+};
+
+static const char *input_icon_names[] = {
+        "audio-input-microphone-muted-symbolic",
+        "audio-input-microphone-low-symbolic",
+        "audio-input-microphone-medium-symbolic",
+        "audio-input-microphone-high-symbolic",
+        NULL
+};
+
+struct GvcAppletPrivate
+{
+        GvcStreamStatusIcon *input_status_icon;
+        GvcStreamStatusIcon *output_status_icon;
+        GvcMixerControl     *control;
+};
+
+static void     gvc_applet_class_init (GvcAppletClass *klass);
+static void     gvc_applet_init       (GvcApplet      *applet);
+static void     gvc_applet_finalize   (GObject        *object);
+
+G_DEFINE_TYPE (GvcApplet, gvc_applet, G_TYPE_OBJECT)
+
+static void
+maybe_show_status_icons (GvcApplet *applet)
+{
+        gboolean        show;
+        GvcMixerStream *stream;
+        GSList         *source_outputs, *l;
+
+        show = TRUE;
+        stream = gvc_mixer_control_get_default_sink (applet->priv->control);
+        if (stream == NULL) {
+                show = FALSE;
+        }
+        gtk_status_icon_set_visible (GTK_STATUS_ICON (applet->priv->output_status_icon), show);
+
+
+        show = FALSE;
+        stream = gvc_mixer_control_get_default_source (applet->priv->control);
+        source_outputs = gvc_mixer_control_get_source_outputs (applet->priv->control);
+        if (stream != NULL && source_outputs != NULL) {
+                /* Check that we're not trying to add the peak detector
+                 * as an application doing recording */
+                for (l = source_outputs ; l ; l = l->next) {
+                        GvcMixerStream *s = l->data;
+                        const char *id;
+
+                        id = gvc_mixer_stream_get_application_id (s);
+                        if (id == NULL) {
+                                show = TRUE;
+                                break;
+                        }
+
+                        if (!g_str_equal (id, "org.gnome.VolumeControl") &&
+                            !g_str_equal (id, "org.PulseAudio.pavucontrol")) {
+                                show = TRUE;
+                                break;
+                        }
+                }
+        }
+        gtk_status_icon_set_visible (GTK_STATUS_ICON (applet->priv->input_status_icon), show);
+
+        g_slist_free (source_outputs);
+}
+
+void
+gvc_applet_start (GvcApplet *applet)
+{
+        g_return_if_fail (GVC_IS_APPLET (applet));
+
+        maybe_show_status_icons (applet);
+}
+
+static void
+gvc_applet_dispose (GObject *object)
+{
+        GvcApplet *applet = GVC_APPLET (object);
+
+        if (applet->priv->control != NULL) {
+                g_object_unref (applet->priv->control);
+                applet->priv->control = NULL;
+        }
+
+        G_OBJECT_CLASS (gvc_applet_parent_class)->dispose (object);
+}
+
+static void
+update_default_source (GvcApplet *applet)
+{
+        GvcMixerStream *stream;
+
+        stream = gvc_mixer_control_get_default_source (applet->priv->control);
+        if (stream != NULL) {
+                gvc_stream_status_icon_set_mixer_stream (applet->priv->input_status_icon,
+                                                         stream);
+                maybe_show_status_icons(applet);
+        } else {
+                g_debug ("Unable to get default source, or no source available");
+        }
+}
+
+static void
+update_default_sink (GvcApplet *applet)
+{
+        GvcMixerStream *stream;
+
+        stream = gvc_mixer_control_get_default_sink (applet->priv->control);
+        if (stream != NULL) {
+                gvc_stream_status_icon_set_mixer_stream (applet->priv->output_status_icon,
+                                                         stream);
+                maybe_show_status_icons(applet);
+        } else {
+                g_warning ("Unable to get default sink");
+        }
+}
+
+static void
+on_control_state_changed (GvcMixerControl      *control,
+                          GvcMixerControlState  new_state,
+                          GvcApplet            *applet)
+{
+        if (new_state == GVC_STATE_READY)  {
+                update_default_sink (applet);
+                update_default_source (applet);
+        } else if (new_state == GVC_STATE_CONNECTING) {
+                g_debug ("Connecting...");
+        }
+}
+
+static void
+on_control_default_sink_changed (GvcMixerControl *control,
+                                 guint            id,
+                                 GvcApplet       *applet)
+{
+        update_default_sink (applet);
+}
+
+static void
+on_control_default_source_changed (GvcMixerControl *control,
+                                   guint            id,
+                                   GvcApplet       *applet)
+{
+        update_default_source (applet);
+}
+
+static void
+on_control_stream_removed (GvcMixerControl *control,
+                           guint            id,
+                           GvcApplet       *applet)
+{
+        maybe_show_status_icons (applet);
+}
+
+static void
+on_control_stream_added (GvcMixerControl *control,
+                         guint            id,
+                         GvcApplet       *applet)
+{
+        maybe_show_status_icons (applet);
+}
+
+static GObject *
+gvc_applet_constructor (GType                  type,
+                        guint                  n_construct_properties,
+                        GObjectConstructParam *construct_params)
+{
+        GObject   *object;
+        GvcApplet *self;
+
+        object = G_OBJECT_CLASS (gvc_applet_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_APPLET (object);
+
+        self->priv->control = gvc_mixer_control_new ("GNOME Volume Control Applet");
+        g_signal_connect (self->priv->control,
+                          "state-changed",
+                          G_CALLBACK (on_control_state_changed),
+                          self);
+        g_signal_connect (self->priv->control,
+                          "default-sink-changed",
+                          G_CALLBACK (on_control_default_sink_changed),
+                          self);
+        g_signal_connect (self->priv->control,
+                          "default-source-changed",
+                          G_CALLBACK (on_control_default_source_changed),
+                          self);
+        g_signal_connect (self->priv->control,
+                          "stream-added",
+                          G_CALLBACK (on_control_stream_added),
+                          self);
+        g_signal_connect (self->priv->control,
+                          "stream-removed",
+                          G_CALLBACK (on_control_stream_removed),
+                          self);
+
+        gvc_mixer_control_open (self->priv->control);
+
+        return object;
+}
+
+static void
+gvc_applet_class_init (GvcAppletClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = gvc_applet_finalize;
+        object_class->dispose = gvc_applet_dispose;
+        object_class->constructor = gvc_applet_constructor;
+
+        g_type_class_add_private (klass, sizeof (GvcAppletPrivate));
+}
+
+static void
+gvc_applet_init (GvcApplet *applet)
+{
+        applet->priv = GVC_APPLET_GET_PRIVATE (applet);
+
+        applet->priv->output_status_icon = gvc_stream_status_icon_new (NULL,
+                                                                       output_icon_names);
+        gvc_stream_status_icon_set_display_name (applet->priv->output_status_icon,
+                                                 _("Output"));
+        gtk_status_icon_set_title (GTK_STATUS_ICON (applet->priv->output_status_icon),
+                                   _("Sound Output Volume"));
+        applet->priv->input_status_icon = gvc_stream_status_icon_new (NULL,
+                                                                      input_icon_names);
+        gvc_stream_status_icon_set_display_name (applet->priv->input_status_icon,
+                                                 _("Input"));
+        gtk_status_icon_set_title (GTK_STATUS_ICON (applet->priv->input_status_icon),
+                                   _("Microphone Volume"));
+}
+
+static void
+gvc_applet_finalize (GObject *object)
+{
+        GvcApplet *applet;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_APPLET (object));
+
+        applet = GVC_APPLET (object);
+
+        g_return_if_fail (applet->priv != NULL);
+
+
+        G_OBJECT_CLASS (gvc_applet_parent_class)->finalize (object);
+}
+
+GvcApplet *
+gvc_applet_new (void)
+{
+        GObject *applet;
+
+        applet = g_object_new (GVC_TYPE_APPLET, NULL);
+
+        return GVC_APPLET (applet);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-applet.h gnome-control-center-3.6.0/panels/sound-nua/gvc-applet.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-applet.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-applet.h	2012-09-28 19:08:52.472641718 -0400
@@ -0,0 +1,55 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_APPLET_H
+#define __GVC_APPLET_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_APPLET         (gvc_applet_get_type ())
+#define GVC_APPLET(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_APPLET, GvcApplet))
+#define GVC_APPLET_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_APPLET, GvcAppletClass))
+#define GVC_IS_APPLET(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_APPLET))
+#define GVC_IS_APPLET_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_APPLET))
+#define GVC_APPLET_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_APPLET, GvcAppletClass))
+
+typedef struct GvcAppletPrivate GvcAppletPrivate;
+
+typedef struct
+{
+        GObject            parent;
+        GvcAppletPrivate *priv;
+} GvcApplet;
+
+typedef struct
+{
+        GObjectClass   parent_class;
+} GvcAppletClass;
+
+GType               gvc_applet_get_type            (void);
+
+GvcApplet *         gvc_applet_new                 (void);
+void                gvc_applet_start               (GvcApplet     *applet);
+
+G_END_DECLS
+
+#endif /* __GVC_APPLET_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-balance-bar.c gnome-control-center-3.6.0/panels/sound-nua/gvc-balance-bar.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-balance-bar.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-balance-bar.c	2012-09-28 19:08:52.473641715 -0400
@@ -0,0 +1,575 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra-gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-balance-bar.h"
+#include "gvc-channel-map-private.h"
+
+#define SCALE_SIZE 220
+#define ADJUSTMENT_MAX_NORMAL 65536.0 /* PA_VOLUME_NORM */
+
+#define GVC_BALANCE_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_BALANCE_BAR, GvcBalanceBarPrivate))
+
+struct GvcBalanceBarPrivate
+{
+        GvcChannelMap *channel_map;
+        GvcBalanceType btype;
+        GtkWidget     *scale_box;
+        GtkWidget     *start_box;
+        GtkWidget     *end_box;
+        GtkWidget     *label;
+        GtkWidget     *scale;
+        GtkAdjustment *adjustment;
+        GtkSizeGroup  *size_group;
+        gboolean       symmetric;
+        gboolean       click_lock;
+};
+
+enum
+{
+        PROP_0,
+        PROP_CHANNEL_MAP,
+        PROP_BALANCE_TYPE,
+};
+
+static void     gvc_balance_bar_class_init (GvcBalanceBarClass *klass);
+static void     gvc_balance_bar_init       (GvcBalanceBar      *balance_bar);
+static void     gvc_balance_bar_finalize   (GObject            *object);
+
+static gboolean on_scale_button_press_event   (GtkWidget      *widget,
+                                               GdkEventButton *event,
+                                               GvcBalanceBar  *bar);
+static gboolean on_scale_button_release_event (GtkWidget      *widget,
+                                               GdkEventButton *event,
+                                               GvcBalanceBar  *bar);
+static gboolean on_scale_scroll_event         (GtkWidget      *widget,
+                                               GdkEventScroll *event,
+                                               GvcBalanceBar  *bar);
+static void on_adjustment_value_changed       (GtkAdjustment *adjustment,
+                                               GvcBalanceBar *bar);
+
+G_DEFINE_TYPE (GvcBalanceBar, gvc_balance_bar, GTK_TYPE_HBOX)
+
+static GtkWidget *
+_scale_box_new (GvcBalanceBar *bar)
+{
+        GvcBalanceBarPrivate *priv = bar->priv;
+        GtkWidget            *box;
+        GtkWidget            *sbox;
+        GtkWidget            *ebox;
+        GtkAdjustment        *adjustment = bar->priv->adjustment;
+        char                 *str_lower, *str_upper;
+        gdouble              lower, upper;
+
+        bar->priv->scale_box = box = gtk_box_new (FALSE, 6);
+        priv->scale = gtk_hscale_new (priv->adjustment);
+        gtk_widget_set_size_request (priv->scale, SCALE_SIZE, -1);
+        gtk_scale_set_has_origin (GTK_SCALE (priv->scale), FALSE);
+        gtk_widget_set_name (priv->scale, "balance-bar-scale");
+        gtk_rc_parse_string ("style \"balance-bar-scale-style\" {\n"
+                             " GtkScale::trough-side-details = 0\n"
+                             "}\n"
+                             "widget \"*.balance-bar-scale\" style : rc \"balance-bar-scale-style\"\n");
+
+        bar->priv->start_box = sbox = gtk_box_new (FALSE, 6);
+        gtk_box_pack_start (GTK_BOX (box), sbox, FALSE, FALSE, 0);
+
+        gtk_box_pack_start (GTK_BOX (sbox), priv->label, FALSE, FALSE, 0);
+
+        gtk_box_pack_start (GTK_BOX (box), priv->scale, TRUE, TRUE, 0);
+
+        switch (bar->priv->btype) {
+        case BALANCE_TYPE_RL:
+                str_lower = g_strdup_printf ("<small>%s</small>", C_("balance", "Left"));
+                str_upper = g_strdup_printf ("<small>%s</small>", C_("balance", "Right"));
+                break;
+        case BALANCE_TYPE_FR:
+                str_lower = g_strdup_printf ("<small>%s</small>", C_("balance", "Rear"));
+                str_upper = g_strdup_printf ("<small>%s</small>", C_("balance", "Front"));
+                break;
+        case BALANCE_TYPE_LFE:
+                str_lower = g_strdup_printf ("<small>%s</small>", C_("balance", "Minimum"));
+                str_upper = g_strdup_printf ("<small>%s</small>", C_("balance", "Maximum"));
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        lower = gtk_adjustment_get_lower (adjustment);
+        gtk_scale_add_mark (GTK_SCALE (priv->scale), lower,
+                            GTK_POS_BOTTOM, str_lower);
+        g_free (str_lower);
+        upper = gtk_adjustment_get_upper (adjustment);
+        gtk_scale_add_mark (GTK_SCALE (priv->scale), upper,
+                            GTK_POS_BOTTOM, str_upper);
+        g_free (str_upper);
+
+        if (bar->priv->btype != BALANCE_TYPE_LFE) {
+                gtk_scale_add_mark (GTK_SCALE (priv->scale),
+                                    (upper - lower)/2 + lower,
+                                    GTK_POS_BOTTOM, NULL);
+        }
+
+        bar->priv->end_box = ebox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+        gtk_box_pack_start (GTK_BOX (box), ebox, FALSE, FALSE, 0);
+
+        ca_gtk_widget_disable_sounds (bar->priv->scale, FALSE);
+        gtk_widget_add_events (bar->priv->scale, GDK_SCROLL_MASK);
+
+        g_signal_connect (G_OBJECT (bar->priv->scale), "button-press-event",
+                          G_CALLBACK (on_scale_button_press_event), bar);
+        g_signal_connect (G_OBJECT (bar->priv->scale), "button-release-event",
+                          G_CALLBACK (on_scale_button_release_event), bar);
+        g_signal_connect (G_OBJECT (bar->priv->scale), "scroll-event",
+                          G_CALLBACK (on_scale_scroll_event), bar);
+
+        if (bar->priv->size_group != NULL) {
+                gtk_size_group_add_widget (bar->priv->size_group, sbox);
+
+                if (bar->priv->symmetric) {
+                        gtk_size_group_add_widget (bar->priv->size_group, ebox);
+                }
+        }
+
+        gtk_scale_set_draw_value (GTK_SCALE (priv->scale), FALSE);
+
+        return box;
+}
+
+void
+gvc_balance_bar_set_size_group (GvcBalanceBar *bar,
+                                GtkSizeGroup  *group,
+                                gboolean       symmetric)
+{
+        g_return_if_fail (GVC_IS_BALANCE_BAR (bar));
+
+        bar->priv->size_group = group;
+        bar->priv->symmetric = symmetric;
+
+        if (bar->priv->size_group != NULL) {
+                gtk_size_group_add_widget (bar->priv->size_group,
+                                           bar->priv->start_box);
+
+                if (bar->priv->symmetric) {
+                        gtk_size_group_add_widget (bar->priv->size_group,
+                                                   bar->priv->end_box);
+                }
+        }
+        gtk_widget_queue_draw (GTK_WIDGET (bar));
+}
+
+static const char *
+btype_to_string (guint btype)
+{
+        switch (btype) {
+        case BALANCE_TYPE_RL:
+                return "Balance";
+        case BALANCE_TYPE_FR:
+                return "Fade";
+                break;
+        case BALANCE_TYPE_LFE:
+                return "LFE";
+        default:
+                g_assert_not_reached ();
+        }
+        return NULL;
+}
+
+static void
+update_level_from_map (GvcBalanceBar *bar,
+                       GvcChannelMap *map)
+{
+        const gdouble *volumes;
+        gdouble val;
+
+        g_debug ("Volume changed (for %s bar)", btype_to_string (bar->priv->btype));
+
+        volumes = gvc_channel_map_get_volume (map);
+        switch (bar->priv->btype) {
+        case BALANCE_TYPE_RL:
+                val = volumes[BALANCE];
+                break;
+        case BALANCE_TYPE_FR:
+                val = volumes[FADE];
+                break;
+        case BALANCE_TYPE_LFE:
+                val = volumes[LFE];
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        gtk_adjustment_set_value (bar->priv->adjustment, val);
+}
+
+static void
+on_channel_map_volume_changed (GvcChannelMap  *map,
+                               gboolean        set,
+                               GvcBalanceBar  *bar)
+{
+        update_level_from_map (bar, map);
+}
+
+static void
+gvc_balance_bar_set_channel_map (GvcBalanceBar *bar,
+                                 GvcChannelMap *map)
+{
+        g_return_if_fail (GVC_BALANCE_BAR (bar));
+
+        if (bar->priv->channel_map != NULL) {
+                g_signal_handlers_disconnect_by_func (G_OBJECT (bar->priv->channel_map),
+                                                      on_channel_map_volume_changed, bar);
+                g_object_unref (bar->priv->channel_map);
+        }
+        bar->priv->channel_map = g_object_ref (map);
+
+        update_level_from_map (bar, map);
+
+        g_signal_connect (G_OBJECT (map), "volume-changed",
+                          G_CALLBACK (on_channel_map_volume_changed), bar);
+
+        g_object_notify (G_OBJECT (bar), "channel-map");
+}
+
+static void
+gvc_balance_bar_set_balance_type (GvcBalanceBar *bar,
+                                  GvcBalanceType btype)
+{
+        GtkWidget *frame;
+
+        g_return_if_fail (GVC_BALANCE_BAR (bar));
+
+        bar->priv->btype = btype;
+        if (bar->priv->btype != BALANCE_TYPE_LFE) {
+                bar->priv->adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                            -1.0,
+                                                                            1.0,
+                                                                            0.5,
+                                                                            0.5,
+                                                                            0.0));
+        } else {
+                bar->priv->adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                            0.0,
+                                                                            ADJUSTMENT_MAX_NORMAL,
+                                                                            ADJUSTMENT_MAX_NORMAL/100.0,
+                                                                            ADJUSTMENT_MAX_NORMAL/10.0,
+                                                                            0.0));
+        }
+
+        g_object_ref_sink (bar->priv->adjustment);
+        g_signal_connect (bar->priv->adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_adjustment_value_changed),
+                          bar);
+
+        switch (btype) {
+        case BALANCE_TYPE_RL:
+                bar->priv->label = gtk_label_new_with_mnemonic (_("_Balance:"));
+                break;
+        case BALANCE_TYPE_FR:
+                bar->priv->label = gtk_label_new_with_mnemonic (_("_Fade:"));
+                break;
+        case BALANCE_TYPE_LFE:
+                bar->priv->label = gtk_label_new_with_mnemonic (_("_Subwoofer:"));
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+        gtk_misc_set_alignment (GTK_MISC (bar->priv->label),
+                                0.0,
+                                0.0);
+        /* frame */
+        frame = gtk_frame_new (NULL);
+        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
+        gtk_container_add (GTK_CONTAINER (bar), frame);
+
+        /* box with scale */
+        bar->priv->scale_box = _scale_box_new (bar);
+        gtk_container_add (GTK_CONTAINER (frame), bar->priv->scale_box);
+        gtk_widget_show_all (frame);
+
+        gtk_widget_set_direction (bar->priv->scale, GTK_TEXT_DIR_LTR);
+        gtk_label_set_mnemonic_widget (GTK_LABEL (bar->priv->label),
+                                       bar->priv->scale);
+
+        g_object_notify (G_OBJECT (bar), "balance-type");
+}
+
+static void
+gvc_balance_bar_set_property (GObject       *object,
+                              guint          prop_id,
+                              const GValue  *value,
+                              GParamSpec    *pspec)
+{
+        GvcBalanceBar *self = GVC_BALANCE_BAR (object);
+
+        switch (prop_id) {
+        case PROP_CHANNEL_MAP:
+                gvc_balance_bar_set_channel_map (self, g_value_get_object (value));
+                break;
+        case PROP_BALANCE_TYPE:
+                gvc_balance_bar_set_balance_type (self, g_value_get_int (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_balance_bar_get_property (GObject     *object,
+                              guint        prop_id,
+                              GValue      *value,
+                              GParamSpec  *pspec)
+{
+        GvcBalanceBar *self = GVC_BALANCE_BAR (object);
+
+        switch (prop_id) {
+        case PROP_CHANNEL_MAP:
+                g_value_set_object (value, self->priv->channel_map);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_balance_bar_constructor (GType                  type,
+                             guint                  n_construct_properties,
+                             GObjectConstructParam *construct_params)
+{
+        return G_OBJECT_CLASS (gvc_balance_bar_parent_class)->constructor (type, n_construct_properties, construct_params);
+}
+
+static void
+gvc_balance_bar_class_init (GvcBalanceBarClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_balance_bar_constructor;
+        object_class->finalize = gvc_balance_bar_finalize;
+        object_class->set_property = gvc_balance_bar_set_property;
+        object_class->get_property = gvc_balance_bar_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_CHANNEL_MAP,
+                                         g_param_spec_object ("channel-map",
+                                                              "channel map",
+                                                              "The channel map",
+                                                              GVC_TYPE_CHANNEL_MAP,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_BALANCE_TYPE,
+                                         g_param_spec_int ("balance-type",
+                                                           "balance type",
+                                                           "Whether the balance is right-left or front-rear",
+                                                           BALANCE_TYPE_RL, NUM_BALANCE_TYPES - 1, BALANCE_TYPE_RL,
+                                                           G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+
+        g_type_class_add_private (klass, sizeof (GvcBalanceBarPrivate));
+}
+
+
+static gboolean
+on_scale_button_press_event (GtkWidget      *widget,
+                             GdkEventButton *event,
+                             GvcBalanceBar  *bar)
+{
+        bar->priv->click_lock = TRUE;
+
+        return FALSE;
+}
+
+static gboolean
+on_scale_button_release_event (GtkWidget      *widget,
+                               GdkEventButton *event,
+                               GvcBalanceBar  *bar)
+{
+        bar->priv->click_lock = FALSE;
+
+        return FALSE;
+}
+
+static gboolean
+on_scale_scroll_event (GtkWidget      *widget,
+                       GdkEventScroll *event,
+                       GvcBalanceBar  *bar)
+{
+        gdouble value;
+        gdouble dx, dy;
+
+        value = gtk_adjustment_get_value (bar->priv->adjustment);
+
+        if (!gdk_event_get_scroll_deltas ((GdkEvent*)event, &dx, &dy)) {
+                dx = 0.0;
+                dy = 0.0;
+
+                switch (event->direction) {
+                case GDK_SCROLL_UP:
+                case GDK_SCROLL_RIGHT:
+                        dy = 1.0;
+                        break;
+                case GDK_SCROLL_DOWN:
+                case GDK_SCROLL_LEFT:
+                        dy = -1.0;
+                        break;
+                default:
+                        ;
+                }
+        }
+
+        if (bar->priv->btype == BALANCE_TYPE_LFE) {
+                if (dy > 0) {
+                        if (value + dy * ADJUSTMENT_MAX_NORMAL/100.0 > ADJUSTMENT_MAX_NORMAL)
+                                value = ADJUSTMENT_MAX_NORMAL;
+                        else
+                                value = value + dy * ADJUSTMENT_MAX_NORMAL/100.0;
+                } else if (dy < 0) {
+                        if (value + dy * ADJUSTMENT_MAX_NORMAL/100.0 < 0)
+                                value = 0.0;
+                        else
+                                value = value + dy * ADJUSTMENT_MAX_NORMAL/100.0;
+                }
+        } else {
+                if (dy > 0) {
+                        if (value + dy * 0.01 > 1.0)
+                                value = 1.0;
+                        else
+                                value = value + dy * 0.01;
+                } else if (dy < 0) {
+                        if (value + dy * 0.01 < -1.0)
+                                value = -1.0;
+                        else
+                                value = value + dy * 0.01;
+                }
+        }
+        gtk_adjustment_set_value (bar->priv->adjustment, value);
+
+        return TRUE;
+}
+
+/* FIXME remove when we depend on a newer PA */
+static pa_cvolume *
+gvc_pa_cvolume_set_position (pa_cvolume *cv, const pa_channel_map *map, pa_channel_position_t t, pa_volume_t v) {
+        unsigned c;
+        gboolean good = FALSE;
+
+        g_assert(cv);
+        g_assert(map);
+
+        g_return_val_if_fail(pa_cvolume_compatible_with_channel_map(cv, map), NULL);
+        g_return_val_if_fail(t < PA_CHANNEL_POSITION_MAX, NULL);
+
+        for (c = 0; c < map->channels; c++)
+                if (map->map[c] == t) {
+                        cv->values[c] = v;
+                        good = TRUE;
+                }
+
+        return good ? cv : NULL;
+}
+
+static void
+on_adjustment_value_changed (GtkAdjustment *adjustment,
+                             GvcBalanceBar *bar)
+{
+        gdouble                val;
+        pa_cvolume             cv;
+        const pa_channel_map  *pa_map;
+
+        if (bar->priv->channel_map == NULL)
+                return;
+
+        cv = *gvc_channel_map_get_cvolume (bar->priv->channel_map);
+        val = gtk_adjustment_get_value (adjustment);
+
+        pa_map = gvc_channel_map_get_pa_channel_map (bar->priv->channel_map);
+
+        switch (bar->priv->btype) {
+        case BALANCE_TYPE_RL:
+                pa_cvolume_set_balance (&cv, pa_map, val);
+                break;
+        case BALANCE_TYPE_FR:
+                pa_cvolume_set_fade (&cv, pa_map, val);
+                break;
+        case BALANCE_TYPE_LFE:
+                gvc_pa_cvolume_set_position (&cv, pa_map, PA_CHANNEL_POSITION_LFE, val);
+                break;
+        }
+
+        gvc_channel_map_volume_changed (bar->priv->channel_map, &cv, TRUE);
+}
+
+static void
+gvc_balance_bar_init (GvcBalanceBar *bar)
+{
+        bar->priv = GVC_BALANCE_BAR_GET_PRIVATE (bar);
+}
+
+static void
+gvc_balance_bar_finalize (GObject *object)
+{
+        GvcBalanceBar *bar;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_BALANCE_BAR (object));
+
+        bar = GVC_BALANCE_BAR (object);
+
+        g_return_if_fail (bar->priv != NULL);
+
+        if (bar->priv->channel_map != NULL) {
+                g_signal_handlers_disconnect_by_func (G_OBJECT (bar->priv->channel_map),
+                                                      on_channel_map_volume_changed, bar);
+                g_object_unref (bar->priv->channel_map);
+        }
+
+        G_OBJECT_CLASS (gvc_balance_bar_parent_class)->finalize (object);
+}
+
+void
+gvc_balance_bar_set_map (GvcBalanceBar* self,
+                         const GvcChannelMap *channel_map)
+{
+        g_object_set (G_OBJECT (self),
+                      "channel-map", channel_map, NULL);
+}                                   
+
+GtkWidget *
+gvc_balance_bar_new (GvcBalanceType btype)
+{
+        GObject *bar;
+        bar = g_object_new (GVC_TYPE_BALANCE_BAR,
+                            "balance-type", btype, NULL);
+
+        return GTK_WIDGET (bar);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-balance-bar.h gnome-control-center-3.6.0/panels/sound-nua/gvc-balance-bar.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-balance-bar.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-balance-bar.h	2012-09-28 19:08:52.473641715 -0400
@@ -0,0 +1,70 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_BALANCE_BAR_H
+#define __GVC_BALANCE_BAR_H
+
+#include <glib-object.h>
+
+#include "gvc-channel-map.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_BALANCE_BAR         (gvc_balance_bar_get_type ())
+#define GVC_BALANCE_BAR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_BALANCE_BAR, GvcBalanceBar))
+#define GVC_BALANCE_BAR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_BALANCE_BAR, GvcBalanceBarClass))
+#define GVC_IS_BALANCE_BAR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_BALANCE_BAR))
+#define GVC_IS_BALANCE_BAR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_BALANCE_BAR))
+#define GVC_BALANCE_BAR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_BALANCE_BAR, GvcBalanceBarClass))
+
+typedef enum {
+        BALANCE_TYPE_RL,
+        BALANCE_TYPE_FR,
+        BALANCE_TYPE_LFE,
+} GvcBalanceType;
+
+#define NUM_BALANCE_TYPES BALANCE_TYPE_LFE + 1
+
+typedef struct GvcBalanceBarPrivate GvcBalanceBarPrivate;
+
+typedef struct
+{
+        GtkHBox               parent;
+        GvcBalanceBarPrivate *priv;
+} GvcBalanceBar;
+
+typedef struct
+{
+        GtkHBoxClass          parent_class;
+} GvcBalanceBarClass;
+
+GType               gvc_balance_bar_get_type            (void);
+GtkWidget *         gvc_balance_bar_new                 (GvcBalanceType btype);
+
+void                gvc_balance_bar_set_size_group      (GvcBalanceBar *bar,
+                                                         GtkSizeGroup  *group,
+                                                         gboolean       symmetric);
+
+void                gvc_balance_bar_set_map (GvcBalanceBar *self,
+                                             const GvcChannelMap *channel_map);
+
+G_END_DECLS
+
+#endif /* __GVC_BALANCE_BAR_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-bar.c gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-bar.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-bar.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-bar.c	2012-09-28 19:08:52.474641713 -0400
@@ -0,0 +1,973 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <pulse/pulseaudio.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra-gtk.h>
+
+#include "gvc-channel-bar.h"
+#include "gvc-mixer-control.h"
+
+#define SCALE_SIZE 128
+#define ADJUSTMENT_MAX_NORMAL gvc_mixer_control_get_vol_max_norm(NULL)
+#define ADJUSTMENT_MAX_AMPLIFIED gvc_mixer_control_get_vol_max_amplified(NULL)
+#define ADJUSTMENT_MAX (bar->priv->is_amplified ? ADJUSTMENT_MAX_AMPLIFIED : ADJUSTMENT_MAX_NORMAL)
+#define SCROLLSTEP (ADJUSTMENT_MAX / 100.0 * 5.0)
+
+#define GVC_CHANNEL_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_CHANNEL_BAR, GvcChannelBarPrivate))
+
+struct GvcChannelBarPrivate
+{
+        GtkOrientation orientation;
+        GtkWidget     *scale_box;
+        GtkWidget     *start_box;
+        GtkWidget     *end_box;
+        GtkWidget     *image;
+        GtkWidget     *label;
+        GtkWidget     *low_image;
+        GtkWidget     *scale;
+        GtkWidget     *high_image;
+        GtkWidget     *mute_box;
+        GtkWidget     *mute_button;
+        GtkAdjustment *adjustment;
+        GtkAdjustment *zero_adjustment;
+        gboolean       show_mute;
+        gboolean       is_muted;
+        char          *name;
+        char          *icon_name;
+        char          *low_icon_name;
+        char          *high_icon_name;
+        GtkSizeGroup  *size_group;
+        gboolean       symmetric;
+        gboolean       click_lock;
+        gboolean       is_amplified;
+        guint32        base_volume;
+};
+
+enum
+{
+        PROP_0,
+        PROP_ORIENTATION,
+        PROP_SHOW_MUTE,
+        PROP_IS_MUTED,
+        PROP_ADJUSTMENT,
+        PROP_NAME,
+        PROP_ICON_NAME,
+        PROP_LOW_ICON_NAME,
+        PROP_HIGH_ICON_NAME,
+        PROP_IS_AMPLIFIED,
+        PROP_ELLIPSIZE
+};
+
+static void     gvc_channel_bar_class_init    (GvcChannelBarClass *klass);
+static void     gvc_channel_bar_init          (GvcChannelBar      *channel_bar);
+static void     gvc_channel_bar_finalize      (GObject            *object);
+
+static gboolean on_scale_button_press_event   (GtkWidget      *widget,
+                                               GdkEventButton *event,
+                                               GvcChannelBar  *bar);
+static gboolean on_scale_button_release_event (GtkWidget      *widget,
+                                               GdkEventButton *event,
+                                               GvcChannelBar  *bar);
+static gboolean on_scale_scroll_event         (GtkWidget      *widget,
+                                               GdkEventScroll *event,
+                                               GvcChannelBar  *bar);
+
+G_DEFINE_TYPE (GvcChannelBar, gvc_channel_bar, GTK_TYPE_HBOX)
+
+static GtkWidget *
+_scale_box_new (GvcChannelBar *bar)
+{
+        GvcChannelBarPrivate *priv = bar->priv;
+        GtkWidget            *box;
+        GtkWidget            *sbox;
+        GtkWidget            *ebox;
+
+        if (priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                bar->priv->scale_box = box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+
+                priv->scale = gtk_vscale_new (priv->adjustment);
+
+                gtk_widget_set_size_request (priv->scale, -1, SCALE_SIZE);
+                gtk_range_set_inverted (GTK_RANGE (priv->scale), TRUE);
+
+                bar->priv->start_box = sbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), sbox, FALSE, FALSE, 0);
+
+                gtk_box_pack_start (GTK_BOX (sbox), priv->image, FALSE, FALSE, 0);
+                gtk_box_pack_start (GTK_BOX (sbox), priv->label, FALSE, FALSE, 0);
+
+                gtk_box_pack_start (GTK_BOX (sbox), priv->high_image, FALSE, FALSE, 0);
+                gtk_widget_hide (priv->high_image);
+                gtk_box_pack_start (GTK_BOX (box), priv->scale, TRUE, TRUE, 0);
+
+                bar->priv->end_box = ebox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), ebox, FALSE, FALSE, 0);
+
+                gtk_box_pack_start (GTK_BOX (ebox), priv->low_image, FALSE, FALSE, 0);
+                gtk_widget_hide (priv->low_image);
+
+                gtk_box_pack_start (GTK_BOX (ebox), priv->mute_box, FALSE, FALSE, 0);
+        } else {
+                bar->priv->scale_box = box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), priv->image, FALSE, FALSE, 0);
+
+                priv->scale = gtk_hscale_new (priv->adjustment);
+
+                gtk_widget_set_size_request (priv->scale, SCALE_SIZE, -1);
+
+                bar->priv->start_box = sbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), sbox, FALSE, FALSE, 0);
+
+                gtk_box_pack_end (GTK_BOX (sbox), priv->low_image, FALSE, FALSE, 0);
+                gtk_widget_show (priv->low_image);
+
+                gtk_box_pack_start (GTK_BOX (sbox), priv->label, TRUE, TRUE, 0);
+                gtk_box_pack_start (GTK_BOX (box), priv->scale, TRUE, TRUE, 0);
+
+                bar->priv->end_box = ebox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), ebox, FALSE, FALSE, 0);
+
+                gtk_box_pack_start (GTK_BOX (ebox), priv->high_image, FALSE, FALSE, 0);
+                gtk_widget_show (priv->high_image);
+                gtk_box_pack_start (GTK_BOX (ebox), priv->mute_box, FALSE, FALSE, 0);
+        }
+
+        ca_gtk_widget_disable_sounds (bar->priv->scale, FALSE);
+        gtk_widget_add_events (bar->priv->scale, GDK_SCROLL_MASK);
+
+        g_signal_connect (G_OBJECT (bar->priv->scale), "button-press-event",
+                          G_CALLBACK (on_scale_button_press_event), bar);
+        g_signal_connect (G_OBJECT (bar->priv->scale), "button-release-event",
+                          G_CALLBACK (on_scale_button_release_event), bar);
+        g_signal_connect (G_OBJECT (bar->priv->scale), "scroll-event",
+                          G_CALLBACK (on_scale_scroll_event), bar);
+
+        if (bar->priv->size_group != NULL) {
+                gtk_size_group_add_widget (bar->priv->size_group, sbox);
+
+                if (bar->priv->symmetric) {
+                        gtk_size_group_add_widget (bar->priv->size_group, ebox);
+                }
+        }
+
+        gtk_scale_set_draw_value (GTK_SCALE (priv->scale), FALSE);
+
+        return box;
+}
+
+static void
+update_image (GvcChannelBar *bar)
+{
+        gtk_image_set_from_icon_name (GTK_IMAGE (bar->priv->image),
+                                      bar->priv->icon_name,
+                                      GTK_ICON_SIZE_DIALOG);
+
+        if (bar->priv->icon_name != NULL) {
+                gtk_widget_show (bar->priv->image);
+        } else {
+                gtk_widget_hide (bar->priv->image);
+        }
+}
+
+static void
+update_label (GvcChannelBar *bar)
+{
+        if (bar->priv->name != NULL) {
+                gtk_label_set_text_with_mnemonic (GTK_LABEL (bar->priv->label),
+                                                  bar->priv->name);
+                gtk_label_set_mnemonic_widget (GTK_LABEL (bar->priv->label),
+                                               bar->priv->scale);
+                gtk_widget_show (bar->priv->label);
+        } else {
+                gtk_label_set_text (GTK_LABEL (bar->priv->label), NULL);
+                gtk_widget_hide (bar->priv->label);
+        }
+}
+
+static void
+update_layout (GvcChannelBar *bar)
+{
+        GtkWidget *box;
+        GtkWidget *frame;
+
+        if (bar->priv->scale == NULL) {
+                return;
+        }
+
+        box = bar->priv->scale_box;
+        frame = gtk_widget_get_parent (box);
+
+        g_object_ref (bar->priv->image);
+        g_object_ref (bar->priv->label);
+        g_object_ref (bar->priv->mute_box);
+        g_object_ref (bar->priv->low_image);
+        g_object_ref (bar->priv->high_image);
+
+        gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->image);
+        gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->label);
+        gtk_container_remove (GTK_CONTAINER (bar->priv->end_box), bar->priv->mute_box);
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->low_image);
+                gtk_container_remove (GTK_CONTAINER (bar->priv->end_box), bar->priv->high_image);
+        } else {
+                gtk_container_remove (GTK_CONTAINER (bar->priv->end_box), bar->priv->low_image);
+                gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->high_image);
+        }
+
+        gtk_container_remove (GTK_CONTAINER (box), bar->priv->start_box);
+        gtk_container_remove (GTK_CONTAINER (box), bar->priv->scale);
+        gtk_container_remove (GTK_CONTAINER (box), bar->priv->end_box);
+        gtk_container_remove (GTK_CONTAINER (frame), box);
+
+        bar->priv->scale_box = _scale_box_new (bar);
+        gtk_container_add (GTK_CONTAINER (frame), bar->priv->scale_box);
+
+        g_object_unref (bar->priv->image);
+        g_object_unref (bar->priv->label);
+        g_object_unref (bar->priv->mute_box);
+        g_object_unref (bar->priv->low_image);
+        g_object_unref (bar->priv->high_image);
+
+        gtk_widget_show_all (frame);
+}
+
+void
+gvc_channel_bar_set_size_group (GvcChannelBar *bar,
+                                GtkSizeGroup  *group,
+                                gboolean       symmetric)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        bar->priv->size_group = group;
+        bar->priv->symmetric = symmetric;
+
+        if (bar->priv->size_group != NULL) {
+                gtk_size_group_add_widget (bar->priv->size_group,
+                                           bar->priv->start_box);
+
+                if (bar->priv->symmetric) {
+                        gtk_size_group_add_widget (bar->priv->size_group,
+                                                   bar->priv->end_box);
+                }
+        }
+        gtk_widget_queue_draw (GTK_WIDGET (bar));
+}
+
+void
+gvc_channel_bar_set_name (GvcChannelBar  *bar,
+                          const char     *name)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        g_free (bar->priv->name);
+        bar->priv->name = g_strdup (name);
+        update_label (bar);
+        g_object_notify (G_OBJECT (bar), "name");
+}
+
+void
+gvc_channel_bar_set_icon_name (GvcChannelBar  *bar,
+                               const char     *name)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        g_free (bar->priv->icon_name);
+        bar->priv->icon_name = g_strdup (name);
+        update_image (bar);
+        g_object_notify (G_OBJECT (bar), "icon-name");
+}
+
+void
+gvc_channel_bar_set_low_icon_name   (GvcChannelBar *bar,
+                                     const char    *name)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (name != NULL && strcmp (bar->priv->low_icon_name, name) != 0) {
+                g_free (bar->priv->low_icon_name);
+                bar->priv->low_icon_name = g_strdup (name);
+                gtk_image_set_from_icon_name (GTK_IMAGE (bar->priv->low_image),
+                                              bar->priv->low_icon_name,
+                                              GTK_ICON_SIZE_MENU);
+                g_object_notify (G_OBJECT (bar), "low-icon-name");
+        }
+}
+
+void
+gvc_channel_bar_set_high_icon_name  (GvcChannelBar *bar,
+                                     const char    *name)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (name != NULL && strcmp (bar->priv->high_icon_name, name) != 0) {
+                g_free (bar->priv->high_icon_name);
+                bar->priv->high_icon_name = g_strdup (name);
+                gtk_image_set_from_icon_name (GTK_IMAGE (bar->priv->high_image),
+                                              bar->priv->high_icon_name,
+                                              GTK_ICON_SIZE_MENU);
+                g_object_notify (G_OBJECT (bar), "high-icon-name");
+        }
+}
+
+void
+gvc_channel_bar_set_orientation (GvcChannelBar  *bar,
+                                 GtkOrientation  orientation)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (orientation != bar->priv->orientation) {
+                bar->priv->orientation = orientation;
+                update_layout (bar);
+                g_object_notify (G_OBJECT (bar), "orientation");
+        }
+}
+
+static void
+gvc_channel_bar_set_adjustment (GvcChannelBar *bar,
+                                GtkAdjustment *adjustment)
+{
+        g_return_if_fail (GVC_CHANNEL_BAR (bar));
+        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
+
+        if (bar->priv->adjustment != NULL) {
+                g_object_unref (bar->priv->adjustment);
+        }
+        bar->priv->adjustment = g_object_ref_sink (adjustment);
+
+        if (bar->priv->scale != NULL) {
+                gtk_range_set_adjustment (GTK_RANGE (bar->priv->scale), adjustment);
+        }
+
+        g_object_notify (G_OBJECT (bar), "adjustment");
+}
+
+GtkAdjustment *
+gvc_channel_bar_get_adjustment (GvcChannelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), NULL);
+
+        return bar->priv->adjustment;
+}
+
+static gboolean
+on_scale_button_press_event (GtkWidget      *widget,
+                             GdkEventButton *event,
+                             GvcChannelBar  *bar)
+{
+        bar->priv->click_lock = TRUE;
+
+        return FALSE;
+}
+
+static gboolean
+on_scale_button_release_event (GtkWidget      *widget,
+                               GdkEventButton *event,
+                               GvcChannelBar  *bar)
+{
+        GtkAdjustment *adj;
+        gdouble value;
+
+        bar->priv->click_lock = FALSE;
+
+        adj = gtk_range_get_adjustment (GTK_RANGE (widget));
+
+        value = gtk_adjustment_get_value (adj);
+
+        /* this means the adjustment moved away from zero and
+         * therefore we should unmute and set the volume. */
+        gvc_channel_bar_set_is_muted (bar, (value == 0.0));
+
+        /* Play a sound! */
+        ca_gtk_play_for_widget (GTK_WIDGET (bar), 0,
+                                CA_PROP_EVENT_ID, "audio-volume-change",
+                                CA_PROP_EVENT_DESCRIPTION, "foobar event happened",
+                                CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+                                NULL);
+
+        return FALSE;
+}
+
+gboolean
+gvc_channel_bar_scroll (GvcChannelBar *bar, GdkEventScroll *event)
+{
+        GtkAdjustment *adj;
+        gdouble value;
+        GdkScrollDirection direction;
+        gdouble dx, dy;
+
+        g_return_val_if_fail (bar != NULL, FALSE);
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
+
+        direction = event->direction;
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                if (direction == GDK_SCROLL_LEFT || direction == GDK_SCROLL_RIGHT)
+                        return FALSE;
+        } else {
+                /* Switch direction for RTL */
+                if (gtk_widget_get_direction (GTK_WIDGET (bar)) == GTK_TEXT_DIR_RTL) {
+                        if (direction == GDK_SCROLL_RIGHT)
+                                direction = GDK_SCROLL_LEFT;
+                        else if (direction == GDK_SCROLL_LEFT)
+                                direction = GDK_SCROLL_RIGHT;
+                }
+                /* Switch side scroll to vertical */
+                if (direction == GDK_SCROLL_RIGHT)
+                        direction = GDK_SCROLL_UP;
+                else if (direction == GDK_SCROLL_LEFT)
+                        direction = GDK_SCROLL_DOWN;
+        }
+
+	if (!gdk_event_get_scroll_deltas ((GdkEvent*)event, &dx, &dy)) {
+		dx = 0.0;
+		dy = 0.0;
+
+		switch (direction) {
+		case GDK_SCROLL_UP:
+		case GDK_SCROLL_LEFT:
+			dy = 1.0;
+			break;
+		case GDK_SCROLL_DOWN:
+		case GDK_SCROLL_RIGHT:
+			dy = -1.0;
+			break;
+		default:
+			;
+		}
+	}
+
+        adj = gtk_range_get_adjustment (GTK_RANGE (bar->priv->scale));
+        if (adj == bar->priv->zero_adjustment) {
+                if (dy > 0)
+                        gvc_channel_bar_set_is_muted (bar, FALSE);
+                return TRUE;
+        }
+
+        value = gtk_adjustment_get_value (adj);
+
+        if (dy > 0) {
+                if (value + dy * SCROLLSTEP > ADJUSTMENT_MAX)
+                        value = ADJUSTMENT_MAX;
+                else
+                        value = value + dy * SCROLLSTEP;
+        } else if (dy < 0) {
+                if (value + dy * SCROLLSTEP < 0)
+                        value = 0.0;
+                else
+                        value = value + dy * SCROLLSTEP;
+        }
+
+        gvc_channel_bar_set_is_muted (bar, (value == 0.0));
+        adj = gtk_range_get_adjustment (GTK_RANGE (bar->priv->scale));
+        gtk_adjustment_set_value (adj, value);
+
+        return TRUE;
+}
+
+static gboolean
+on_scale_scroll_event (GtkWidget      *widget,
+                       GdkEventScroll *event,
+                       GvcChannelBar  *bar)
+{
+        return gvc_channel_bar_scroll (bar, event);
+}
+
+static void
+on_zero_adjustment_value_changed (GtkAdjustment *adjustment,
+                                  GvcChannelBar *bar)
+{
+        gdouble value;
+
+        if (bar->priv->click_lock != FALSE) {
+                return;
+        }
+
+        value = gtk_adjustment_get_value (bar->priv->zero_adjustment);
+        gtk_adjustment_set_value (bar->priv->adjustment, value);
+
+
+        if (bar->priv->show_mute == FALSE) {
+                /* this means the adjustment moved away from zero and
+                 * therefore we should unmute and set the volume. */
+                gvc_channel_bar_set_is_muted (bar, value > 0.0);
+        }
+}
+
+static void
+update_mute_button (GvcChannelBar *bar)
+{
+        if (bar->priv->show_mute) {
+                gtk_widget_show (bar->priv->mute_button);
+                gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (bar->priv->mute_button),
+                                              bar->priv->is_muted);
+        } else {
+                gtk_widget_hide (bar->priv->mute_button);
+        }
+
+        if (bar->priv->is_muted) {
+                /* If we aren't showing the mute button then
+                 * move slider to the zero.  But we don't want to
+                 * change the adjustment.  */
+                g_signal_handlers_block_by_func (bar->priv->zero_adjustment,
+                                                 on_zero_adjustment_value_changed,
+                                                 bar);
+                gtk_adjustment_set_value (bar->priv->zero_adjustment, 0);
+                g_signal_handlers_unblock_by_func (bar->priv->zero_adjustment,
+                                                   on_zero_adjustment_value_changed,
+                                                   bar);
+                gtk_range_set_adjustment (GTK_RANGE (bar->priv->scale),
+                                          bar->priv->zero_adjustment);
+        } else {
+                /* no longer muted so restore the original adjustment
+                 * and tell the front-end that the value changed */
+                gtk_range_set_adjustment (GTK_RANGE (bar->priv->scale),
+                                          bar->priv->adjustment);
+                gtk_adjustment_value_changed (bar->priv->adjustment);
+        }
+}
+
+void
+gvc_channel_bar_set_is_muted (GvcChannelBar *bar,
+                              gboolean       is_muted)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (is_muted != bar->priv->is_muted) {
+                /* Update our internal state before telling the
+                 * front-end about our changes */
+                bar->priv->is_muted = is_muted;
+                update_mute_button (bar);
+                g_object_notify (G_OBJECT (bar), "is-muted");
+        }
+}
+
+gboolean
+gvc_channel_bar_get_is_muted  (GvcChannelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
+        return bar->priv->is_muted;
+}
+
+void
+gvc_channel_bar_set_show_mute (GvcChannelBar *bar,
+                               gboolean       show_mute)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (show_mute != bar->priv->show_mute) {
+                bar->priv->show_mute = show_mute;
+                g_object_notify (G_OBJECT (bar), "show-mute");
+                update_mute_button (bar);
+        }
+}
+
+gboolean
+gvc_channel_bar_get_show_mute (GvcChannelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
+        return bar->priv->show_mute;
+}
+
+void
+gvc_channel_bar_set_is_amplified (GvcChannelBar *bar, gboolean amplified)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        bar->priv->is_amplified = amplified;
+        gtk_adjustment_set_upper (bar->priv->adjustment, ADJUSTMENT_MAX);
+        gtk_adjustment_set_upper (bar->priv->zero_adjustment, ADJUSTMENT_MAX);
+        gtk_scale_clear_marks (GTK_SCALE (bar->priv->scale));
+
+        if (amplified) {
+                char *str;
+
+                if (bar->priv->base_volume == ADJUSTMENT_MAX_NORMAL) {
+                        str = g_strdup_printf ("<small>%s</small>", C_("volume", "100%"));
+                        gtk_scale_add_mark (GTK_SCALE (bar->priv->scale), ADJUSTMENT_MAX_NORMAL,
+                                            GTK_POS_BOTTOM, str);
+                } else {
+                        str = g_strdup_printf ("<small>%s</small>", C_("volume", "Unamplified"));
+                        gtk_scale_add_mark (GTK_SCALE (bar->priv->scale), bar->priv->base_volume,
+                                            GTK_POS_BOTTOM, str);
+                        /* Only show 100% if it's higher than the base volume */
+                        if (bar->priv->base_volume < ADJUSTMENT_MAX_NORMAL) {
+                                str = g_strdup_printf ("<small>%s</small>", C_("volume", "100%"));
+                                gtk_scale_add_mark (GTK_SCALE (bar->priv->scale), ADJUSTMENT_MAX_NORMAL,
+                                                    GTK_POS_BOTTOM, str);
+                        }
+                }
+
+                g_free (str);
+                gtk_alignment_set (GTK_ALIGNMENT (bar->priv->mute_box), 0.5, 0, 0, 0);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->low_image), 0.5, 0.15);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->high_image), 0.5, 0.15);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->label), 0, 0);
+        } else {
+                gtk_alignment_set (GTK_ALIGNMENT (bar->priv->mute_box), 0.5, 0.5, 0, 0);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->low_image), 0.5, 0.5);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->high_image), 0.5, 0.5);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->label), 0, 0.5);
+        }
+}
+
+gboolean
+gvc_channel_bar_get_ellipsize (GvcChannelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
+
+        return gtk_label_get_ellipsize (GTK_LABEL (bar->priv->label)) != PANGO_ELLIPSIZE_NONE;
+}
+
+void
+gvc_channel_bar_set_ellipsize (GvcChannelBar *bar,
+                               gboolean       ellipsized)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (ellipsized)
+                gtk_label_set_ellipsize (GTK_LABEL (bar->priv->label), PANGO_ELLIPSIZE_END);
+	else
+                gtk_label_set_ellipsize (GTK_LABEL (bar->priv->label), PANGO_ELLIPSIZE_NONE);
+}
+
+void
+gvc_channel_bar_set_base_volume (GvcChannelBar *bar,
+                                 pa_volume_t    base_volume)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (base_volume == 0) {
+                bar->priv->base_volume = ADJUSTMENT_MAX_NORMAL;
+                return;
+        }
+
+        /* Note that you need to call _is_amplified() afterwards to update the marks */
+        bar->priv->base_volume = base_volume;
+}
+
+static void
+gvc_channel_bar_set_property (GObject       *object,
+                              guint          prop_id,
+                              const GValue  *value,
+                              GParamSpec    *pspec)
+{
+        GvcChannelBar *self = GVC_CHANNEL_BAR (object);
+
+        switch (prop_id) {
+        case PROP_ORIENTATION:
+                gvc_channel_bar_set_orientation (self, g_value_get_enum (value));
+                break;
+        case PROP_IS_MUTED:
+                gvc_channel_bar_set_is_muted (self, g_value_get_boolean (value));
+                break;
+        case PROP_SHOW_MUTE:
+                gvc_channel_bar_set_show_mute (self, g_value_get_boolean (value));
+                break;
+        case PROP_NAME:
+                gvc_channel_bar_set_name (self, g_value_get_string (value));
+                break;
+        case PROP_ICON_NAME:
+                gvc_channel_bar_set_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_LOW_ICON_NAME:
+                gvc_channel_bar_set_low_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_HIGH_ICON_NAME:
+                gvc_channel_bar_set_high_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_ADJUSTMENT:
+                gvc_channel_bar_set_adjustment (self, g_value_get_object (value));
+                break;
+        case PROP_IS_AMPLIFIED:
+                gvc_channel_bar_set_is_amplified (self, g_value_get_boolean (value));
+                break;
+        case PROP_ELLIPSIZE:
+                gvc_channel_bar_set_ellipsize (self, g_value_get_boolean (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_channel_bar_get_property (GObject     *object,
+                              guint        prop_id,
+                              GValue      *value,
+                              GParamSpec  *pspec)
+{
+        GvcChannelBar *self = GVC_CHANNEL_BAR (object);
+        GvcChannelBarPrivate *priv = self->priv;
+
+        switch (prop_id) {
+        case PROP_ORIENTATION:
+                g_value_set_enum (value, priv->orientation);
+                break;
+        case PROP_IS_MUTED:
+                g_value_set_boolean (value, priv->is_muted);
+                break;
+        case PROP_SHOW_MUTE:
+                g_value_set_boolean (value, priv->show_mute);
+                break;
+        case PROP_NAME:
+                g_value_set_string (value, priv->name);
+                break;
+        case PROP_ICON_NAME:
+                g_value_set_string (value, priv->icon_name);
+                break;
+        case PROP_LOW_ICON_NAME:
+                g_value_set_string (value, priv->low_icon_name);
+                break;
+        case PROP_HIGH_ICON_NAME:
+                g_value_set_string (value, priv->high_icon_name);
+                break;
+        case PROP_ADJUSTMENT:
+                g_value_set_object (value, gvc_channel_bar_get_adjustment (self));
+                break;
+        case PROP_IS_AMPLIFIED:
+                g_value_set_boolean (value, priv->is_amplified);
+                break;
+        case PROP_ELLIPSIZE:
+                g_value_set_boolean (value, gvc_channel_bar_get_ellipsize (self));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_channel_bar_constructor (GType                  type,
+                             guint                  n_construct_properties,
+                             GObjectConstructParam *construct_params)
+{
+        GObject       *object;
+        GvcChannelBar *self;
+
+        object = G_OBJECT_CLASS (gvc_channel_bar_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_CHANNEL_BAR (object);
+
+        update_mute_button (self);
+
+        return object;
+}
+
+static void
+gvc_channel_bar_class_init (GvcChannelBarClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_channel_bar_constructor;
+        object_class->finalize = gvc_channel_bar_finalize;
+        object_class->set_property = gvc_channel_bar_set_property;
+        object_class->get_property = gvc_channel_bar_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_ORIENTATION,
+                                         g_param_spec_enum ("orientation",
+                                                            "Orientation",
+                                                            "The orientation of the scale",
+                                                            GTK_TYPE_ORIENTATION,
+                                                            GTK_ORIENTATION_VERTICAL,
+                                                            G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_IS_MUTED,
+                                         g_param_spec_boolean ("is-muted",
+                                                               "is muted",
+                                                               "Whether stream is muted",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_SHOW_MUTE,
+                                         g_param_spec_boolean ("show-mute",
+                                                               "show mute",
+                                                               "Whether stream is muted",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_object_class_install_property (object_class,
+                                         PROP_ADJUSTMENT,
+                                         g_param_spec_object ("adjustment",
+                                                              "Adjustment",
+                                                              "The GtkAdjustment that contains the current value of this scale button object",
+                                                              GTK_TYPE_ADJUSTMENT,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_NAME,
+                                         g_param_spec_string ("name",
+                                                              "Name",
+                                                              "Name to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_ICON_NAME,
+                                         g_param_spec_string ("icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_LOW_ICON_NAME,
+                                         g_param_spec_string ("low-icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this stream",
+                                                              "audio-volume-low-symbolic",
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_HIGH_ICON_NAME,
+                                         g_param_spec_string ("high-icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this stream",
+                                                              "audio-volume-high-symbolic",
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_IS_AMPLIFIED,
+                                         g_param_spec_boolean ("is-amplified",
+                                                               "Is amplified",
+                                                               "Whether the stream is digitally amplified",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_ELLIPSIZE,
+                                         g_param_spec_boolean ("ellipsize",
+                                                               "Label is ellipsized",
+                                                               "Whether the label is ellipsized",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_type_class_add_private (klass, sizeof (GvcChannelBarPrivate));
+}
+
+static void
+on_mute_button_toggled (GtkToggleButton *button,
+                        GvcChannelBar   *bar)
+{
+        gboolean is_muted;
+        is_muted = gtk_toggle_button_get_active (button);
+        gvc_channel_bar_set_is_muted (bar, is_muted);
+}
+
+static void
+gvc_channel_bar_init (GvcChannelBar *bar)
+{
+        GtkWidget *frame;
+
+        bar->priv = GVC_CHANNEL_BAR_GET_PRIVATE (bar);
+
+        bar->priv->base_volume = ADJUSTMENT_MAX_NORMAL;
+        bar->priv->low_icon_name = g_strdup ("audio-volume-low-symbolic");
+        bar->priv->high_icon_name = g_strdup ("audio-volume-high-symbolic");
+
+        bar->priv->orientation = GTK_ORIENTATION_VERTICAL;
+        bar->priv->adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                    0.0,
+                                                                    ADJUSTMENT_MAX_NORMAL,
+                                                                    ADJUSTMENT_MAX_NORMAL/100.0,
+                                                                    ADJUSTMENT_MAX_NORMAL/10.0,
+                                                                    0.0));
+        g_object_ref_sink (bar->priv->adjustment);
+
+        bar->priv->zero_adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                         0.0,
+                                                                         ADJUSTMENT_MAX_NORMAL,
+                                                                         ADJUSTMENT_MAX_NORMAL/100.0,
+                                                                         ADJUSTMENT_MAX_NORMAL/10.0,
+                                                                         0.0));
+        g_object_ref_sink (bar->priv->zero_adjustment);
+
+        g_signal_connect (bar->priv->zero_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_zero_adjustment_value_changed),
+                          bar);
+
+        bar->priv->mute_button = gtk_check_button_new_with_label (_("Mute"));
+        gtk_widget_set_no_show_all (bar->priv->mute_button, TRUE);
+        g_signal_connect (bar->priv->mute_button,
+                          "toggled",
+                          G_CALLBACK (on_mute_button_toggled),
+                          bar);
+        bar->priv->mute_box = gtk_alignment_new (0.5, 0.5, 0, 0);
+        gtk_container_add (GTK_CONTAINER (bar->priv->mute_box), bar->priv->mute_button);
+
+        bar->priv->low_image = gtk_image_new_from_icon_name ("audio-volume-low-symbolic",
+                                                             GTK_ICON_SIZE_MENU);
+        gtk_widget_set_no_show_all (bar->priv->low_image, TRUE);
+        bar->priv->high_image = gtk_image_new_from_icon_name ("audio-volume-high-symbolic",
+                                                              GTK_ICON_SIZE_MENU);
+        gtk_widget_set_no_show_all (bar->priv->high_image, TRUE);
+
+        bar->priv->image = gtk_image_new ();
+        gtk_widget_set_no_show_all (bar->priv->image, TRUE);
+
+        bar->priv->label = gtk_label_new (NULL);
+        gtk_misc_set_alignment (GTK_MISC (bar->priv->label), 0.0, 0.5);
+        gtk_widget_set_no_show_all (bar->priv->label, TRUE);
+
+        /* frame */
+        frame = gtk_frame_new (NULL);
+        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
+        gtk_container_add (GTK_CONTAINER (bar), frame);
+        gtk_widget_show_all (frame);
+
+        /* box with scale */
+        bar->priv->scale_box = _scale_box_new (bar);
+
+        gtk_container_add (GTK_CONTAINER (frame), bar->priv->scale_box);
+}
+
+static void
+gvc_channel_bar_finalize (GObject *object)
+{
+        GvcChannelBar *channel_bar;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (object));
+
+        channel_bar = GVC_CHANNEL_BAR (object);
+
+        g_return_if_fail (channel_bar->priv != NULL);
+
+        g_free (channel_bar->priv->name);
+        g_free (channel_bar->priv->icon_name);
+        g_free (channel_bar->priv->low_icon_name);
+        g_free (channel_bar->priv->high_icon_name);
+
+        G_OBJECT_CLASS (gvc_channel_bar_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_channel_bar_new (void)
+{
+        GObject *bar;
+        bar = g_object_new (GVC_TYPE_CHANNEL_BAR,
+                            NULL);
+        return GTK_WIDGET (bar);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-bar.h gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-bar.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-bar.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-bar.h	2012-09-28 19:08:52.475641713 -0400
@@ -0,0 +1,89 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_CHANNEL_BAR_H
+#define __GVC_CHANNEL_BAR_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_CHANNEL_BAR         (gvc_channel_bar_get_type ())
+#define GVC_CHANNEL_BAR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_CHANNEL_BAR, GvcChannelBar))
+#define GVC_CHANNEL_BAR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_CHANNEL_BAR, GvcChannelBarClass))
+#define GVC_IS_CHANNEL_BAR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_CHANNEL_BAR))
+#define GVC_IS_CHANNEL_BAR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_CHANNEL_BAR))
+#define GVC_CHANNEL_BAR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_CHANNEL_BAR, GvcChannelBarClass))
+
+typedef struct GvcChannelBarPrivate GvcChannelBarPrivate;
+
+typedef struct
+{
+        GtkHBox               parent;
+        GvcChannelBarPrivate *priv;
+} GvcChannelBar;
+
+typedef struct
+{
+        GtkHBoxClass          parent_class;
+} GvcChannelBarClass;
+
+GType               gvc_channel_bar_get_type            (void);
+
+GtkWidget *         gvc_channel_bar_new                 (void);
+
+void                gvc_channel_bar_set_name            (GvcChannelBar *bar,
+                                                         const char    *name);
+void                gvc_channel_bar_set_icon_name       (GvcChannelBar *bar,
+                                                         const char    *icon_name);
+void                gvc_channel_bar_set_low_icon_name   (GvcChannelBar *bar,
+                                                         const char    *icon_name);
+void                gvc_channel_bar_set_high_icon_name  (GvcChannelBar *bar,
+                                                         const char    *icon_name);
+
+void                gvc_channel_bar_set_orientation     (GvcChannelBar *bar,
+                                                         GtkOrientation orientation);
+GtkOrientation      gvc_channel_bar_get_orientation     (GvcChannelBar *bar);
+
+GtkAdjustment *     gvc_channel_bar_get_adjustment      (GvcChannelBar *bar);
+
+gboolean            gvc_channel_bar_get_is_muted        (GvcChannelBar *bar);
+void                gvc_channel_bar_set_is_muted        (GvcChannelBar *bar,
+                                                         gboolean       is_muted);
+gboolean            gvc_channel_bar_get_show_mute       (GvcChannelBar *bar);
+void                gvc_channel_bar_set_show_mute       (GvcChannelBar *bar,
+                                                         gboolean       show_mute);
+void                gvc_channel_bar_set_size_group      (GvcChannelBar *bar,
+                                                         GtkSizeGroup  *group,
+                                                         gboolean       symmetric);
+void                gvc_channel_bar_set_is_amplified    (GvcChannelBar *bar,
+                                                         gboolean amplified);
+void                gvc_channel_bar_set_base_volume     (GvcChannelBar *bar,
+                                                         guint32        base_volume);
+gboolean            gvc_channel_bar_get_ellipsize       (GvcChannelBar *bar);
+void                gvc_channel_bar_set_ellipsize       (GvcChannelBar *bar,
+                                                         gboolean       ellipsized);
+
+gboolean            gvc_channel_bar_scroll              (GvcChannelBar  *bar,
+                                                         GdkEventScroll *event);
+
+G_END_DECLS
+
+#endif /* __GVC_CHANNEL_BAR_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-map.c gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-map.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-map.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-map.c	2012-09-28 19:08:52.476641714 -0400
@@ -0,0 +1,254 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-channel-map.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_CHANNEL_MAP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_CHANNEL_MAP, GvcChannelMapPrivate))
+
+struct GvcChannelMapPrivate
+{
+        pa_channel_map        pa_map;
+        gboolean              pa_volume_is_set;
+        pa_cvolume            pa_volume;
+        gdouble               extern_volume[NUM_TYPES]; /* volume, balance, fade, lfe */
+        gboolean              can_balance;
+        gboolean              can_fade;
+};
+
+enum {
+        VOLUME_CHANGED,
+        LAST_SIGNAL
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+static void     gvc_channel_map_class_init (GvcChannelMapClass *klass);
+static void     gvc_channel_map_init       (GvcChannelMap      *channel_map);
+static void     gvc_channel_map_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcChannelMap, gvc_channel_map, G_TYPE_OBJECT)
+
+guint
+gvc_channel_map_get_num_channels (const GvcChannelMap *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), 0);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return 0;
+
+        return map->priv->pa_map.channels;
+}
+
+const gdouble *
+gvc_channel_map_get_volume (GvcChannelMap *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), NULL);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return NULL;
+
+        map->priv->extern_volume[VOLUME] = (gdouble) pa_cvolume_max (&map->priv->pa_volume);
+        if (gvc_channel_map_can_balance (map))
+                map->priv->extern_volume[BALANCE] = (gdouble) pa_cvolume_get_balance (&map->priv->pa_volume, &map->priv->pa_map);
+        else
+                map->priv->extern_volume[BALANCE] = 0;
+        if (gvc_channel_map_can_fade (map))
+                map->priv->extern_volume[FADE] = (gdouble) pa_cvolume_get_fade (&map->priv->pa_volume, &map->priv->pa_map);
+        else
+                map->priv->extern_volume[FADE] = 0;
+        if (gvc_channel_map_has_lfe (map))
+                map->priv->extern_volume[LFE] = (gdouble) pa_cvolume_get_position (&map->priv->pa_volume, &map->priv->pa_map, PA_CHANNEL_POSITION_LFE);
+        else
+                map->priv->extern_volume[LFE] = 0;
+
+        return map->priv->extern_volume;
+}
+
+gboolean
+gvc_channel_map_can_balance (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), FALSE);
+
+        return map->priv->can_balance;
+}
+
+gboolean
+gvc_channel_map_can_fade (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), FALSE);
+
+        return map->priv->can_fade;
+}
+
+const char *
+gvc_channel_map_get_mapping (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), NULL);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return NULL;
+
+        return pa_channel_map_to_pretty_name (&map->priv->pa_map);
+}
+
+/**
+ * gvc_channel_map_has_position: (skip)
+ *
+ * @map:
+ * @position:
+ *
+ * Returns:
+ */
+gboolean
+gvc_channel_map_has_position (const GvcChannelMap  *map,
+                              pa_channel_position_t position)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), FALSE);
+
+        return pa_channel_map_has_position (&(map->priv->pa_map), position);
+}
+
+const pa_channel_map *
+gvc_channel_map_get_pa_channel_map (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), NULL);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return NULL;
+
+        return &map->priv->pa_map;
+}
+
+const pa_cvolume *
+gvc_channel_map_get_cvolume (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), NULL);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return NULL;
+
+        return &map->priv->pa_volume;
+}
+
+static void
+gvc_channel_map_class_init (GvcChannelMapClass *klass)
+{
+        GObjectClass   *gobject_class = G_OBJECT_CLASS (klass);
+
+        gobject_class->finalize = gvc_channel_map_finalize;
+
+        signals [VOLUME_CHANGED] =
+                g_signal_new ("volume-changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcChannelMapClass, volume_changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__BOOLEAN,
+                              G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
+
+        g_type_class_add_private (klass, sizeof (GvcChannelMapPrivate));
+}
+
+void
+gvc_channel_map_volume_changed (GvcChannelMap     *map,
+                                const pa_cvolume  *cv,
+                                gboolean           set)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_MAP (map));
+        g_return_if_fail (cv != NULL);
+        g_return_if_fail (pa_cvolume_compatible_with_channel_map(cv, &map->priv->pa_map));
+
+        if (pa_cvolume_equal(cv, &map->priv->pa_volume))
+                return;
+
+        map->priv->pa_volume = *cv;
+
+        if (map->priv->pa_volume_is_set == FALSE) {
+                map->priv->pa_volume_is_set = TRUE;
+                return;
+        }
+        g_signal_emit (map, signals[VOLUME_CHANGED], 0, set);
+}
+
+static void
+gvc_channel_map_init (GvcChannelMap *map)
+{
+        map->priv = GVC_CHANNEL_MAP_GET_PRIVATE (map);
+        map->priv->pa_volume_is_set = FALSE;
+}
+
+static void
+gvc_channel_map_finalize (GObject *object)
+{
+        GvcChannelMap *channel_map;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_CHANNEL_MAP (object));
+
+        channel_map = GVC_CHANNEL_MAP (object);
+
+        g_return_if_fail (channel_map->priv != NULL);
+
+        G_OBJECT_CLASS (gvc_channel_map_parent_class)->finalize (object);
+}
+
+GvcChannelMap *
+gvc_channel_map_new (void)
+{
+        GObject *map;
+        map = g_object_new (GVC_TYPE_CHANNEL_MAP, NULL);
+        return GVC_CHANNEL_MAP (map);
+}
+
+static void
+set_from_pa_map (GvcChannelMap        *map,
+                 const pa_channel_map *pa_map)
+{
+        g_assert (pa_channel_map_valid(pa_map));
+
+        map->priv->can_balance = pa_channel_map_can_balance (pa_map);
+        map->priv->can_fade = pa_channel_map_can_fade (pa_map);
+
+        map->priv->pa_map = *pa_map;
+        pa_cvolume_set(&map->priv->pa_volume, pa_map->channels, PA_VOLUME_NORM);
+}
+
+GvcChannelMap *
+gvc_channel_map_new_from_pa_channel_map (const pa_channel_map *pa_map)
+{
+        GObject *map;
+        map = g_object_new (GVC_TYPE_CHANNEL_MAP, NULL);
+
+        set_from_pa_map (GVC_CHANNEL_MAP (map), pa_map);
+
+        return GVC_CHANNEL_MAP (map);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-map.h gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-map.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-map.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-map.h	2012-09-28 19:08:52.476641714 -0400
@@ -0,0 +1,73 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_CHANNEL_MAP_H
+#define __GVC_CHANNEL_MAP_H
+
+#include <glib-object.h>
+#include <gvc-pulseaudio-fake.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_CHANNEL_MAP         (gvc_channel_map_get_type ())
+#define GVC_CHANNEL_MAP(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_CHANNEL_MAP, GvcChannelMap))
+#define GVC_CHANNEL_MAP_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_CHANNEL_MAP, GvcChannelMapClass))
+#define GVC_IS_CHANNEL_MAP(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_CHANNEL_MAP))
+#define GVC_IS_CHANNEL_MAP_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_CHANNEL_MAP))
+#define GVC_CHANNEL_MAP_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_CHANNEL_MAP, GvcChannelMapClass))
+
+typedef struct GvcChannelMapPrivate GvcChannelMapPrivate;
+
+typedef struct
+{
+        GObject               parent;
+        GvcChannelMapPrivate *priv;
+} GvcChannelMap;
+
+typedef struct
+{
+        GObjectClass           parent_class;
+        void (*volume_changed) (GvcChannelMap *channel_map, gboolean set);
+} GvcChannelMapClass;
+
+enum {
+        VOLUME,
+        BALANCE,
+        FADE,
+        LFE,
+        NUM_TYPES
+};
+
+GType                   gvc_channel_map_get_type                (void);
+
+GvcChannelMap *         gvc_channel_map_new                     (void);
+guint                   gvc_channel_map_get_num_channels        (const GvcChannelMap  *map);
+const gdouble *         gvc_channel_map_get_volume              (GvcChannelMap  *map);
+gboolean                gvc_channel_map_can_balance             (const GvcChannelMap  *map);
+gboolean                gvc_channel_map_can_fade                (const GvcChannelMap  *map);
+gboolean                gvc_channel_map_has_position            (const GvcChannelMap  *map,
+                                                                 pa_channel_position_t position);
+#define                 gvc_channel_map_has_lfe(x)              gvc_channel_map_has_position (x, PA_CHANNEL_POSITION_LFE)
+
+const char *            gvc_channel_map_get_mapping             (const GvcChannelMap  *map);
+
+G_END_DECLS
+
+#endif /* __GVC_CHANNEL_MAP_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-map-private.h gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-map-private.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-channel-map-private.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-channel-map-private.h	2012-09-28 19:08:52.477641714 -0400
@@ -0,0 +1,39 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_CHANNEL_MAP_PRIVATE_H
+#define __GVC_CHANNEL_MAP_PRIVATE_H
+
+#include <glib-object.h>
+#include <pulse/pulseaudio.h>
+
+G_BEGIN_DECLS
+
+GvcChannelMap *         gvc_channel_map_new_from_pa_channel_map (const pa_channel_map *map);
+const pa_channel_map *  gvc_channel_map_get_pa_channel_map      (const GvcChannelMap  *map);
+
+void                    gvc_channel_map_volume_changed          (GvcChannelMap    *map,
+                                                                 const pa_cvolume *cv,
+                                                                 gboolean          set);
+const pa_cvolume *      gvc_channel_map_get_cvolume             (const GvcChannelMap  *map);
+
+G_END_DECLS
+
+#endif /* __GVC_CHANNEL_MAP_PRIVATE_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-combo-box.c gnome-control-center-3.6.0/panels/sound-nua/gvc-combo-box.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-combo-box.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-combo-box.c	2012-09-28 19:08:52.478641713 -0400
@@ -0,0 +1,410 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Bastien Nocera
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra-gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-combo-box.h"
+#include "gvc-mixer-stream.h"
+#include "gvc-mixer-card.h"
+
+#define GVC_COMBO_BOX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_COMBO_BOX, GvcComboBoxPrivate))
+
+struct GvcComboBoxPrivate
+{
+        GtkWidget     *drop_box;
+        GtkWidget     *start_box;
+        GtkWidget     *end_box;
+        GtkWidget     *label;
+        GtkWidget     *button;
+        GtkTreeModel  *model;
+        GtkWidget     *combobox;
+        gboolean       set_called;
+        GtkSizeGroup  *size_group;
+        gboolean       symmetric;
+};
+
+enum {
+        COL_NAME,
+        COL_HUMAN_NAME,
+        NUM_COLS
+};
+
+enum {
+        CHANGED,
+        BUTTON_CLICKED,
+        LAST_SIGNAL
+};
+
+enum {
+        PROP_0,
+        PROP_LABEL,
+        PROP_SHOW_BUTTON,
+        PROP_BUTTON_LABEL
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+static void     gvc_combo_box_class_init (GvcComboBoxClass *klass);
+static void     gvc_combo_box_init       (GvcComboBox      *combo_box);
+static void     gvc_combo_box_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcComboBox, gvc_combo_box, GTK_TYPE_HBOX)
+
+void
+gvc_combo_box_set_size_group (GvcComboBox *combo_box,
+                              GtkSizeGroup  *group,
+                              gboolean       symmetric)
+{
+        g_return_if_fail (GVC_IS_COMBO_BOX (combo_box));
+
+        combo_box->priv->size_group = group;
+        combo_box->priv->symmetric = symmetric;
+
+        if (combo_box->priv->size_group != NULL) {
+                gtk_size_group_add_widget (combo_box->priv->size_group,
+                                           combo_box->priv->start_box);
+
+                if (combo_box->priv->symmetric) {
+                        gtk_size_group_add_widget (combo_box->priv->size_group,
+                                                   combo_box->priv->end_box);
+                }
+        }
+        gtk_widget_queue_draw (GTK_WIDGET (combo_box));
+}
+
+static void
+gvc_combo_box_set_property (GObject       *object,
+                            guint          prop_id,
+                            const GValue  *value,
+                            GParamSpec    *pspec)
+{
+        GvcComboBox *self = GVC_COMBO_BOX (object);
+
+        switch (prop_id) {
+        case PROP_LABEL:
+                gtk_label_set_text_with_mnemonic (GTK_LABEL (self->priv->label), g_value_get_string (value));
+                break;
+        case PROP_BUTTON_LABEL:
+                gtk_button_set_label (GTK_BUTTON (self->priv->button), g_value_get_string (value));
+                break;
+        case PROP_SHOW_BUTTON:
+                gtk_widget_set_visible (self->priv->button, g_value_get_boolean (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_combo_box_get_property (GObject     *object,
+                            guint        prop_id,
+                            GValue      *value,
+                            GParamSpec  *pspec)
+{
+        GvcComboBox *self = GVC_COMBO_BOX (object);
+
+        switch (prop_id) {
+        case PROP_LABEL:
+                g_value_set_string (value,
+                                    gtk_label_get_text (GTK_LABEL (self->priv->label)));
+                break;
+        case PROP_BUTTON_LABEL:
+                g_value_set_string (value,
+                                    gtk_button_get_label (GTK_BUTTON (self->priv->button)));
+                break;
+        case PROP_SHOW_BUTTON:
+                g_value_set_boolean (value,
+                                     gtk_widget_get_visible (self->priv->button));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_combo_box_class_init (GvcComboBoxClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = gvc_combo_box_finalize;
+        object_class->set_property = gvc_combo_box_set_property;
+        object_class->get_property = gvc_combo_box_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_LABEL,
+                                         g_param_spec_string ("label",
+                                                              "label",
+                                                              "The combo box label",
+                                                              _("_Profile:"),
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_SHOW_BUTTON,
+                                         g_param_spec_boolean ("show-button",
+                                                               "show-button",
+                                                               "Whether to show the button",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_BUTTON_LABEL,
+                                         g_param_spec_string ("button-label",
+                                                              "button-label",
+                                                              "The button's label",
+                                                              "APPLICATION BUG",
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        signals [CHANGED] =
+                g_signal_new ("changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcComboBoxClass, changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__STRING,
+                              G_TYPE_NONE, 1, G_TYPE_STRING);
+        signals [BUTTON_CLICKED] =
+                g_signal_new ("button-clicked",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcComboBoxClass, button_clicked),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__VOID,
+                              G_TYPE_NONE, 0, G_TYPE_NONE);
+
+        g_type_class_add_private (klass, sizeof (GvcComboBoxPrivate));
+}
+
+void
+gvc_combo_box_set_profiles (GvcComboBox *combo_box,
+                            const GHashTable* profiles)
+{
+        g_return_if_fail (GVC_IS_COMBO_BOX (combo_box));
+        g_return_if_fail (combo_box->priv->set_called == FALSE);
+
+        const GList *l;
+        const GList *keys;
+
+        keys = g_hash_table_get_keys (profiles);
+
+        for (l = keys; l != NULL; l = l->next) {
+                gchar* k;
+                GvcMixerCardProfile *p;
+                k = l->data;
+                
+                p = g_hash_table_lookup (profiles, k);
+                g_debug ("set profiles - key %s \n profile %s \n human profile %s",
+                         k,
+                         p->profile,
+                         p->human_profile);
+
+                gtk_list_store_insert_with_values (GTK_LIST_STORE (combo_box->priv->model),
+                                                   NULL,
+                                                   G_MAXINT,
+                                                   COL_NAME, p->profile,
+                                                   COL_HUMAN_NAME, p->human_profile,
+                                                   -1);
+        }
+        combo_box->priv->set_called = TRUE;
+}
+
+void
+gvc_combo_box_set_ports (GvcComboBox *combo_box,
+                         const GList       *ports)
+{
+        const GList *l;
+
+        g_return_if_fail (GVC_IS_COMBO_BOX (combo_box));
+        g_return_if_fail (combo_box->priv->set_called == FALSE);
+
+        for (l = ports; l != NULL; l = l->next) {
+                GvcMixerStreamPort *p = l->data;
+
+                gtk_list_store_insert_with_values (GTK_LIST_STORE (combo_box->priv->model),
+                                                   NULL,
+                                                   G_MAXINT,
+                                                   COL_NAME, p->port,
+                                                   COL_HUMAN_NAME, p->human_port,
+                                                   -1);
+        }
+        combo_box->priv->set_called = TRUE;
+}
+
+void
+gvc_combo_box_set_active (GvcComboBox *combo_box,
+                          const char  *id)
+{
+        GtkTreeIter iter;
+        gboolean cont;
+
+        cont = gtk_tree_model_get_iter_first (combo_box->priv->model, &iter);
+        while (cont != FALSE) {
+                char *name;
+
+                gtk_tree_model_get (combo_box->priv->model, &iter,
+                                    COL_NAME, &name,
+                                    -1);
+                if (g_strcmp0 (name, id) == 0) {
+                        gtk_combo_box_set_active_iter (GTK_COMBO_BOX (combo_box->priv->combobox), &iter);
+                        return;
+                }
+                cont = gtk_tree_model_iter_next (combo_box->priv->model, &iter);
+        }
+        g_warning ("Could not find id '%s' in combo box", id);
+}
+
+static void
+on_combo_box_changed (GtkComboBox *widget,
+                      GvcComboBox *combo_box)
+{
+        GtkTreeIter          iter;
+        char                *profile;
+
+        if (gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter) == FALSE) {
+                g_warning ("Could not find an active profile or port");
+                return;
+        }
+
+        gtk_tree_model_get (combo_box->priv->model, &iter,
+                            COL_NAME, &profile,
+                            -1);
+        g_signal_emit (combo_box, signals[CHANGED], 0, profile);
+        g_free (profile);
+}
+
+static void
+on_combo_box_button_clicked (GtkButton   *button,
+                             GvcComboBox *combo_box)
+{
+        g_signal_emit (combo_box, signals[BUTTON_CLICKED], 0);
+}
+
+static void
+gvc_combo_box_init (GvcComboBox *combo_box)
+{
+        GtkWidget *frame;
+        GtkWidget            *box;
+        GtkWidget            *sbox;
+        GtkWidget            *ebox;
+        GtkCellRenderer      *renderer;
+
+        combo_box->priv = GVC_COMBO_BOX_GET_PRIVATE (combo_box);
+
+        combo_box->priv->model = GTK_TREE_MODEL (gtk_list_store_new (NUM_COLS,
+                                                                     G_TYPE_STRING,
+                                                                     G_TYPE_STRING));
+
+        combo_box->priv->label = gtk_label_new (NULL);
+        gtk_misc_set_alignment (GTK_MISC (combo_box->priv->label),
+                                0.0,
+                                0.5);
+
+        /* frame */
+        frame = gtk_frame_new (NULL);
+        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
+        gtk_container_add (GTK_CONTAINER (combo_box), frame);
+
+        combo_box->priv->drop_box = box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+        combo_box->priv->combobox = gtk_combo_box_new_with_model (combo_box->priv->model);
+                
+        renderer = gtk_cell_renderer_text_new ();
+        gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo_box->priv->combobox),
+                                    renderer, TRUE);
+        gtk_cell_layout_add_attribute (GTK_CELL_LAYOUT (combo_box->priv->combobox),
+                                       renderer,
+                                       "text", COL_HUMAN_NAME);
+
+        /* Make sure that the combo box isn't too wide when human names are overly long,
+         * but that we can still read the full length of it */
+        g_object_set (G_OBJECT (renderer), "ellipsize", PANGO_ELLIPSIZE_END, NULL);
+        gtk_cell_renderer_set_fixed_size (renderer, 5, -1);        
+        g_object_set (G_OBJECT (combo_box->priv->combobox), "popup-fixed-width", FALSE, NULL);
+
+        combo_box->priv->start_box = sbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+        gtk_box_pack_start (GTK_BOX (box), sbox, FALSE, FALSE, 0);
+
+        gtk_box_pack_start (GTK_BOX (sbox), combo_box->priv->label, FALSE, FALSE, 0);
+
+        gtk_box_pack_start (GTK_BOX (box), combo_box->priv->combobox, TRUE, TRUE, 0);
+
+        combo_box->priv->button = gtk_button_new_with_label ("APPLICATION BUG");
+        gtk_button_set_use_underline (GTK_BUTTON (combo_box->priv->button), TRUE);
+        gtk_widget_set_no_show_all (combo_box->priv->button, TRUE);
+        gtk_box_pack_start (GTK_BOX (box), combo_box->priv->button, FALSE, FALSE, 0);
+
+        combo_box->priv->end_box = ebox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+        gtk_box_pack_start (GTK_BOX (box), ebox, FALSE, FALSE, 0);
+
+        if (combo_box->priv->size_group != NULL) {
+                gtk_size_group_add_widget (combo_box->priv->size_group, sbox);
+
+                if (combo_box->priv->symmetric) {
+                        gtk_size_group_add_widget (combo_box->priv->size_group, ebox);
+                }
+        }
+
+        gtk_container_add (GTK_CONTAINER (frame), combo_box->priv->drop_box);
+        gtk_widget_show_all (frame);
+
+        gtk_label_set_mnemonic_widget (GTK_LABEL (combo_box->priv->label),
+                                       combo_box->priv->combobox);
+
+        g_signal_connect (G_OBJECT (combo_box->priv->combobox), "changed",
+                          G_CALLBACK (on_combo_box_changed), combo_box);
+        g_signal_connect (G_OBJECT (combo_box->priv->button), "clicked",
+                          G_CALLBACK (on_combo_box_button_clicked), combo_box);
+}
+
+static void
+gvc_combo_box_finalize (GObject *object)
+{
+        GvcComboBox *combo_box;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_COMBO_BOX (object));
+
+        combo_box = GVC_COMBO_BOX (object);
+
+        g_return_if_fail (combo_box->priv != NULL);
+
+        g_object_unref (combo_box->priv->model);
+        combo_box->priv->model = NULL;
+
+        G_OBJECT_CLASS (gvc_combo_box_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_combo_box_new (const char *label)
+{
+        GObject *combo_box;
+        combo_box = g_object_new (GVC_TYPE_COMBO_BOX,
+                                  "label", label,
+                                  NULL);
+        return GTK_WIDGET (combo_box);
+}
+
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-combo-box.h gnome-control-center-3.6.0/panels/sound-nua/gvc-combo-box.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-combo-box.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-combo-box.h	2012-09-28 19:08:52.478641713 -0400
@@ -0,0 +1,66 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_COMBO_BOX_H
+#define __GVC_COMBO_BOX_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_COMBO_BOX         (gvc_combo_box_get_type ())
+#define GVC_COMBO_BOX(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_COMBO_BOX, GvcComboBox))
+#define GVC_COMBO_BOX_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_COMBO_BOX, GvcComboBoxClass))
+#define GVC_IS_COMBO_BOX(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_COMBO_BOX))
+#define GVC_IS_COMBO_BOX_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_COMBO_BOX))
+#define GVC_COMBO_BOX_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_COMBO_BOX, GvcComboBoxClass))
+
+typedef struct GvcComboBoxPrivate GvcComboBoxPrivate;
+
+typedef struct
+{
+        GtkHBox               parent;
+        GvcComboBoxPrivate *priv;
+} GvcComboBox;
+
+typedef struct
+{
+        GtkHBoxClass            parent_class;
+        void (* changed)        (GvcComboBox *combobox, const char *name);
+        void (* button_clicked) (GvcComboBox *combobox);
+} GvcComboBoxClass;
+
+GType                   gvc_combo_box_get_type            (void);
+
+GtkWidget *             gvc_combo_box_new                 (const char   *label);
+
+void                    gvc_combo_box_set_size_group      (GvcComboBox  *combo_box,
+                                                           GtkSizeGroup *group,
+                                                           gboolean      symmetric);
+
+void                    gvc_combo_box_set_profiles        (GvcComboBox  *combo_box,
+                                                          const GHashTable  *profiles);
+void                    gvc_combo_box_set_ports           (GvcComboBox  *combo_box,
+                                                            const GList  *ports);
+void                    gvc_combo_box_set_active          (GvcComboBox  *combo_box,
+                                                           const char   *id);
+G_END_DECLS
+
+#endif /* __GVC_COMBO_BOX_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-level-bar.c gnome-control-center-3.6.0/panels/sound-nua/gvc-level-bar.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-level-bar.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-level-bar.c	2012-09-28 19:08:52.479641711 -0400
@@ -0,0 +1,770 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann <william.jon.mccann@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <math.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include "gvc-level-bar.h"
+
+#define NUM_BOXES 30
+
+#define GVC_LEVEL_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_LEVEL_BAR, GvcLevelBarPrivate))
+
+#define MIN_HORIZONTAL_BAR_WIDTH   150
+#define HORIZONTAL_BAR_HEIGHT      6
+#define VERTICAL_BAR_WIDTH         6
+#define MIN_VERTICAL_BAR_HEIGHT    400
+
+typedef struct {
+        int          peak_num;
+        int          max_peak_num;
+
+        GdkRectangle area;
+        int          delta;
+        int          box_width;
+        int          box_height;
+        int          box_radius;
+        double       bg_r;
+        double       bg_g;
+        double       bg_b;
+        double       bdr_r;
+        double       bdr_g;
+        double       bdr_b;
+        double       fl_r;
+        double       fl_g;
+        double       fl_b;
+} LevelBarLayout;
+
+struct GvcLevelBarPrivate
+{
+        GtkOrientation orientation;
+        GtkAdjustment *peak_adjustment;
+        GtkAdjustment *rms_adjustment;
+        int            scale;
+        gdouble        peak_fraction;
+        gdouble        rms_fraction;
+        gdouble        max_peak;
+        guint          max_peak_id;
+        LevelBarLayout layout;
+};
+
+enum
+{
+        PROP_0,
+        PROP_PEAK_ADJUSTMENT,
+        PROP_RMS_ADJUSTMENT,
+        PROP_SCALE,
+        PROP_ORIENTATION,
+};
+
+static void     gvc_level_bar_class_init (GvcLevelBarClass *klass);
+static void     gvc_level_bar_init       (GvcLevelBar      *level_bar);
+static void     gvc_level_bar_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcLevelBar, gvc_level_bar, GTK_TYPE_WIDGET)
+
+#define check_rectangle(rectangle1, rectangle2)                          \
+        {                                                                \
+                /* .x and .y are always 0 */                             \
+                if (rectangle1.width  != rectangle2.width)  return TRUE; \
+                if (rectangle1.height != rectangle2.height) return TRUE; \
+        }
+
+static gboolean
+layout_changed (LevelBarLayout *layout1,
+                LevelBarLayout *layout2)
+{
+        check_rectangle (layout1->area, layout2->area);
+        if (layout1->delta != layout2->delta) return TRUE;
+        if (layout1->peak_num != layout2->peak_num) return TRUE;
+        if (layout1->max_peak_num != layout2->max_peak_num) return TRUE;
+        if (layout1->bg_r != layout2->bg_r
+            || layout1->bg_g != layout2->bg_g
+            || layout1->bg_b != layout2->bg_b)
+                return TRUE;
+        if (layout1->bdr_r != layout2->bdr_r
+            || layout1->bdr_g != layout2->bdr_g
+            || layout1->bdr_b != layout2->bdr_b)
+                return TRUE;
+        if (layout1->fl_r != layout2->fl_r
+            || layout1->fl_g != layout2->fl_g
+            || layout1->fl_b != layout2->fl_b)
+                return TRUE;
+
+        return FALSE;
+}
+
+static gdouble
+fraction_from_adjustment (GvcLevelBar   *bar,
+                          GtkAdjustment *adjustment)
+{
+        gdouble level;
+        gdouble fraction;
+        gdouble min;
+        gdouble max;
+
+        level = gtk_adjustment_get_value (adjustment);
+
+        min = gtk_adjustment_get_lower (adjustment);
+        max = gtk_adjustment_get_upper (adjustment);
+
+        switch (bar->priv->scale) {
+        case GVC_LEVEL_SCALE_LINEAR:
+                fraction = (level - min) / (max - min);
+                break;
+        case GVC_LEVEL_SCALE_LOG:
+                fraction = log10 ((level - min + 1) / (max - min + 1));
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        return fraction;
+}
+
+static gboolean
+reset_max_peak (GvcLevelBar *bar)
+{
+        gdouble min;
+
+        min = gtk_adjustment_get_lower (bar->priv->peak_adjustment);
+        bar->priv->max_peak = min;
+        bar->priv->layout.max_peak_num = 0;
+        gtk_widget_queue_draw (GTK_WIDGET (bar));
+        bar->priv->max_peak_id = 0;
+        return FALSE;
+}
+
+static void
+bar_calc_layout (GvcLevelBar *bar)
+{
+        GdkColor color;
+        int      peak_level;
+        int      max_peak_level;
+        GtkAllocation allocation;
+        GtkStyle *style;
+
+        gtk_widget_get_allocation (GTK_WIDGET (bar), &allocation);
+        bar->priv->layout.area.width = allocation.width - 2;
+        bar->priv->layout.area.height = allocation.height - 2;
+
+        style = gtk_widget_get_style (GTK_WIDGET (bar));
+        color = style->bg [GTK_STATE_NORMAL];
+        bar->priv->layout.bg_r = (float)color.red / 65535.0;
+        bar->priv->layout.bg_g = (float)color.green / 65535.0;
+        bar->priv->layout.bg_b = (float)color.blue / 65535.0;
+        color = style->dark [GTK_STATE_NORMAL];
+        bar->priv->layout.bdr_r = (float)color.red / 65535.0;
+        bar->priv->layout.bdr_g = (float)color.green / 65535.0;
+        bar->priv->layout.bdr_b = (float)color.blue / 65535.0;
+        color = style->bg [GTK_STATE_SELECTED];
+        bar->priv->layout.fl_r = (float)color.red / 65535.0;
+        bar->priv->layout.fl_g = (float)color.green / 65535.0;
+        bar->priv->layout.fl_b = (float)color.blue / 65535.0;
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                peak_level = bar->priv->peak_fraction * bar->priv->layout.area.height;
+                max_peak_level = bar->priv->max_peak * bar->priv->layout.area.height;
+
+                bar->priv->layout.delta = bar->priv->layout.area.height / NUM_BOXES;
+                bar->priv->layout.area.x = 0;
+                bar->priv->layout.area.y = 0;
+                bar->priv->layout.box_height = bar->priv->layout.delta / 2;
+                bar->priv->layout.box_width = bar->priv->layout.area.width;
+                bar->priv->layout.box_radius = bar->priv->layout.box_width / 2;
+        } else {
+                peak_level = bar->priv->peak_fraction * bar->priv->layout.area.width;
+                max_peak_level = bar->priv->max_peak * bar->priv->layout.area.width;
+
+                bar->priv->layout.delta = bar->priv->layout.area.width / NUM_BOXES;
+                bar->priv->layout.area.x = 0;
+                bar->priv->layout.area.y = 0;
+                bar->priv->layout.box_width = bar->priv->layout.delta / 2;
+                bar->priv->layout.box_height = bar->priv->layout.area.height;
+                bar->priv->layout.box_radius = bar->priv->layout.box_height / 2;
+        }
+
+        /* This can happen if the level bar isn't realized */
+        if (bar->priv->layout.delta == 0)
+                return;
+
+        bar->priv->layout.peak_num = peak_level / bar->priv->layout.delta;
+        bar->priv->layout.max_peak_num = max_peak_level / bar->priv->layout.delta;
+}
+
+static void
+update_peak_value (GvcLevelBar *bar)
+{
+        gdouble        val;
+        LevelBarLayout layout;
+
+        layout = bar->priv->layout;
+
+        val = fraction_from_adjustment (bar, bar->priv->peak_adjustment);
+        bar->priv->peak_fraction = val;
+
+        if (val > bar->priv->max_peak) {
+                if (bar->priv->max_peak_id > 0) {
+                        g_source_remove (bar->priv->max_peak_id);
+                }
+                bar->priv->max_peak_id = g_timeout_add_seconds (1, (GSourceFunc)reset_max_peak, bar);
+                bar->priv->max_peak = val;
+        }
+
+        bar_calc_layout (bar);
+
+        if (layout_changed (&bar->priv->layout, &layout)) {
+                gtk_widget_queue_draw (GTK_WIDGET (bar));
+        }
+}
+
+static void
+update_rms_value (GvcLevelBar *bar)
+{
+        gdouble val;
+
+        val = fraction_from_adjustment (bar, bar->priv->rms_adjustment);
+        bar->priv->rms_fraction = val;
+}
+
+GtkOrientation
+gvc_level_bar_get_orientation (GvcLevelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_LEVEL_BAR (bar), 0);
+        return bar->priv->orientation;
+}
+
+void
+gvc_level_bar_set_orientation (GvcLevelBar   *bar,
+                               GtkOrientation orientation)
+{
+        g_return_if_fail (GVC_IS_LEVEL_BAR (bar));
+
+        if (orientation != bar->priv->orientation) {
+                bar->priv->orientation = orientation;
+                gtk_widget_queue_draw (GTK_WIDGET (bar));
+                g_object_notify (G_OBJECT (bar), "orientation");
+        }
+}
+
+static void
+on_peak_adjustment_value_changed (GtkAdjustment *adjustment,
+                                  GvcLevelBar   *bar)
+{
+        update_peak_value (bar);
+}
+
+static void
+on_rms_adjustment_value_changed (GtkAdjustment *adjustment,
+                                 GvcLevelBar   *bar)
+{
+        update_rms_value (bar);
+}
+
+void
+gvc_level_bar_set_peak_adjustment (GvcLevelBar   *bar,
+                                   GtkAdjustment *adjustment)
+{
+        g_return_if_fail (GVC_LEVEL_BAR (bar));
+        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
+
+        if (bar->priv->peak_adjustment != NULL) {
+                g_signal_handlers_disconnect_by_func (bar->priv->peak_adjustment,
+                                                      G_CALLBACK (on_peak_adjustment_value_changed),
+                                                      bar);
+                g_object_unref (bar->priv->peak_adjustment);
+        }
+
+        bar->priv->peak_adjustment = g_object_ref_sink (adjustment);
+
+        g_signal_connect (bar->priv->peak_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_peak_adjustment_value_changed),
+                          bar);
+
+        update_peak_value (bar);
+
+        g_object_notify (G_OBJECT (bar), "peak-adjustment");
+}
+
+void
+gvc_level_bar_set_rms_adjustment (GvcLevelBar   *bar,
+                                  GtkAdjustment *adjustment)
+{
+        g_return_if_fail (GVC_LEVEL_BAR (bar));
+        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
+
+        if (bar->priv->rms_adjustment != NULL) {
+                g_signal_handlers_disconnect_by_func (bar->priv->peak_adjustment,
+                                                      G_CALLBACK (on_rms_adjustment_value_changed),
+                                                      bar);
+                g_object_unref (bar->priv->rms_adjustment);
+        }
+
+        bar->priv->rms_adjustment = g_object_ref_sink (adjustment);
+
+
+        g_signal_connect (bar->priv->peak_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_peak_adjustment_value_changed),
+                          bar);
+
+        update_rms_value (bar);
+
+        g_object_notify (G_OBJECT (bar), "rms-adjustment");
+}
+
+GtkAdjustment *
+gvc_level_bar_get_peak_adjustment (GvcLevelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_LEVEL_BAR (bar), NULL);
+
+        return bar->priv->peak_adjustment;
+}
+
+GtkAdjustment *
+gvc_level_bar_get_rms_adjustment (GvcLevelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_LEVEL_BAR (bar), NULL);
+
+        return bar->priv->rms_adjustment;
+}
+
+void
+gvc_level_bar_set_scale (GvcLevelBar  *bar,
+                         GvcLevelScale scale)
+{
+        g_return_if_fail (GVC_IS_LEVEL_BAR (bar));
+
+        if (scale != bar->priv->scale) {
+                bar->priv->scale = scale;
+
+                update_peak_value (bar);
+                update_rms_value (bar);
+
+                g_object_notify (G_OBJECT (bar), "scale");
+        }
+}
+
+static void
+gvc_level_bar_set_property (GObject       *object,
+                              guint          prop_id,
+                              const GValue  *value,
+                              GParamSpec    *pspec)
+{
+        GvcLevelBar *self = GVC_LEVEL_BAR (object);
+
+        switch (prop_id) {
+        case PROP_SCALE:
+                gvc_level_bar_set_scale (self, g_value_get_int (value));
+                break;
+        case PROP_ORIENTATION:
+                gvc_level_bar_set_orientation (self, g_value_get_enum (value));
+                break;
+        case PROP_PEAK_ADJUSTMENT:
+                gvc_level_bar_set_peak_adjustment (self, g_value_get_object (value));
+                break;
+        case PROP_RMS_ADJUSTMENT:
+                gvc_level_bar_set_rms_adjustment (self, g_value_get_object (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_level_bar_get_property (GObject     *object,
+                              guint        prop_id,
+                              GValue      *value,
+                              GParamSpec  *pspec)
+{
+        GvcLevelBar *self = GVC_LEVEL_BAR (object);
+
+        switch (prop_id) {
+        case PROP_SCALE:
+                g_value_set_int (value, self->priv->scale);
+                break;
+        case PROP_ORIENTATION:
+                g_value_set_enum (value, self->priv->orientation);
+                break;
+        case PROP_PEAK_ADJUSTMENT:
+                g_value_set_object (value, self->priv->peak_adjustment);
+                break;
+        case PROP_RMS_ADJUSTMENT:
+                g_value_set_object (value, self->priv->rms_adjustment);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_level_bar_constructor (GType                  type,
+                           guint                  n_construct_properties,
+                           GObjectConstructParam *construct_params)
+{
+        return G_OBJECT_CLASS (gvc_level_bar_parent_class)->constructor (type, n_construct_properties, construct_params);
+}
+
+static void
+gvc_level_bar_size_request (GtkWidget      *widget,
+                            GtkRequisition *requisition)
+{
+        GvcLevelBar *bar = GVC_LEVEL_BAR (widget);
+
+        switch (bar->priv->orientation) {
+        case GTK_ORIENTATION_VERTICAL:
+                requisition->width = VERTICAL_BAR_WIDTH;
+                requisition->height = MIN_VERTICAL_BAR_HEIGHT;
+                break;
+        case GTK_ORIENTATION_HORIZONTAL:
+                requisition->width = MIN_HORIZONTAL_BAR_WIDTH;
+                requisition->height = HORIZONTAL_BAR_HEIGHT;
+                break;
+        default:
+                g_assert_not_reached ();
+                break;
+        }
+}
+
+static void
+gvc_level_bar_get_preferred_width (GtkWidget *widget,
+                                   gint      *minimum,
+                                   gint      *natural)
+{
+        GtkRequisition requisition;
+
+        gvc_level_bar_size_request (widget, &requisition);
+
+        if (minimum != NULL) {
+                *minimum = requisition.width;
+        }
+        if (natural != NULL) {
+                *natural = requisition.width;
+        }
+}
+
+static void
+gvc_level_bar_get_preferred_height (GtkWidget *widget,
+                                    gint      *minimum,
+                                    gint      *natural)
+{
+        GtkRequisition requisition;
+
+        gvc_level_bar_size_request (widget, &requisition);
+
+        if (minimum != NULL) {
+                *minimum = requisition.height;
+        }
+        if (natural != NULL) {
+                *natural = requisition.height;
+        }
+}
+
+static void
+gvc_level_bar_size_allocate (GtkWidget     *widget,
+                             GtkAllocation *allocation)
+{
+        GvcLevelBar *bar;
+
+        g_return_if_fail (GVC_IS_LEVEL_BAR (widget));
+        g_return_if_fail (allocation != NULL);
+
+        bar = GVC_LEVEL_BAR (widget);
+
+        /* FIXME: add height property, labels, etc */
+        GTK_WIDGET_CLASS (gvc_level_bar_parent_class)->size_allocate (widget, allocation);
+
+        gtk_widget_set_allocation (widget, allocation);
+        gtk_widget_get_allocation (widget, allocation);
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                allocation->height = MIN (allocation->height, MIN_VERTICAL_BAR_HEIGHT);
+                allocation->width = MAX (allocation->width, VERTICAL_BAR_WIDTH);
+        } else {
+                allocation->width = MIN (allocation->width, MIN_HORIZONTAL_BAR_WIDTH);
+                allocation->height = MAX (allocation->height, HORIZONTAL_BAR_HEIGHT);
+        }
+
+        bar_calc_layout (bar);
+}
+
+static void
+curved_rectangle (cairo_t *cr,
+                  double   x0,
+                  double   y0,
+                  double   width,
+                  double   height,
+                  double   radius)
+{
+        double x1;
+        double y1;
+
+        x1 = x0 + width;
+        y1 = y0 + height;
+
+        if (!width || !height) {
+                return;
+        }
+
+        if (width / 2 < radius) {
+                if (height / 2 < radius) {
+                        cairo_move_to  (cr, x0, (y0 + y1) / 2);
+                        cairo_curve_to (cr, x0 ,y0, x0, y0, (x0 + x1) / 2, y0);
+                        cairo_curve_to (cr, x1, y0, x1, y0, x1, (y0 + y1) / 2);
+                        cairo_curve_to (cr, x1, y1, x1, y1, (x1 + x0) / 2, y1);
+                        cairo_curve_to (cr, x0, y1, x0, y1, x0, (y0 + y1) / 2);
+                } else {
+                        cairo_move_to  (cr, x0, y0 + radius);
+                        cairo_curve_to (cr, x0, y0, x0, y0, (x0 + x1) / 2, y0);
+                        cairo_curve_to (cr, x1, y0, x1, y0, x1, y0 + radius);
+                        cairo_line_to (cr, x1, y1 - radius);
+                        cairo_curve_to (cr, x1, y1, x1, y1, (x1 + x0) / 2, y1);
+                        cairo_curve_to (cr, x0, y1, x0, y1, x0, y1 - radius);
+                }
+        } else {
+                if (height / 2 < radius) {
+                        cairo_move_to  (cr, x0, (y0 + y1) / 2);
+                        cairo_curve_to (cr, x0, y0, x0 , y0, x0 + radius, y0);
+                        cairo_line_to (cr, x1 - radius, y0);
+                        cairo_curve_to (cr, x1, y0, x1, y0, x1, (y0 + y1) / 2);
+                        cairo_curve_to (cr, x1, y1, x1, y1, x1 - radius, y1);
+                        cairo_line_to (cr, x0 + radius, y1);
+                        cairo_curve_to (cr, x0, y1, x0, y1, x0, (y0 + y1) / 2);
+                } else {
+                        cairo_move_to  (cr, x0, y0 + radius);
+                        cairo_curve_to (cr, x0 , y0, x0 , y0, x0 + radius, y0);
+                        cairo_line_to (cr, x1 - radius, y0);
+                        cairo_curve_to (cr, x1, y0, x1, y0, x1, y0 + radius);
+                        cairo_line_to (cr, x1, y1 - radius);
+                        cairo_curve_to (cr, x1, y1, x1, y1, x1 - radius, y1);
+                        cairo_line_to (cr, x0 + radius, y1);
+                        cairo_curve_to (cr, x0, y1, x0, y1, x0, y1 - radius);
+                }
+        }
+
+        cairo_close_path (cr);
+}
+
+static int
+gvc_level_bar_draw (GtkWidget *widget,
+                    cairo_t   *cr)
+{
+        GvcLevelBar     *bar;
+
+        g_return_val_if_fail (GVC_IS_LEVEL_BAR (widget), FALSE);
+
+        bar = GVC_LEVEL_BAR (widget);
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                int i;
+                int by;
+
+                for (i = 0; i < NUM_BOXES; i++) {
+                        by = i * bar->priv->layout.delta;
+                        curved_rectangle (cr,
+                                          bar->priv->layout.area.x + 0.5,
+                                          by + 0.5,
+                                          bar->priv->layout.box_width - 1,
+                                          bar->priv->layout.box_height - 1,
+                                          bar->priv->layout.box_radius);
+                        if ((bar->priv->layout.max_peak_num - 1) == i) {
+                                /* fill peak foreground */
+                                cairo_set_source_rgb (cr, bar->priv->layout.fl_r, bar->priv->layout.fl_g, bar->priv->layout.fl_b);
+                                cairo_fill_preserve (cr);
+                        } else if ((bar->priv->layout.peak_num - 1) >= i) {
+                                /* fill background */
+                                cairo_set_source_rgb (cr, bar->priv->layout.bg_r, bar->priv->layout.bg_g, bar->priv->layout.bg_b);
+                                cairo_fill_preserve (cr);
+                                /* fill foreground */
+                                cairo_set_source_rgba (cr, bar->priv->layout.fl_r, bar->priv->layout.fl_g, bar->priv->layout.fl_b, 0.5);
+                                cairo_fill_preserve (cr);
+                        } else {
+                                /* fill background */
+                                cairo_set_source_rgb (cr, bar->priv->layout.bg_r, bar->priv->layout.bg_g, bar->priv->layout.bg_b);
+                                cairo_fill_preserve (cr);
+                        }
+
+                        /* stroke border */
+                        cairo_set_source_rgb (cr, bar->priv->layout.bdr_r, bar->priv->layout.bdr_g, bar->priv->layout.bdr_b);
+                        cairo_set_line_width (cr, 1);
+                        cairo_stroke (cr);
+                }
+
+        } else {
+                int i;
+                int bx;
+
+                for (i = 0; i < NUM_BOXES; i++) {
+                        bx = i * bar->priv->layout.delta;
+                        curved_rectangle (cr,
+                                          bx + 0.5,
+                                          bar->priv->layout.area.y + 0.5,
+                                          bar->priv->layout.box_width - 1,
+                                          bar->priv->layout.box_height - 1,
+                                          bar->priv->layout.box_radius);
+
+                        if ((bar->priv->layout.max_peak_num - 1) == i) {
+                                /* fill peak foreground */
+                                cairo_set_source_rgb (cr, bar->priv->layout.fl_r, bar->priv->layout.fl_g, bar->priv->layout.fl_b);
+                                cairo_fill_preserve (cr);
+                        } else if ((bar->priv->layout.peak_num - 1) >= i) {
+                                /* fill background */
+                                cairo_set_source_rgb (cr, bar->priv->layout.bg_r, bar->priv->layout.bg_g, bar->priv->layout.bg_b);
+                                cairo_fill_preserve (cr);
+                                /* fill foreground */
+                                cairo_set_source_rgba (cr, bar->priv->layout.fl_r, bar->priv->layout.fl_g, bar->priv->layout.fl_b, 0.5);
+                                cairo_fill_preserve (cr);
+                        } else {
+                                /* fill background */
+                                cairo_set_source_rgb (cr, bar->priv->layout.bg_r, bar->priv->layout.bg_g, bar->priv->layout.bg_b);
+                                cairo_fill_preserve (cr);
+                        }
+
+                        /* stroke border */
+                        cairo_set_source_rgb (cr, bar->priv->layout.bdr_r, bar->priv->layout.bdr_g, bar->priv->layout.bdr_b);
+                        cairo_set_line_width (cr, 1);
+                        cairo_stroke (cr);
+                }
+        }
+
+        return FALSE;
+}
+
+static void
+gvc_level_bar_class_init (GvcLevelBarClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+        GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
+
+        object_class->constructor = gvc_level_bar_constructor;
+        object_class->finalize = gvc_level_bar_finalize;
+        object_class->set_property = gvc_level_bar_set_property;
+        object_class->get_property = gvc_level_bar_get_property;
+
+        widget_class->draw = gvc_level_bar_draw;
+        widget_class->get_preferred_width = gvc_level_bar_get_preferred_width;
+        widget_class->get_preferred_height = gvc_level_bar_get_preferred_height;
+        widget_class->size_allocate = gvc_level_bar_size_allocate;
+
+        g_object_class_install_property (object_class,
+                                         PROP_ORIENTATION,
+                                         g_param_spec_enum ("orientation",
+                                                            "Orientation",
+                                                            "The orientation of the bar",
+                                                            GTK_TYPE_ORIENTATION,
+                                                            GTK_ORIENTATION_HORIZONTAL,
+                                                            G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_PEAK_ADJUSTMENT,
+                                         g_param_spec_object ("peak-adjustment",
+                                                              "Peak Adjustment",
+                                                              "The GtkAdjustment that contains the current peak value",
+                                                              GTK_TYPE_ADJUSTMENT,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_RMS_ADJUSTMENT,
+                                         g_param_spec_object ("rms-adjustment",
+                                                              "RMS Adjustment",
+                                                              "The GtkAdjustment that contains the current rms value",
+                                                              GTK_TYPE_ADJUSTMENT,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_SCALE,
+                                         g_param_spec_int ("scale",
+                                                           "Scale",
+                                                           "Scale",
+                                                           0,
+                                                           G_MAXINT,
+                                                           GVC_LEVEL_SCALE_LINEAR,
+                                                           G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_type_class_add_private (klass, sizeof (GvcLevelBarPrivate));
+}
+
+static void
+gvc_level_bar_init (GvcLevelBar *bar)
+{
+        bar->priv = GVC_LEVEL_BAR_GET_PRIVATE (bar);
+
+        bar->priv->peak_adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                         0.0,
+                                                                         1.0,
+                                                                         0.05,
+                                                                         0.1,
+                                                                         0.1));
+        g_object_ref_sink (bar->priv->peak_adjustment);
+        g_signal_connect (bar->priv->peak_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_peak_adjustment_value_changed),
+                          bar);
+
+        bar->priv->rms_adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                        0.0,
+                                                                        1.0,
+                                                                        0.05,
+                                                                        0.1,
+                                                                        0.1));
+        g_object_ref_sink (bar->priv->rms_adjustment);
+        g_signal_connect (bar->priv->rms_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_rms_adjustment_value_changed),
+                          bar);
+
+        gtk_widget_set_has_window (GTK_WIDGET (bar), FALSE);
+}
+
+static void
+gvc_level_bar_finalize (GObject *object)
+{
+        GvcLevelBar *bar;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_LEVEL_BAR (object));
+
+        bar = GVC_LEVEL_BAR (object);
+
+        if (bar->priv->max_peak_id > 0) {
+                g_source_remove (bar->priv->max_peak_id);
+        }
+
+        g_return_if_fail (bar->priv != NULL);
+
+        G_OBJECT_CLASS (gvc_level_bar_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_level_bar_new (void)
+{
+        GObject *bar;
+        bar = g_object_new (GVC_TYPE_LEVEL_BAR,
+                            NULL);
+        return GTK_WIDGET (bar);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-level-bar.h gnome-control-center-3.6.0/panels/sound-nua/gvc-level-bar.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-level-bar.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-level-bar.h	2012-09-28 19:08:52.480641709 -0400
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann <william.jon.mccann@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_LEVEL_BAR_H
+#define __GVC_LEVEL_BAR_H
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_LEVEL_BAR         (gvc_level_bar_get_type ())
+#define GVC_LEVEL_BAR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_LEVEL_BAR, GvcLevelBar))
+#define GVC_LEVEL_BAR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_LEVEL_BAR, GvcLevelBarClass))
+#define GVC_IS_LEVEL_BAR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_LEVEL_BAR))
+#define GVC_IS_LEVEL_BAR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_LEVEL_BAR))
+#define GVC_LEVEL_BAR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_LEVEL_BAR, GvcLevelBarClass))
+
+typedef struct GvcLevelBarPrivate GvcLevelBarPrivate;
+
+typedef struct
+{
+        GtkWidget           parent;
+        GvcLevelBarPrivate *priv;
+} GvcLevelBar;
+
+typedef struct
+{
+        GtkWidgetClass      parent_class;
+} GvcLevelBarClass;
+
+typedef enum
+{
+    GVC_LEVEL_SCALE_LINEAR,
+    GVC_LEVEL_SCALE_LOG,
+    GVC_LEVEL_SCALE_LAST
+} GvcLevelScale;
+
+GType               gvc_level_bar_get_type            (void);
+
+GtkWidget *         gvc_level_bar_new                 (void);
+void                gvc_level_bar_set_orientation     (GvcLevelBar   *bar,
+                                                       GtkOrientation orientation);
+GtkOrientation      gvc_level_bar_get_orientation     (GvcLevelBar   *bar);
+
+void                gvc_level_bar_set_peak_adjustment (GvcLevelBar   *bar,
+                                                       GtkAdjustment *adjustment);
+GtkAdjustment *     gvc_level_bar_get_peak_adjustment (GvcLevelBar   *bar);
+void                gvc_level_bar_set_rms_adjustment  (GvcLevelBar   *bar,
+                                                       GtkAdjustment *adjustment);
+GtkAdjustment *     gvc_level_bar_get_rms_adjustment  (GvcLevelBar   *bar);
+void                gvc_level_bar_set_scale           (GvcLevelBar   *bar,
+                                                       GvcLevelScale  scale);
+
+
+G_END_DECLS
+
+#endif /* __GVC_LEVEL_BAR_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-log.c gnome-control-center-3.6.0/panels/sound-nua/gvc-log.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-log.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-log.c	2012-09-28 19:08:52.480641709 -0400
@@ -0,0 +1,64 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#include "config.h"
+
+#include <glib.h>
+#include <glib/gstdio.h>
+
+#include "gvc-log.h"
+
+
+static int log_levels = G_LOG_LEVEL_CRITICAL |
+                        G_LOG_LEVEL_ERROR    |
+                        G_LOG_LEVEL_WARNING  |
+                        G_LOG_LEVEL_MESSAGE  |
+                        G_LOG_LEVEL_INFO     |
+                        G_LOG_LEVEL_DEBUG;
+
+static void
+gvc_log_default_handler (const gchar    *log_domain,
+                         GLogLevelFlags  log_level,
+                         const gchar    *message,
+                         gpointer        unused_data)
+{
+        if ((log_level & log_levels) == 0)
+                return;
+
+        g_log_default_handler (log_domain, log_level, message, unused_data);
+}
+
+void
+gvc_log_init (void)
+{
+        g_log_set_default_handler (gvc_log_default_handler, NULL);
+}
+
+void
+gvc_log_set_debug (gboolean debug)
+{
+        if (debug) {
+                log_levels |= (G_LOG_LEVEL_DEBUG | G_LOG_LEVEL_INFO);
+                g_debug ("Enabling debugging");
+        } else {
+                log_levels &= ~ (G_LOG_LEVEL_DEBUG | G_LOG_LEVEL_INFO);
+        }
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-log.h gnome-control-center-3.6.0/panels/sound-nua/gvc-log.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-log.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-log.h	2012-09-28 19:08:52.481641708 -0400
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_LOG_H
+#define __GVC_LOG_H
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+
+void gvc_log_init      (void);
+void gvc_log_set_debug (gboolean debug);
+
+
+G_END_DECLS
+
+#endif /* __GVC_LOG_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-card.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-card.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-card.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-card.c	2012-09-28 19:08:52.481641708 -0400
@@ -0,0 +1,550 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ * Copyright (C) 2009 Bastien Nocera
+ * Copyright (C) Conor Curran 2011 <conor.curran@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-card.h"
+#include "gvc-mixer-card-private.h"
+
+#define GVC_MIXER_CARD_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_CARD, GvcMixerCardPrivate))
+
+static guint32 card_serial = 1;
+
+struct GvcMixerCardPrivate
+{
+        pa_context    *pa_context;
+        guint          id;
+        guint          index;
+        char          *name;
+        char          *icon_name;
+        char          *profile;
+        char          *target_profile;
+        char          *human_profile;
+        GList         *profiles;
+        pa_operation  *profile_op;
+        GList	      *ports;        
+};
+
+enum
+{
+        PROP_0,
+        PROP_ID,
+        PROP_PA_CONTEXT,
+        PROP_INDEX,
+        PROP_NAME,
+        PROP_ICON_NAME,
+        PROP_PROFILE,
+        PROP_HUMAN_PROFILE,
+};
+
+static void     gvc_mixer_card_class_init (GvcMixerCardClass *klass);
+static void     gvc_mixer_card_init       (GvcMixerCard      *mixer_card);
+static void     gvc_mixer_card_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcMixerCard, gvc_mixer_card, G_TYPE_OBJECT)
+
+static guint32
+get_next_card_serial (void)
+{
+        guint32 serial;
+
+        serial = card_serial++;
+
+        if ((gint32)card_serial < 0) {
+                card_serial = 1;
+        }
+
+        return serial;
+}
+
+pa_context *
+gvc_mixer_card_get_pa_context (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), 0);
+        return card->priv->pa_context;
+}
+
+guint
+gvc_mixer_card_get_index (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), 0);
+        return card->priv->index;
+}
+
+guint
+gvc_mixer_card_get_id (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), 0);
+        return card->priv->id;
+}
+
+const char *
+gvc_mixer_card_get_name (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        return card->priv->name;
+}
+
+gboolean
+gvc_mixer_card_set_name (GvcMixerCard *card,
+                         const char     *name)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+
+        g_free (card->priv->name);
+        card->priv->name = g_strdup (name);
+        g_object_notify (G_OBJECT (card), "name");
+
+        return TRUE;
+}
+
+const char *
+gvc_mixer_card_get_icon_name (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        return card->priv->icon_name;
+}
+
+gboolean
+gvc_mixer_card_set_icon_name (GvcMixerCard *card,
+                              const char     *icon_name)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+
+        g_free (card->priv->icon_name);
+        card->priv->icon_name = g_strdup (icon_name);
+        g_object_notify (G_OBJECT (card), "icon-name");
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_card_get_profile: (skip)
+ *
+ * @card:
+ *
+ * Returns:
+ */
+GvcMixerCardProfile *
+gvc_mixer_card_get_profile (GvcMixerCard *card)
+{
+        GList *l;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        g_return_val_if_fail (card->priv->profiles != NULL, NULL);
+
+        for (l = card->priv->profiles; l != NULL; l = l->next) {
+                GvcMixerCardProfile *p = l->data;
+                if (g_str_equal (card->priv->profile, p->profile)) {
+                        return p;
+                }
+        }
+
+        g_assert_not_reached ();
+
+        return NULL;
+}
+
+gboolean
+gvc_mixer_card_set_profile (GvcMixerCard *card,
+                            const char     *profile)
+{
+        GList *l;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+        g_return_val_if_fail (card->priv->profiles != NULL, FALSE);
+
+        g_free (card->priv->profile);
+        card->priv->profile = g_strdup (profile);
+
+        g_free (card->priv->human_profile);
+        card->priv->human_profile = NULL;
+
+        for (l = card->priv->profiles; l != NULL; l = l->next) {
+                GvcMixerCardProfile *p = l->data;
+                if (g_str_equal (card->priv->profile, p->profile)) {
+                        card->priv->human_profile = g_strdup (p->human_profile);
+                        break;
+                }
+        }
+
+        g_object_notify (G_OBJECT (card), "profile");
+
+        return TRUE;
+}
+
+static void
+_pa_context_set_card_profile_by_index_cb (pa_context                       *context,
+                                          int                               success,
+                                          void                             *userdata)
+{
+        GvcMixerCard *card = GVC_MIXER_CARD (userdata);
+
+        g_assert (card->priv->target_profile);
+
+        if (success > 0) {
+                gvc_mixer_card_set_profile (card, card->priv->target_profile);
+        } else {
+                g_debug ("Failed to switch profile on '%s' from '%s' to '%s'",
+                         card->priv->name,
+                         card->priv->profile,
+                         card->priv->target_profile);
+        }
+        g_free (card->priv->target_profile);
+        card->priv->target_profile = NULL;
+
+        pa_operation_unref (card->priv->profile_op);
+        card->priv->profile_op = NULL;
+}
+
+gboolean
+gvc_mixer_card_change_profile (GvcMixerCard *card,
+                               const char *profile)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+        g_return_val_if_fail (card->priv->profiles != NULL, FALSE);
+
+        /* Same profile, or already requested? */
+        if (g_strcmp0 (card->priv->profile, profile) == 0)
+                return TRUE;
+        if (g_strcmp0 (profile, card->priv->target_profile) == 0)
+                return TRUE;
+        if (card->priv->profile_op != NULL) {
+                pa_operation_cancel (card->priv->profile_op);
+                pa_operation_unref (card->priv->profile_op);
+                card->priv->profile_op = NULL;
+        }
+
+        if (card->priv->profile != NULL) {
+                g_free (card->priv->target_profile);
+                card->priv->target_profile = g_strdup (profile);
+
+                card->priv->profile_op = pa_context_set_card_profile_by_index (card->priv->pa_context,
+                                                                               card->priv->index,
+                                                                               card->priv->target_profile,
+                                                                               _pa_context_set_card_profile_by_index_cb,
+                                                                               card);
+
+                if (card->priv->profile_op == NULL) {
+                        g_warning ("pa_context_set_card_profile_by_index() failed");
+                        return FALSE;
+                }
+        } else {
+                g_assert (card->priv->human_profile == NULL);
+                card->priv->profile = g_strdup (profile);
+        }
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_card_get_profiles:
+ *
+ * Return value: (transfer none) (element-type GvcMixerCardProfile):
+ */
+const GList *
+gvc_mixer_card_get_profiles (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        return card->priv->profiles;
+}
+
+
+/**
+ * gvc_mixer_card_get_ports:
+ *
+ * Return value: (transfer none) (element-type GvcMixerCardPort):
+ */
+const GList *
+gvc_mixer_card_get_ports (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        return card->priv->ports;
+}
+
+/**
+ * gvc_mixer_card_set_profiles:
+ * @profiles: (transfer full) (element-type GvcMixerCardProfile):
+ */
+gboolean
+gvc_mixer_card_set_profiles (GvcMixerCard *card,
+                             GList        *profiles)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+        g_return_val_if_fail (card->priv->profiles == NULL, FALSE);
+
+        card->priv->profiles = g_list_sort (profiles, (GCompareFunc) sort_profiles);
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_card_get_gicon:
+ *
+ * Return value: (transfer full) (element-type GIcon):
+ */
+GIcon *
+gvc_mixer_card_get_gicon (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        if (card->priv->icon_name == NULL)
+                return NULL;
+        return g_themed_icon_new_with_default_fallbacks (card->priv->icon_name);
+}
+
+/**
+ * gvc_mixer_card_set_ports:
+ * @profiles: (transfer full) (element-type GvcMixerCardPort):
+ */
+gboolean              
+gvc_mixer_card_set_ports (GvcMixerCard *card,
+                          GList          *ports)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+        g_return_val_if_fail (card->priv->ports == NULL, FALSE);
+
+        card->priv->ports = ports;
+
+        return TRUE;	
+}                                                     
+
+static void
+gvc_mixer_card_set_property (GObject       *object,
+                             guint          prop_id,
+                             const GValue  *value,
+                             GParamSpec    *pspec)
+{
+        GvcMixerCard *self = GVC_MIXER_CARD (object);
+
+        switch (prop_id) {
+        case PROP_PA_CONTEXT:
+                self->priv->pa_context = g_value_get_pointer (value);
+                break;
+        case PROP_INDEX:
+                self->priv->index = g_value_get_ulong (value);
+                break;
+        case PROP_ID:
+                self->priv->id = g_value_get_ulong (value);
+                break;
+        case PROP_NAME:
+                gvc_mixer_card_set_name (self, g_value_get_string (value));
+                break;
+        case PROP_ICON_NAME:
+                gvc_mixer_card_set_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_PROFILE:
+                gvc_mixer_card_set_profile (self, g_value_get_string (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_card_get_property (GObject     *object,
+                             guint        prop_id,
+                             GValue      *value,
+                             GParamSpec  *pspec)
+{
+        GvcMixerCard *self = GVC_MIXER_CARD (object);
+
+        switch (prop_id) {
+        case PROP_PA_CONTEXT:
+                g_value_set_pointer (value, self->priv->pa_context);
+                break;
+        case PROP_INDEX:
+                g_value_set_ulong (value, self->priv->index);
+                break;
+        case PROP_ID:
+                g_value_set_ulong (value, self->priv->id);
+                break;
+        case PROP_NAME:
+                g_value_set_string (value, self->priv->name);
+                break;
+        case PROP_ICON_NAME:
+                g_value_set_string (value, self->priv->icon_name);
+                break;
+        case PROP_PROFILE:
+                g_value_set_string (value, self->priv->profile);
+                break;
+        case PROP_HUMAN_PROFILE:
+                g_value_set_string (value, self->priv->human_profile);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_mixer_card_constructor (GType                  type,
+                            guint                  n_construct_properties,
+                            GObjectConstructParam *construct_params)
+{
+        GObject       *object;
+        GvcMixerCard *self;
+
+        object = G_OBJECT_CLASS (gvc_mixer_card_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_CARD (object);
+
+        self->priv->id = get_next_card_serial ();
+
+        return object;
+}
+
+static void
+gvc_mixer_card_class_init (GvcMixerCardClass *klass)
+{
+        GObjectClass   *gobject_class = G_OBJECT_CLASS (klass);
+
+        gobject_class->constructor = gvc_mixer_card_constructor;
+        gobject_class->finalize = gvc_mixer_card_finalize;
+
+        gobject_class->set_property = gvc_mixer_card_set_property;
+        gobject_class->get_property = gvc_mixer_card_get_property;
+
+        g_object_class_install_property (gobject_class,
+                                         PROP_INDEX,
+                                         g_param_spec_ulong ("index",
+                                                             "Index",
+                                                             "The index for this card",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_ID,
+                                         g_param_spec_ulong ("id",
+                                                             "id",
+                                                             "The id for this card",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_PA_CONTEXT,
+                                         g_param_spec_pointer ("pa-context",
+                                                               "PulseAudio context",
+                                                               "The PulseAudio context for this card",
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_NAME,
+                                         g_param_spec_string ("name",
+                                                              "Name",
+                                                              "Name to display for this card",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_ICON_NAME,
+                                         g_param_spec_string ("icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this card",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_PROFILE,
+                                         g_param_spec_string ("profile",
+                                                              "Profile",
+                                                              "Name of current profile for this card",
+                                                              NULL,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (gobject_class,
+                                         PROP_HUMAN_PROFILE,
+                                         g_param_spec_string ("human-profile",
+                                                              "Profile (Human readable)",
+                                                              "Name of current profile for this card in human readable form",
+                                                              NULL,
+                                                              G_PARAM_READABLE));
+
+        g_type_class_add_private (klass, sizeof (GvcMixerCardPrivate));
+}
+
+static void
+gvc_mixer_card_init (GvcMixerCard *card)
+{
+        card->priv = GVC_MIXER_CARD_GET_PRIVATE (card);
+}
+
+
+GvcMixerCard *
+gvc_mixer_card_new (pa_context *context,
+                    guint       index)
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_CARD,
+                               "index", index,
+                               "pa-context", context,
+                               NULL);
+        return GVC_MIXER_CARD (object);
+}
+
+static void
+free_profile (GvcMixerCardProfile *p)
+{
+        g_free (p->profile);
+        g_free (p->human_profile);
+        g_free (p->status);
+        g_free (p);
+}
+
+static void
+gvc_mixer_card_finalize (GObject *object)
+{
+        GvcMixerCard *mixer_card;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_CARD (object));
+
+        mixer_card = GVC_MIXER_CARD (object);
+
+        g_return_if_fail (mixer_card->priv != NULL);
+
+        g_free (mixer_card->priv->name);
+        mixer_card->priv->name = NULL;
+
+        g_free (mixer_card->priv->icon_name);
+        mixer_card->priv->icon_name = NULL;
+
+        g_free (mixer_card->priv->target_profile);
+        mixer_card->priv->target_profile = NULL;
+
+        g_free (mixer_card->priv->profile);
+        mixer_card->priv->profile = NULL;
+
+        g_free (mixer_card->priv->human_profile);
+        mixer_card->priv->human_profile = NULL;
+
+        g_list_foreach (mixer_card->priv->profiles, (GFunc) free_profile, NULL);
+        g_list_free (mixer_card->priv->profiles);
+        mixer_card->priv->profiles = NULL;
+
+        G_OBJECT_CLASS (gvc_mixer_card_parent_class)->finalize (object);
+}
+
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-card.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-card.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-card.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-card.h	2012-09-28 19:08:52.482641708 -0400
@@ -0,0 +1,109 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc.
+ * Copyright (C) Conor Curran 2011 <conor.curran@canonical.com>
+ 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_CARD_H
+#define __GVC_MIXER_CARD_H
+
+#include <glib-object.h>
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_CARD         (gvc_mixer_card_get_type ())
+#define GVC_MIXER_CARD(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_CARD, GvcMixerCard))
+#define GVC_MIXER_CARD_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_CARD, GvcMixerCardClass))
+#define GVC_IS_MIXER_CARD(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_CARD))
+#define GVC_IS_MIXER_CARD_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_CARD))
+#define GVC_MIXER_CARD_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_CARD, GvcMixerCardClass))
+
+typedef struct GvcMixerCardPrivate GvcMixerCardPrivate;
+
+typedef struct
+{
+        GObject                parent;
+        GvcMixerCardPrivate   *priv;
+} GvcMixerCard;
+
+typedef struct
+{
+        GObjectClass           parent_class;
+
+        /* vtable */
+} GvcMixerCardClass;
+
+typedef struct
+{
+        char *profile;
+        char *human_profile;
+        char *status;
+        guint priority;
+        guint n_sinks, n_sources;
+} GvcMixerCardProfile;
+
+typedef struct
+{
+        char *port;
+        char *human_port;
+        guint priority;
+        gint  available;
+        gint  direction;
+        GList *profiles;
+} GvcMixerCardPort;
+
+GType                 gvc_mixer_card_get_type          (void);
+
+guint                 gvc_mixer_card_get_id            (GvcMixerCard *card);
+guint                 gvc_mixer_card_get_index         (GvcMixerCard *card);
+const char *          gvc_mixer_card_get_name          (GvcMixerCard *card);
+const char *          gvc_mixer_card_get_icon_name     (GvcMixerCard *card);
+GvcMixerCardProfile * gvc_mixer_card_get_profile       (GvcMixerCard *card);
+const GList *         gvc_mixer_card_get_profiles      (GvcMixerCard *card);
+const GList *         gvc_mixer_card_get_ports         (GvcMixerCard *card);
+gboolean              gvc_mixer_card_change_profile    (GvcMixerCard *card,
+                                                        const char *profile);
+GIcon *		      gvc_mixer_card_get_gicon 	       (GvcMixerCard *card);
+
+/* private */
+gboolean              gvc_mixer_card_set_name          (GvcMixerCard *card,
+                                                        const char   *name);
+gboolean              gvc_mixer_card_set_icon_name     (GvcMixerCard *card,
+                                                        const char   *name);
+gboolean              gvc_mixer_card_set_profile       (GvcMixerCard *card,
+                                                        const char   *profile);
+gboolean              gvc_mixer_card_set_profiles      (GvcMixerCard *card,
+                                                        GList        *profiles);
+gboolean              gvc_mixer_card_set_ports         (GvcMixerCard *stream,
+                                                        GList        *ports);
+
+static int
+sort_profiles (GvcMixerCardProfile *a,
+               GvcMixerCardProfile *b)
+{
+        if (a->priority == b->priority)
+                return 0;
+        if (a->priority > b->priority)
+                return 1;
+        return -1;
+}
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_CARD_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-card-private.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-card-private.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-card-private.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-card-private.h	2012-09-28 19:08:52.482641708 -0400
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_CARD_PRIVATE_H
+#define __GVC_MIXER_CARD_PRIVATE_H
+
+#include <pulse/pulseaudio.h>
+#include "gvc-mixer-card.h"
+
+G_BEGIN_DECLS
+
+GvcMixerCard *        gvc_mixer_card_new               (pa_context   *context,
+                                                        guint         index);
+pa_context *          gvc_mixer_card_get_pa_context    (GvcMixerCard *card);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_CARD_PRIVATE_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-control.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-control.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-control.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-control.c	2012-09-28 19:08:52.486641705 -0400
@@ -0,0 +1,3374 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006-2008 Lennart Poettering
+ * Copyright (C) 2008 Sjoerd Simons <sjoerd@luon.net>
+ * Copyright (C) 2008 William Jon McCann
+ * Copyright (C) 2012 Conor Curran
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+#include <pulse/glib-mainloop.h>
+#include <pulse/ext-stream-restore.h>
+
+#include "gvc-mixer-control.h"
+#include "gvc-mixer-sink.h"
+#include "gvc-mixer-source.h"
+#include "gvc-mixer-sink-input.h"
+#include "gvc-mixer-source-output.h"
+#include "gvc-mixer-event-role.h"
+#include "gvc-mixer-card.h"
+#include "gvc-mixer-card-private.h"
+#include "gvc-channel-map-private.h"
+#include "gvc-mixer-control-private.h"
+
+#define GVC_MIXER_CONTROL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_CONTROL, GvcMixerControlPrivate))
+
+#define RECONNECT_DELAY 5
+
+enum {
+        PROP_0,
+        PROP_NAME
+};
+
+struct GvcMixerControlPrivate
+{
+        pa_glib_mainloop *pa_mainloop;
+        pa_mainloop_api  *pa_api;
+        pa_context       *pa_context;
+        int               n_outstanding;
+        guint             reconnect_id;
+        char             *name;
+
+        gboolean          default_sink_is_set;
+        guint             default_sink_id;
+        guint             active_output_id;
+        char             *default_sink_name;
+        gboolean          default_source_is_set;
+        guint             default_source_id;
+        char             *default_source_name;
+
+        gboolean          event_sink_input_is_set;
+        guint             event_sink_input_id;
+
+        GHashTable       *all_streams;
+        GHashTable       *sinks; /* fixed outputs */
+        GHashTable       *sources; /* fixed inputs */
+        GHashTable       *sink_inputs; /* routable output streams */
+        GHashTable       *source_outputs; /* routable input streams */
+        GHashTable       *clients;
+        GHashTable       *cards;
+        GHashTable       *ui_outputs; /* Ui visible outputs */
+        GHashTable       *ui_inputs; /* Ui visible inputs */      
+        GvcMixerStream   *new_default_stream; /* new default stream, used in gvc_mixer_control_set_default_sink/source () */
+        gboolean          new_default_is_source; /* true if currently setting the default source, false if setting the default sink */
+
+        /*
+        When we change profile on a device that is not the server default sink,
+        it will jump back to the default sink set by the server to prevent the audio setup from being 'outputless'.
+        All well and good but then when we get the new stream created for the new profile how do we know 
+        that this is the intended default or selected device the user wishes to use.
+        */        
+        guint            profile_swapping_device_id;
+        GvcMixerControlState state;
+};
+
+enum {
+        STATE_CHANGED,
+        STREAM_ADDED,
+        STREAM_REMOVED,
+        CARD_ADDED,
+        CARD_REMOVED,
+        DEFAULT_SINK_CHANGED,
+        DEFAULT_SOURCE_CHANGED,
+        OUTPUT_ADDED,
+        ACTIVE_OUTPUT_UPDATE,        
+        ACTIVE_INPUT_UPDATE,        
+        INPUT_ADDED,
+        OUTPUT_REMOVED,
+        INPUT_REMOVED,
+        LAST_SIGNAL
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+static void                     gvc_mixer_control_class_init (GvcMixerControlClass *klass);
+static void                     gvc_mixer_control_init       (GvcMixerControl      *mixer_control);
+static void                     gvc_mixer_control_finalize   (GObject              *object);
+
+G_DEFINE_TYPE (GvcMixerControl, gvc_mixer_control, G_TYPE_OBJECT)
+
+pa_context *
+gvc_mixer_control_get_pa_context (GvcMixerControl *control)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+        return control->priv->pa_context;
+}
+
+/**
+ * gvc_mixer_control_get_event_sink_input:
+ *
+ * @control:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerStream *
+gvc_mixer_control_get_event_sink_input (GvcMixerControl *control)
+{
+        GvcMixerStream *stream;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        stream = g_hash_table_lookup (control->priv->all_streams,
+                                      GUINT_TO_POINTER (control->priv->event_sink_input_id));
+
+        return stream;
+}
+
+static void
+gvc_mixer_control_stream_restore_cb (pa_context *c,
+                                     const pa_ext_stream_restore_info *info,
+                                     int eol,
+                                     void *userdata)
+{
+        pa_operation *o;
+        char *prefix;
+        GvcMixerControl *control = (GvcMixerControl *) userdata;
+        pa_ext_stream_restore_info new_info;
+
+        if (eol || control->priv->new_default_stream == NULL)
+                return;
+
+        /* Don't change inputs to outputs and vice versa */
+        prefix = control->priv->new_default_is_source ? "source-output-by" : "sink-input-by";
+        if (!g_str_has_prefix(info->name, prefix))
+                return;
+
+        new_info.name = info->name;
+        new_info.channel_map = info->channel_map;
+        new_info.volume = info->volume;
+        new_info.mute = info->mute;
+
+        new_info.device = gvc_mixer_stream_get_name (control->priv->new_default_stream);
+
+        o = pa_ext_stream_restore_write (control->priv->pa_context,
+                                         PA_UPDATE_REPLACE,
+                                         &new_info, 1,
+                                         TRUE, NULL, NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_write() failed: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+                return;
+        }
+
+        g_debug ("Changed default device for %s to %s", info->name, new_info.device);
+
+        pa_operation_unref (o);
+}
+
+/**
+ * gvc_mixer_control_lookup_device_from_stream:
+ * @control:
+ * @stream:
+ * Returns: GvcUIDevice (transfer none) or NULL:
+ */
+static GvcMixerUIDevice *
+gvc_mixer_control_lookup_device_from_stream (GvcMixerControl *control,
+                                             GvcMixerStream *stream)
+{
+	GList 		        *devices;
+	GList 		        *d;
+	GvcMixerUIDevice	*device;			
+
+        if (GVC_IS_MIXER_SOURCE (stream))
+               devices = g_hash_table_get_values (control->priv->ui_inputs);                
+        else{
+               devices = g_hash_table_get_values (control->priv->ui_outputs);
+        }
+
+        gboolean is_network_stream;
+        const GList *ports;
+        ports = gvc_mixer_stream_get_ports (stream);
+
+        // really this should be called 'is_network_or_bluetooth_stream'
+        is_network_stream = ports == NULL;
+
+	for (d = devices; d != NULL; d = d->next) {		
+		device = d->data;
+		gint stream_id = -2;
+
+		g_object_get (G_OBJECT (device),
+			     "stream-id", &stream_id,
+			      NULL);
+
+                if (is_network_stream) {
+                        if (stream_id == gvc_mixer_stream_get_id (stream)) {
+                                g_debug ("\n lookup device from stream - %s - it is a network_stream \n",
+                                        gvc_mixer_ui_device_get_description (device));
+                                return device;
+                        }       
+                }
+                else {
+                        const GvcMixerStreamPort *port;
+                        port = gvc_mixer_stream_get_port (stream);
+
+        		if (stream_id == gvc_mixer_stream_get_id (stream) &&
+                            g_strcmp0 (gvc_mixer_ui_device_get_port(device),
+                                       port->port) == 0) {
+                                g_debug ("\n \n lookup-device-from-stream found device  \n device description %s \n device port = %s \n device stream id %i \n AND \n stream port = %s stream id %u and stream description %s \n",
+                                         gvc_mixer_ui_device_get_description (device),
+                                         gvc_mixer_ui_device_get_port(device),                                 
+                                         stream_id,
+                                         port->port,
+                                         gvc_mixer_stream_get_id (stream),
+                                         gvc_mixer_stream_get_description (stream));
+        			return device;
+        		}
+                }
+	}
+	g_debug ("\n gvc_mixer_control_lookup_device_from_stream - Could not find a device ?  %s \n",gvc_mixer_stream_get_description (stream));		 
+	return NULL;
+}
+
+gboolean
+gvc_mixer_control_set_default_sink (GvcMixerControl *control,
+                                    GvcMixerStream  *stream)
+{
+        pa_operation *o;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_debug ("\n about to set default sink on server \n");
+        o = pa_context_set_default_sink (control->priv->pa_context,
+                                         gvc_mixer_stream_get_name (stream),
+                                         NULL,
+                                         NULL);
+        if (o == NULL) {
+                g_warning ("pa_context_set_default_sink() failed: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+                return FALSE;
+        }
+
+        pa_operation_unref (o);
+
+        control->priv->new_default_stream = stream;
+        control->priv->new_default_is_source = FALSE;
+        g_object_add_weak_pointer (G_OBJECT (stream), (gpointer *) &control->priv->new_default_stream);
+
+        o = pa_ext_stream_restore_read (control->priv->pa_context,
+                                        gvc_mixer_control_stream_restore_cb,
+                                        control);
+
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_read() failed: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+                return FALSE;
+        }
+
+        pa_operation_unref (o);
+        
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_control_set_default_source (GvcMixerControl *control,
+                                      GvcMixerStream  *stream)
+{
+        pa_operation *o;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        o = pa_context_set_default_source (control->priv->pa_context,
+                                           gvc_mixer_stream_get_name (stream),
+                                           NULL,
+                                           NULL);
+        if (o == NULL) {
+                g_warning ("pa_context_set_default_source() failed");
+                return FALSE;
+        }
+
+        pa_operation_unref (o);
+
+        control->priv->new_default_stream = stream;
+        control->priv->new_default_is_source = TRUE;
+        g_object_add_weak_pointer (G_OBJECT (stream), (gpointer *) &control->priv->new_default_stream);
+
+        o = pa_ext_stream_restore_read (control->priv->pa_context,
+                                        gvc_mixer_control_stream_restore_cb,
+                                        control);
+
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_read() failed: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+                return FALSE;
+        }
+
+        pa_operation_unref (o);
+
+        // source change successfull => update the UI.
+        GvcMixerUIDevice* input;
+        input = gvc_mixer_control_lookup_device_from_stream (control, stream);
+        g_signal_emit (G_OBJECT (control),
+                       signals[ACTIVE_INPUT_UPDATE],
+                       0,
+                       gvc_mixer_ui_device_get_id (input));             
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_control_get_default_sink:
+ *
+ * @control:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerStream *
+gvc_mixer_control_get_default_sink (GvcMixerControl *control)
+{
+        GvcMixerStream *stream;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        if (control->priv->default_sink_is_set) {
+                stream = g_hash_table_lookup (control->priv->all_streams,
+                                              GUINT_TO_POINTER (control->priv->default_sink_id));
+        } else {
+                stream = NULL;
+        }
+
+        return stream;
+}
+
+/**
+ * gvc_mixer_control_get_default_source:
+ *
+ * @control:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerStream *
+gvc_mixer_control_get_default_source (GvcMixerControl *control)
+{
+        GvcMixerStream *stream;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        if (control->priv->default_source_is_set) {
+                stream = g_hash_table_lookup (control->priv->all_streams,
+                                              GUINT_TO_POINTER (control->priv->default_source_id));
+        } else {
+                stream = NULL;
+        }
+
+        return stream;
+}
+
+static gpointer
+gvc_mixer_control_lookup_id (GHashTable *hash_table,
+                             guint       id)
+{
+        return g_hash_table_lookup (hash_table,
+                                    GUINT_TO_POINTER (id));
+}
+
+/**
+ * gvc_mixer_control_lookup_stream_id:
+ *
+ * @control:
+ * @id:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerStream *
+gvc_mixer_control_lookup_stream_id (GvcMixerControl *control,
+                                    guint            id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        return gvc_mixer_control_lookup_id (control->priv->all_streams, id);
+}
+
+/**
+ * gvc_mixer_control_lookup_card_id:
+ *
+ * @control:
+ * @id:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerCard *
+gvc_mixer_control_lookup_card_id (GvcMixerControl *control,
+                                  guint            id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+        return gvc_mixer_control_lookup_id (control->priv->cards, id);
+}
+
+/**
+ * gvc_mixer_control_lookup_output_id:
+ * @control:
+ * @id:
+ * Returns: (transfer none):
+ */
+GvcMixerUIDevice*	
+gvc_mixer_control_lookup_output_id (GvcMixerControl *control,
+				    guint            id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        return gvc_mixer_control_lookup_id (control->priv->ui_outputs, id);	
+}
+
+/**
+ * gvc_mixer_control_lookup_input_id:
+ * @control:
+ * @id:
+ * Returns: (transfer none):
+ */
+GvcMixerUIDevice*       
+gvc_mixer_control_lookup_input_id (GvcMixerControl *control,
+                                    guint            id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        return gvc_mixer_control_lookup_id (control->priv->ui_inputs, id);     
+}
+
+/**
+ * gvc_mixer_control_get_active_profile_from_ui_device:
+ * @control: GvcMixerControl*
+ * @device: GvcMixerUIDevice*
+ * Returns: (transfer container) (element-type gchar*):
+   The profile full name stored in that device
+   TODO: This belongs within the GvcMixerUIDevice.
+ */
+const gchar*
+gvc_mixer_control_get_active_profile_from_ui_device (GvcMixerControl* control,
+                                                     GvcMixerUIDevice* device)
+{
+        guint card_id;
+        g_object_get (G_OBJECT (device), "card-id", &card_id, NULL);
+        if (card_id == GVC_MIXER_UI_DEVICE_INVALID){
+                g_warning ("device did not have an appropriate card id");
+                return NULL;
+        }
+        GvcMixerCard *card;
+        card = gvc_mixer_control_lookup_card_id (control, card_id);
+        GvcMixerCardProfile *profile;
+        profile = gvc_mixer_card_get_profile (card);
+        return gvc_mixer_ui_device_get_matching_profile(device, profile->profile);
+}
+
+/**
+ * gvc_mixer_control_get_stream_from_device:
+ * @control:
+ * @dev
+ * Returns: (transfer container) (element-type Gvc.MixerStream):
+ */
+GvcMixerStream*
+gvc_mixer_control_get_stream_from_device (GvcMixerControl *control,
+                                          GvcMixerUIDevice *dev)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+        g_return_val_if_fail (GVC_IS_MIXER_UI_DEVICE (dev), NULL);
+        
+        gint stream_id = gvc_mixer_ui_device_get_stream_id (dev);
+        
+        if (stream_id == GVC_MIXER_UI_DEVICE_INVALID) {
+                g_debug ("gvc_mixer_control_get_stream_from_device - device has a null stream");
+                return NULL;
+        }       
+        return gvc_mixer_control_lookup_stream_id (control, stream_id);
+}                                                             
+/**
+ * gvc_mixer_control_change_profile_on_selected_device:
+ * @control:
+ * @device:
+ * @param profile Can be null if any profile present on this port is okay
+ * Returns: (transfer container) (element-type gboolean):
+   This method will attempt to swap the profile on the card of the device with given profile name
+   If successfull it will set the preferred profile on that device so as we know the next time the user
+   moves to that device it should have this profile active. 
+ */
+gboolean
+gvc_mixer_control_change_profile_on_selected_device (GvcMixerControl *control,
+                                                     GvcMixerUIDevice *device,
+                                                     const gchar* profile)                                                    
+{
+        guint card_id;
+        const gchar *best_profile;
+        GvcMixerCardProfile *current_profile;
+        g_object_get ( G_OBJECT(device), "card-id", &card_id, NULL);
+        
+        if (card_id == GVC_MIXER_UI_DEVICE_INVALID){
+                g_warning ("gvc_mixer_control_change_profile - no card => different profile but cant find a valid card id ?");
+                return;
+        }
+        GvcMixerCard *card;
+        card = gvc_mixer_control_lookup_card_id (control, card_id);     
+        current_profile = gvc_mixer_card_get_profile (card);
+        
+        if (current_profile)
+                best_profile = gvc_mixer_ui_device_get_best_profile (device, profile, current_profile->profile);
+        else
+                best_profile = profile;
+        
+        g_assert(best_profile);
+
+        g_debug ("Selected '%s', moving to profile '%s' on card '%s' on stream id %i \n",
+                profile ? profile : "(any)", best_profile,
+                gvc_mixer_card_get_name (card),
+                gvc_mixer_ui_device_get_stream_id (device));
+        
+        g_debug ("\n default sink name = %s \n and default sink id %u",
+                 control->priv->default_sink_name,
+                 control->priv->default_sink_id);
+
+        control->priv->profile_swapping_device_id = gvc_mixer_ui_device_get_id (device);
+
+        if (gvc_mixer_card_change_profile (card, best_profile)) {
+                gvc_mixer_ui_device_set_user_preferred_profile (device, best_profile);
+                return TRUE;
+        }
+        return FALSE;
+}                                                     
+
+/**
+ * gvc_mixer_control_change_output:
+ * @control:
+ * @output:
+ This method is called from the UI when the user selects a previously unselected device.
+ - Firstly it queries the stream from the device.
+   - It assumes that if the stream is null that it cannot be a bluetooth or network stream (they never show unless they have valid sinks and sources)
+   In the scenario of a NULL stream on the device
+        - It fetches the device's preferred profile or if NUll the profile with the highest priority on that device.
+        - It then caches this device in control->priv->cached_desired_output_id so that when the update_sink triggered
+          from when we attempt to change profile we will know exactly what device to highlight on that stream.
+        - It attempts to swap the profile on the card from that device and returns.
+ - Next, it handles network or bluetooth streams that only require their stream to be made the default.
+ - Next it deals with port changes so if the stream's active port is not the same as the port on the device
+   it will attempt to change the port on that stream to be same as the device. If this fails it will return.
+ - Finally it will set this new stream to be the default stream and emit a signal for the UI confirming the active output device.
+ */						     
+void
+gvc_mixer_control_change_output (GvcMixerControl *control,
+                                 GvcMixerUIDevice* output)
+{
+        g_debug ("\n control change output \n");
+        GvcMixerStream *stream;
+        GvcMixerStream *default_stream;
+
+        stream = gvc_mixer_control_get_stream_from_device (control, output);
+        if (stream == NULL){
+                gvc_mixer_control_change_profile_on_selected_device (control,
+                        output, NULL);
+                return;
+        }
+
+        // Handle a network sink => a portless or cardless device
+        if (gvc_mixer_ui_device_is_software (output) || gvc_mixer_ui_device_is_bluetooth (output)){
+                g_debug ("Did we try to move to a software/bluetooth sink ? \n");
+                if (gvc_mixer_control_set_default_sink (control, stream)) {
+                        // sink change successfull => update the UI.
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[ACTIVE_OUTPUT_UPDATE],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (output));             
+                }
+                else{
+                        g_warning ("Failed to set default sink with stream from output %s \n",
+                                   gvc_mixer_ui_device_get_description (output));
+                }
+                return;
+        }
+
+	const GvcMixerStreamPort* active_port = gvc_mixer_stream_get_port (stream);
+	const gchar* output_port = gvc_mixer_ui_device_get_port (output);
+        // First ensure the correct port is active on the sink
+	if (g_strcmp0 (active_port->port, output_port) != 0){
+		g_debug ("\n Port change, switch to = %s \n", 
+			  output_port); 
+		if (gvc_mixer_stream_change_port (stream, output_port) == FALSE){
+                        g_warning ("\n Could not change port ! \n");
+                        return;
+		}
+        }
+
+        default_stream = gvc_mixer_control_get_default_sink (control);	 
+        
+        // Finally if we are not on the correct stream, swap over.
+	if (stream != default_stream){
+                g_debug ("\n\n !!!!Attempting to swap over to stream %s \n",
+                         gvc_mixer_stream_get_description(stream));
+                GvcMixerUIDevice* output;
+                if (gvc_mixer_control_set_default_sink (control, stream)){
+                        output = gvc_mixer_control_lookup_device_from_stream (control, stream);
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[ACTIVE_OUTPUT_UPDATE],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (output));                                  
+                }
+                else{
+                        // If the move failed for some reason reset the UI.
+                        output = gvc_mixer_control_lookup_device_from_stream (control, default_stream);
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[ACTIVE_OUTPUT_UPDATE],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (output));                                  
+                        
+                }
+        }
+}
+
+
+/**
+ * gvc_mixer_control_change_input:
+ * @control:
+ * @input:
+ This method is called from the UI when the user selects a previously unselected device.
+ - Firstly it queries the stream from the device.
+   - It assumes that if the stream is null that it cannot be a bluetooth or network stream (they never show unless they have valid sinks and sources)
+   In the scenario of a NULL stream on the device
+        - It fetches the device's preferred profile or if NUll the profile with the highest priority on that device.
+        - It then caches this device in control->priv->cached_desired_input_id so that when the update_source triggered
+          from when we attempt to change profile we will know exactly what device to highlight on that stream.
+        - It attempts to swap the profile on the card from that device and returns.
+ - Next, it handles network or bluetooth streams that only require their stream to be made the default.
+ - Next it deals with port changes so if the stream's active port is not the same as the port on the device
+   it will attempt to change the port on that stream to be same as the device. If this fails it will return.
+ - Finally it will set this new stream to be the default stream and emit a signal for the UI confirming the active input device.
+ */
+void
+gvc_mixer_control_change_input (GvcMixerControl *control,
+                                GvcMixerUIDevice* input)
+{
+        GvcMixerStream *stream;
+        GvcMixerStream *default_stream;
+
+        stream = gvc_mixer_control_get_stream_from_device (control, input);
+        if (stream == NULL){
+                gvc_mixer_control_change_profile_on_selected_device (control,
+                        input, NULL);
+                return;
+        }
+
+        // Handle a network sink => a portless/cardless device
+        if (gvc_mixer_ui_device_is_software (input) || gvc_mixer_ui_device_is_bluetooth (input)){
+                g_debug ("\n Did we try to move to a software/bluetooth source ? \n");
+                if (! gvc_mixer_control_set_default_source (control, stream)) {
+                        g_warning ("Failed to set default source with stream from input %s \n",
+                                   gvc_mixer_ui_device_get_description (input));
+                }
+                return;
+        }
+
+        const GvcMixerStreamPort* active_port = gvc_mixer_stream_get_port (stream);
+        const gchar* input_port = gvc_mixer_ui_device_get_port (input);
+        // First ensure the correct port is active on the sink
+        if (g_strcmp0 (active_port->port, input_port) != 0){
+                g_debug ("\n Port change, switch to = %s \n", 
+                          input_port); 
+                if (gvc_mixer_stream_change_port (stream, input_port) == FALSE){
+                        g_warning ("\n Could not change port ! \n");
+                        return;
+                }
+        }
+
+        default_stream = gvc_mixer_control_get_default_source (control);   
+        
+        // Finally if we are not on the correct stream, swap over.              
+        if (stream != default_stream){
+                g_debug ("\n change-input - attempting to swap over to stream %s \n",
+                         gvc_mixer_stream_get_description(stream));
+                gvc_mixer_control_set_default_source (control, stream);
+        }
+}
+
+
+static void
+listify_hash_values_hfunc (gpointer key,
+                           gpointer value,
+                           gpointer user_data)
+{
+        GSList **list = user_data;
+
+        *list = g_slist_prepend (*list, value);
+}
+
+static int
+gvc_name_collate (const char *namea,
+                  const char *nameb)
+{
+        if (nameb == NULL && namea == NULL)
+                return 0;
+        if (nameb == NULL)
+                return 1;
+        if (namea == NULL)
+                return -1;
+
+        return g_utf8_collate (namea, nameb);
+}
+
+static int
+gvc_card_collate (GvcMixerCard *a,
+                  GvcMixerCard *b)
+{
+        const char *namea;
+        const char *nameb;
+
+        g_return_val_if_fail (a == NULL || GVC_IS_MIXER_CARD (a), 0);
+        g_return_val_if_fail (b == NULL || GVC_IS_MIXER_CARD (b), 0);
+
+        namea = gvc_mixer_card_get_name (a);
+        nameb = gvc_mixer_card_get_name (b);
+
+        return gvc_name_collate (namea, nameb);
+}
+
+/**
+ * gvc_mixer_control_get_cards:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerCard):
+ */
+GSList *
+gvc_mixer_control_get_cards (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->cards,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_card_collate);
+}
+
+static int
+gvc_stream_collate (GvcMixerStream *a,
+                    GvcMixerStream *b)
+{
+        const char *namea;
+        const char *nameb;
+
+        g_return_val_if_fail (a == NULL || GVC_IS_MIXER_STREAM (a), 0);
+        g_return_val_if_fail (b == NULL || GVC_IS_MIXER_STREAM (b), 0);
+
+        namea = gvc_mixer_stream_get_name (a);
+        nameb = gvc_mixer_stream_get_name (b);
+
+        return gvc_name_collate (namea, nameb);
+}
+
+/**
+ * gvc_mixer_control_get_streams:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerStream):
+ */
+GSList *
+gvc_mixer_control_get_streams (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->all_streams,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+
+/**
+ * gvc_mixer_control_get_sinks:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerSink):
+ */
+GSList *
+gvc_mixer_control_get_sinks (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->sinks,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+/**
+ * gvc_mixer_control_get_sources:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerSource):
+ */
+GSList *
+gvc_mixer_control_get_sources (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->sources,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+/**
+ * gvc_mixer_control_get_sink_inputs:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerSinkInput):
+ */
+GSList *
+gvc_mixer_control_get_sink_inputs (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->sink_inputs,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+/**
+ * gvc_mixer_control_get_source_outputs:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerSourceOutput):
+ */
+GSList *
+gvc_mixer_control_get_source_outputs (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->source_outputs,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+static void
+dec_outstanding (GvcMixerControl *control)
+{
+        if (control->priv->n_outstanding <= 0) {
+                return;
+        }
+
+        if (--control->priv->n_outstanding <= 0) {
+                control->priv->state = GVC_STATE_READY;
+                g_signal_emit (G_OBJECT (control), signals[STATE_CHANGED], 0, GVC_STATE_READY);
+        }
+}
+
+GvcMixerControlState
+gvc_mixer_control_get_state (GvcMixerControl *control)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+
+        return control->priv->state;
+}
+
+static void
+on_default_source_port_notify (GObject        *object,
+                               GParamSpec     *pspec,
+                               GvcMixerControl *control)
+{
+        char *port;
+        g_object_get (object, "port", &port, NULL);
+        GvcMixerUIDevice* input;
+        input = gvc_mixer_control_lookup_device_from_stream (control,
+                                                             GVC_MIXER_STREAM (object));
+                                                                      
+        g_debug ("\n\n on_default_source_port_notify - moved to port %s \n which SHOULD ?? correspond to output \n %s \n",
+                 port,
+                 gvc_mixer_ui_device_get_description (input));
+
+        g_signal_emit (G_OBJECT (control),
+                       signals[ACTIVE_INPUT_UPDATE],
+                       0,
+                       gvc_mixer_ui_device_get_id (input));       
+
+        g_free (port);
+}
+
+
+static void
+_set_default_source (GvcMixerControl *control,
+                     GvcMixerStream  *stream)
+{
+        guint new_id;
+
+        if (stream == NULL) {
+                control->priv->default_source_id = 0;
+                control->priv->default_source_is_set = FALSE;
+                g_signal_emit (control,
+                               signals[DEFAULT_SOURCE_CHANGED],
+                               0,
+                               PA_INVALID_INDEX);
+                return;
+        }
+
+        new_id = gvc_mixer_stream_get_id (stream);
+
+        if (control->priv->default_source_id != new_id) {
+                control->priv->default_source_id = new_id;
+                control->priv->default_source_is_set = TRUE;
+                g_signal_emit (control,
+                               signals[DEFAULT_SOURCE_CHANGED],
+                               0,
+                               new_id);
+
+                if (control->priv->default_source_is_set){
+                        g_signal_handlers_disconnect_by_func (gvc_mixer_control_get_default_source (control),
+                                                              on_default_source_port_notify,
+                                                              control);                        
+                }
+
+                g_signal_connect (stream,
+                                  "notify::port",
+                                  G_CALLBACK (on_default_source_port_notify),
+                                  control);
+
+                GvcMixerUIDevice* input;
+                input = gvc_mixer_control_lookup_device_from_stream (control, stream);
+
+                g_signal_emit (G_OBJECT (control),
+                               signals[ACTIVE_INPUT_UPDATE],
+                               0,
+                               gvc_mixer_ui_device_get_id (input));
+
+        }
+}
+
+static void
+on_default_sink_port_notify (GObject        *object,
+                             GParamSpec     *pspec,
+                             GvcMixerControl *control)
+{
+        char *port;
+        g_object_get (object, "port", &port, NULL);
+        GvcMixerUIDevice* output;
+        output = gvc_mixer_control_lookup_device_from_stream (control,
+                                                              GVC_MIXER_STREAM (object));
+        if (output != NULL){
+                g_debug ("\n\n on_default_sink_port_notify - moved to port %s \n which SHOULD correspond to output %s \n",
+                         port,
+                         gvc_mixer_ui_device_get_description (output));
+                g_signal_emit (G_OBJECT (control),
+                               signals[ACTIVE_OUTPUT_UPDATE],
+                               0,
+                               gvc_mixer_ui_device_get_id (output));
+        }
+        g_free(port);
+}
+
+
+static void
+_set_default_sink (GvcMixerControl *control,
+                   GvcMixerStream  *stream)
+{
+        guint new_id;
+
+        if (stream == NULL) {
+                /* Don't tell front-ends about an unset default
+                 * sink if it's already unset */
+                if (control->priv->default_sink_is_set == FALSE)
+                        return;
+                control->priv->default_sink_id = 0;
+                control->priv->default_sink_is_set = FALSE;
+                g_signal_emit (control,
+                               signals[DEFAULT_SINK_CHANGED],
+                               0,
+                               PA_INVALID_INDEX);
+                return;
+        }
+
+        new_id = gvc_mixer_stream_get_id (stream);
+
+        if (control->priv->default_sink_id != new_id) {                
+                if (control->priv->default_sink_is_set){
+                        g_signal_handlers_disconnect_by_func (gvc_mixer_control_get_default_sink (control),
+                                                              on_default_sink_port_notify,
+                                                              control);                        
+                }
+
+                control->priv->default_sink_id = new_id;
+
+                control->priv->default_sink_is_set = TRUE;
+                g_signal_emit (control,
+                               signals[DEFAULT_SINK_CHANGED],
+                               0,
+                               new_id);
+                               
+                g_signal_connect (stream,
+                                  "notify::port",
+                                  G_CALLBACK (on_default_sink_port_notify),
+                                  control);
+
+                GvcMixerUIDevice* output;                
+                output = gvc_mixer_control_lookup_device_from_stream (control, stream);
+
+                g_debug ("active_sink change \n");
+
+                g_signal_emit (G_OBJECT (control),
+                               signals[ACTIVE_OUTPUT_UPDATE],
+                               0,
+                               gvc_mixer_ui_device_get_id (output));                       
+        }
+}
+
+static gboolean
+_stream_has_name (gpointer        key,
+                  GvcMixerStream *stream,
+                  const char     *name)
+{
+        const char *t_name;
+
+        t_name = gvc_mixer_stream_get_name (stream);
+
+        if (t_name != NULL
+            && name != NULL
+            && strcmp (t_name, name) == 0) {
+                return TRUE;
+        }
+
+        return FALSE;
+}
+
+static GvcMixerStream  *
+find_stream_for_name (GvcMixerControl *control,
+                      const char      *name)
+{
+        GvcMixerStream *stream;
+
+        stream = g_hash_table_find (control->priv->all_streams,
+                                    (GHRFunc)_stream_has_name,
+                                    (char *)name);
+        return stream;
+}
+
+static void
+update_default_source_from_name (GvcMixerControl *control,
+                                 const char      *name)
+{
+        gboolean changed = FALSE;
+
+        if ((control->priv->default_source_name == NULL
+             && name != NULL)
+            || (control->priv->default_source_name != NULL
+                && name == NULL)
+            || (name != NULL && strcmp (control->priv->default_source_name, name) != 0)) {
+                changed = TRUE;
+        }
+
+        if (changed) {
+                GvcMixerStream *stream;
+
+                g_free (control->priv->default_source_name);
+                control->priv->default_source_name = g_strdup (name);
+
+                stream = find_stream_for_name (control, name);
+                _set_default_source (control, stream);
+        }
+}
+
+static void
+update_default_sink_from_name (GvcMixerControl *control,
+                               const char      *name)
+{
+        gboolean changed = FALSE;
+
+        if ((control->priv->default_sink_name == NULL
+             && name != NULL)
+            || (control->priv->default_sink_name != NULL
+                && name == NULL)
+            || (name != NULL && strcmp (control->priv->default_sink_name, name) != 0)) {
+                changed = TRUE;
+        }
+
+        if (changed) {
+                GvcMixerStream *stream;
+                g_free (control->priv->default_sink_name);
+                control->priv->default_sink_name = g_strdup (name);
+
+                stream = find_stream_for_name (control, name);
+                _set_default_sink (control, stream);
+        }
+}
+
+static void
+update_server (GvcMixerControl      *control,
+               const pa_server_info *info)
+{
+        if (info->default_source_name != NULL) {
+                update_default_source_from_name (control, info->default_source_name);
+        }
+        if (info->default_sink_name != NULL) {
+                g_debug ("\n update server");
+                update_default_sink_from_name (control, info->default_sink_name);
+        }
+}
+
+static void
+remove_stream (GvcMixerControl *control,
+               GvcMixerStream  *stream)
+{
+        guint id;
+
+        g_object_ref (stream);
+
+        id = gvc_mixer_stream_get_id (stream);
+                
+        if (id == control->priv->default_sink_id) {
+                _set_default_sink (control, NULL);
+        } else if (id == control->priv->default_source_id) {
+                _set_default_source (control, NULL);
+        }
+
+        g_hash_table_remove (control->priv->all_streams,
+                             GUINT_TO_POINTER (id));
+        g_signal_emit (G_OBJECT (control),
+                       signals[STREAM_REMOVED],
+                       0,
+                       gvc_mixer_stream_get_id (stream));
+        g_object_unref (stream);
+}
+
+static void
+add_stream (GvcMixerControl *control,
+            GvcMixerStream  *stream)
+{
+        g_hash_table_insert (control->priv->all_streams,
+                             GUINT_TO_POINTER (gvc_mixer_stream_get_id (stream)),
+                             stream);
+        g_signal_emit (G_OBJECT (control),
+                       signals[STREAM_ADDED],
+                       0,
+                       gvc_mixer_stream_get_id (stream));
+}
+
+/*
+This method will match individual stream ports against it's corresponding device
+It does this by:
+- iterates through our devices and finds the one where the card-id on the device is the same as the card-id on the stream
+  && the port-name on the device is the same as the streamport-name.
+This should always find a match and is used exclusively by @sync_devices.
+*/ 
+static gboolean
+match_stream_with_devices (GvcMixerControl *control,
+        		   GvcMixerStreamPort* stream_port,
+                           GvcMixerStream* stream)
+{
+	GList 			*devices;
+	GList 			*d;
+	GvcMixerUIDevice	*device;
+        guint                   stream_card_id;
+        guint                   stream_id;
+        			
+	stream_id      =  gvc_mixer_stream_get_id (stream);
+        stream_card_id =  gvc_mixer_stream_get_card_index (stream);
+
+        devices  = g_hash_table_get_values (GVC_IS_MIXER_SOURCE (stream) ? control->priv->ui_inputs : control->priv->ui_outputs);                       
+	gboolean in_possession 	= FALSE;
+
+	for (d = devices; d != NULL; d = d->next) {				
+		device = d->data;
+
+		gint  device_stream_id;
+		gchar *device_port_name;
+		gchar *origin;
+		gchar *description;
+		gint  card_id;
+		
+		g_object_get (G_OBJECT (device),
+			     "stream-id", &device_stream_id,
+			     "card-id", &card_id,
+			     "origin", &origin,
+			     "description", &description,
+			     "port-name", &device_port_name,
+			      NULL);
+
+		g_debug ("\n Attempt to match_stream update_with_existing_outputs \n Try description : %s \n, origin : %s \n device port name : %s \n card id : %i \n AGAINST stream port: %s \n sink card id %i \n\n ",
+			 description,
+			 origin,
+			 device_port_name,
+			 card_id, 
+			 stream_port->port,
+			 stream_card_id);
+
+		if ( stream_card_id == card_id &&
+		     g_strcmp0 (device_port_name, stream_port->port) == 0) {					     
+			g_debug ("\n Match device with stream \n We have a match with description : %s  \n origin : %s \n cached already with device id %u, \n => set stream id to %i \n\n ",
+ 				 description,
+				 origin,
+				 gvc_mixer_ui_device_get_id (device),
+                                 stream_id);
+			
+			g_object_set (G_OBJECT (device),
+    				      "stream-id", (gint)stream_id,
+				      NULL);		      								     
+			in_possession = TRUE;						    
+		}
+									      
+		g_free (device_port_name);				
+		g_free (origin);						
+		g_free (description);
+		
+		if (in_possession == TRUE)
+			break;
+	}
+	return in_possession;	
+}
+
+/*
+This method attempts to match a sink or source with it's relevant UI device.
+GvcMixerStream can represent both a sink or source.
+Using static card port introspection implies that we know beforehand what outputs and inputs are available to the user.
+But that does not mean that all of these inputs and outputs are available to be used. 
+For instance we might be able to see that there is a HDMI port available but if we are on the default analog stereo output profile there is no valid sink for that HDMI device. We first need to change profile and when update_sink is called only then can we match the new hdmi sink with it's corresponding device.
+It works like this: 
+Firstly it checks to see if the incoming stream has no ports.
+- If a stream has no ports but has a valid card ID (bluetooth),  it will attempt to match the device with the stream using the card id.
+- If a stream has no ports and no valid card id, it goes ahead and makes a new device (software/network devices are only detectable at the sink/source level)
+If the stream has ports it will match each port against the stream using @match_stream_with_devices.
+This method should always find a match !
+*/
+static void
+sync_devices (GvcMixerControl *control,
+	      GvcMixerStream* stream)
+{
+	// Go through ports to see what outputs can be created.
+	const GList *stream_ports = NULL;
+	const GList *n = NULL;
+        const GList *d;
+        gboolean is_output = !GVC_IS_MIXER_SOURCE (stream);
+        stream_ports = gvc_mixer_stream_get_ports (stream);
+	gint stream_port_count = 0;
+		
+        if (g_list_length (stream_ports) == 0){
+                GvcMixerUIDevice* device;
+                // Bluetooth
+                // => no ports && a valid card
+                if (gvc_mixer_stream_get_card_index (stream) != PA_INVALID_INDEX) {
+                        GList *devices;
+
+                        devices = g_hash_table_get_values ( is_output ? control->priv->ui_outputs : control->priv->ui_inputs);
+
+                        gboolean in_possession  = FALSE;
+
+                        for (d = devices; d != NULL; d = d->next) {                             
+                                gint  card_id;
+                                device = d->data;
+                                
+                                g_object_get (G_OBJECT (device),
+                                             "card-id", &card_id,
+                                              NULL);
+                                g_debug ("\n sync devices \n device description - %s \n device card id - %i \n stream description - %s \n stream card id - %i", gvc_mixer_ui_device_get_description (device), card_id, gvc_mixer_stream_get_description (stream), gvc_mixer_stream_get_card_index (stream));
+                                if (card_id == gvc_mixer_stream_get_card_index (stream)){
+                                        in_possession = TRUE;
+                                        break;
+                                }
+                        }
+                        if (!in_possession){
+                                g_warning ("\n \n Couldn't match the portless stream (with card) - %s \n is it an input ? -> %i \n \n streams card id -> %i \n", gvc_mixer_stream_get_description (stream), GVC_IS_MIXER_SOURCE (stream), gvc_mixer_stream_get_card_index (stream));
+                                return;
+                        }
+
+                        GvcMixerCard* card = NULL;
+                        card = gvc_mixer_control_lookup_card_id (control,
+                                                                 gvc_mixer_stream_get_card_index (stream));
+                        g_object_set (G_OBJECT (device),
+                                      "stream-id", (gint)gvc_mixer_stream_get_id (stream),
+                                      "description", gvc_mixer_stream_get_description (stream),
+                                      "origin", "", /*Leave it empty for these special cases*/
+                                      "port-name", NULL,
+                                      "port-available", TRUE,
+                                      NULL);
+                }
+                // Network sink/source => no ports && no card.
+                else{
+                        GObject *object;
+
+                        object = g_object_new (GVC_TYPE_MIXER_UI_DEVICE,
+                                               "stream-id", (gint)gvc_mixer_stream_get_id (stream),
+                                               "description", gvc_mixer_stream_get_description (stream),
+                                               "origin", "", /*Leave it empty for these special cases*/
+                                               "port-name", NULL,
+                                               "port-available", TRUE,
+                                                NULL);
+                        device = GVC_MIXER_UI_DEVICE (object);
+
+                        g_hash_table_insert (is_output ? control->priv->ui_outputs : control->priv->ui_inputs,
+                                             GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (device)),
+                                             g_object_ref (device));
+                                        
+                }
+                g_signal_emit (G_OBJECT (control),
+                               signals[is_output ? OUTPUT_ADDED : INPUT_ADDED],
+                               0,
+                               gvc_mixer_ui_device_get_id (device));
+
+                return;
+        }
+
+        // Go ahead and make sure to match each port against a previously created device
+	for (n = stream_ports; n != NULL; n = n->next) {
+
+		GvcMixerStreamPort *stream_port;
+		stream_port = n->data;		
+		stream_port_count ++;
+							
+		if ( TRUE == match_stream_with_devices (control,
+							stream_port,
+							stream))
+			continue;		
+		
+		g_warning ("\n Sync_devices : Failed to match \n stream id: %u \n description : %s \n origin : %s \n \n ",
+     			   gvc_mixer_stream_get_id (stream),
+			   stream_port->human_port,				 	 
+			   gvc_mixer_stream_get_description (stream));		
+	}		
+}
+
+static void
+set_icon_name_from_proplist (GvcMixerStream *stream,
+                             pa_proplist    *l,
+                             const char     *default_icon_name)
+{
+        const char *t;
+
+        if ((t = pa_proplist_gets (l, PA_PROP_DEVICE_ICON_NAME))) {
+                goto finish;
+        }
+
+        if ((t = pa_proplist_gets (l, PA_PROP_MEDIA_ICON_NAME))) {
+                goto finish;
+        }
+
+        if ((t = pa_proplist_gets (l, PA_PROP_WINDOW_ICON_NAME))) {
+                goto finish;
+        }
+
+        if ((t = pa_proplist_gets (l, PA_PROP_APPLICATION_ICON_NAME))) {
+                goto finish;
+        }
+
+        if ((t = pa_proplist_gets (l, PA_PROP_MEDIA_ROLE))) {
+
+                if (strcmp (t, "video") == 0 ||
+                    strcmp (t, "phone") == 0) {
+                        goto finish;
+                }
+
+                if (strcmp (t, "music") == 0) {
+                        t = "audio";
+                        goto finish;
+                }
+
+                if (strcmp (t, "game") == 0) {
+                        t = "applications-games";
+                        goto finish;
+                }
+
+                if (strcmp (t, "event") == 0) {
+                        t = "dialog-information";
+                        goto finish;
+                }
+        }
+
+        t = default_icon_name;
+
+ finish:
+        gvc_mixer_stream_set_icon_name (stream, t);
+}
+
+/*
+* Called when anything changes with a sink.
+*/
+static void
+update_sink (GvcMixerControl    *control,
+             const pa_sink_info *info)
+{
+        GvcMixerStream  *stream;
+        gboolean        is_new;
+        pa_volume_t     max_volume;
+        GvcChannelMap   *map;
+        char            map_buff[PA_CHANNEL_MAP_SNPRINT_MAX];
+
+        pa_channel_map_snprint (map_buff, PA_CHANNEL_MAP_SNPRINT_MAX, &info->channel_map);
+#if 1
+        g_debug ("Updating sink: index=%u name='%s' description='%s' map='%s'",
+                 info->index,
+                 info->name,
+                 info->description,
+                 map_buff);
+#endif
+
+        map = NULL;
+        is_new = FALSE;
+        stream = g_hash_table_lookup (control->priv->sinks,
+                                      GUINT_TO_POINTER (info->index));
+
+        if (stream == NULL) {
+                GList *list = NULL;
+                guint i;
+
+                map = gvc_channel_map_new_from_pa_channel_map (&info->channel_map);
+                stream = gvc_mixer_sink_new (control->priv->pa_context,
+                                             info->index,
+                                             map);
+
+                for (i = 0; i < info->n_ports; i++) {
+                        GvcMixerStreamPort *port;
+
+                        port = g_new0 (GvcMixerStreamPort, 1);
+                        port->port = g_strdup (info->ports[i]->name);
+                        port->human_port = g_strdup (info->ports[i]->description);
+                        port->priority = info->ports[i]->priority;
+                        port->available = info->ports[i]->available == 0 ||
+                                            info->ports[i]->available == 2;
+                        
+                        list = g_list_prepend (list, port);
+                }
+                gvc_mixer_stream_set_ports (stream, list);
+
+                g_object_unref (map);
+                is_new = TRUE;
+
+        } else if (gvc_mixer_stream_is_running (stream)) {
+                /* Ignore events if volume changes are outstanding */
+                g_debug ("Ignoring event, volume changes are outstanding");
+                return;
+        }   
+
+        max_volume = pa_cvolume_max (&info->volume);
+        gvc_mixer_stream_set_name (stream, info->name);
+        gvc_mixer_stream_set_card_index (stream, info->card);
+        gvc_mixer_stream_set_description (stream, info->description);
+        set_icon_name_from_proplist (stream, info->proplist, "audio-card");
+        gvc_mixer_stream_set_volume (stream, (guint)max_volume);
+        gvc_mixer_stream_set_is_muted (stream, info->mute);
+        gvc_mixer_stream_set_can_decibel (stream, !!(info->flags & PA_SINK_DECIBEL_VOLUME));
+        gvc_mixer_stream_set_base_volume (stream, (guint32) info->base_volume);
+
+        // Messy I know but to set the port everytime regardless of whether it has changed will cost us a 
+        // port change notify signal which causes the frontend to resync. 
+        // Only update the UI when something has changed.
+        if (info->active_port != NULL){
+                if (is_new){
+                        gvc_mixer_stream_set_port (stream, info->active_port->name);                        
+                }
+                else{
+                        GvcMixerStreamPort* active_port;
+                        active_port = gvc_mixer_stream_get_port (stream);
+                        if (active_port == NULL || 
+                            g_strcmp0 (active_port->port, info->active_port->name) != 0){                
+                                g_debug ("\n update sink - apparently a port update");
+                                gvc_mixer_stream_set_port (stream, info->active_port->name);
+                        }
+                }
+	}
+        
+        if (is_new) {
+                g_debug ("\n update sink - is new \n");
+
+                g_hash_table_insert (control->priv->sinks,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (stream));
+                add_stream (control, stream);
+                // Always sink on a new stream to able to assign the right stream id 
+                // to the appropriate outputs (=> multiple potential outputs per stream).
+                sync_devices (control, stream);	
+        }
+        
+        /*
+        When we change profile on a device that is not the server default sink,
+        it will jump back to the default sink set by the server to prevent the audio setup from being 'outputless'.
+        All well and good but then when we get the new stream created for the new profile how do we know 
+        that this is the intended default or selected device the user wishes to use.
+        This is messy but it's the only reliable way that it can be done without ripping the whole thing apart.
+        */
+        if (control->priv->profile_swapping_device_id != GVC_MIXER_UI_DEVICE_INVALID){
+                GvcMixerUIDevice *dev = NULL;
+                dev = gvc_mixer_control_lookup_output_id (control, control->priv->profile_swapping_device_id);
+                if (dev != NULL){
+                        // now check to make sure this new stream is the same stream just matched and set on the device object
+                        if (gvc_mixer_ui_device_get_stream_id (dev) == gvc_mixer_stream_get_id (stream)){
+                                g_debug ("Looks like we profile swapped on a non server default sink");
+                                gvc_mixer_control_set_default_sink (control, stream);
+                        }  
+                }
+                control->priv->profile_swapping_device_id = GVC_MIXER_UI_DEVICE_INVALID;                
+        }
+
+        if (control->priv->default_sink_name != NULL
+            && info->name != NULL
+            && strcmp (control->priv->default_sink_name, info->name) == 0) {
+                _set_default_sink (control, stream);
+        }
+
+        if (map == NULL)
+                map = (GvcChannelMap *) gvc_mixer_stream_get_channel_map (stream);
+        
+        gvc_channel_map_volume_changed (map, &info->volume, FALSE);     
+}
+
+static void
+update_source (GvcMixerControl      *control,
+               const pa_source_info *info)
+{
+        GvcMixerStream *stream;
+        gboolean        is_new;
+        gboolean        port_change;
+        pa_volume_t     max_volume;
+
+#if 1
+        g_debug ("Updating source: index=%u name='%s' description='%s'",
+                 info->index,
+                 info->name,
+                 info->description);
+#endif
+
+        /* completely ignore monitors, they're not real sources */
+        if (info->monitor_of_sink != PA_INVALID_INDEX) {
+                return;
+        }
+
+        is_new = FALSE;
+        stream = g_hash_table_lookup (control->priv->sources,
+                                      GUINT_TO_POINTER (info->index));
+        if (stream == NULL) {
+                GList *list = NULL;
+                guint i;
+                GvcChannelMap *map;
+
+                map = gvc_channel_map_new_from_pa_channel_map (&info->channel_map);
+                stream = gvc_mixer_source_new (control->priv->pa_context,
+                                               info->index,
+                                               map);
+
+                for (i = 0; i < info->n_ports; i++) {
+                        GvcMixerStreamPort *port;
+
+                        port = g_new0 (GvcMixerStreamPort, 1);
+                        port->port = g_strdup (info->ports[i]->name);
+                        port->human_port = g_strdup (info->ports[i]->description);
+                        port->priority = info->ports[i]->priority;
+                        list = g_list_prepend (list, port);
+                }
+                gvc_mixer_stream_set_ports (stream, list);
+
+                g_object_unref (map);
+                is_new = TRUE;
+        } else if (gvc_mixer_stream_is_running (stream)) {
+                /* Ignore events if volume changes are outstanding */
+                g_debug ("Ignoring event, volume changes are outstanding");
+                return;
+        }
+
+        max_volume = pa_cvolume_max (&info->volume);
+
+        gvc_mixer_stream_set_name (stream, info->name);
+        gvc_mixer_stream_set_card_index (stream, info->card);
+        gvc_mixer_stream_set_description (stream, info->description);
+        set_icon_name_from_proplist (stream, info->proplist, "audio-input-microphone");
+        gvc_mixer_stream_set_volume (stream, (guint)max_volume);
+        gvc_mixer_stream_set_is_muted (stream, info->mute);
+        gvc_mixer_stream_set_can_decibel (stream, !!(info->flags & PA_SOURCE_DECIBEL_VOLUME));
+        gvc_mixer_stream_set_base_volume (stream, (guint32) info->base_volume);
+        g_debug ("\n update source \n");
+
+        if (info->active_port != NULL){
+                if (is_new){
+                        gvc_mixer_stream_set_port (stream, info->active_port->name);                        
+                }
+                else{
+                        GvcMixerStreamPort* active_port;
+                        active_port = gvc_mixer_stream_get_port (stream);
+                        if (active_port == NULL || 
+                            g_strcmp0 (active_port->port, info->active_port->name) != 0){                
+                                g_debug ("\n update source - apparently a port update \n");
+                                gvc_mixer_stream_set_port (stream, info->active_port->name);
+                        }
+                }
+        }
+        
+        if (is_new) {
+                g_hash_table_insert (control->priv->sources,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (stream));
+                add_stream (control, stream);
+                sync_devices (control, stream);
+        }
+
+        if (control->priv->profile_swapping_device_id != GVC_MIXER_UI_DEVICE_INVALID){
+                GvcMixerUIDevice *dev = NULL;
+ 
+                dev = gvc_mixer_control_lookup_input_id (control, control->priv->profile_swapping_device_id);
+
+                if (dev != NULL){
+                        // now check to make sure this new stream is the same stream just matched and set on the device object
+                        if (gvc_mixer_ui_device_get_stream_id (dev) == gvc_mixer_stream_get_id (stream)){
+                                g_debug ("Looks like we profile swapped on a non server default sink");
+                                gvc_mixer_control_set_default_source (control, stream);
+                        }  
+                }
+                control->priv->profile_swapping_device_id = GVC_MIXER_UI_DEVICE_INVALID;                
+        }
+        if (control->priv->default_source_name != NULL
+            && info->name != NULL
+            && strcmp (control->priv->default_source_name, info->name) == 0) {
+                _set_default_source (control, stream);
+        }
+}
+
+static void
+set_is_event_stream_from_proplist (GvcMixerStream *stream,
+                                   pa_proplist    *l)
+{
+        const char *t;
+        gboolean is_event_stream;
+
+        is_event_stream = FALSE;
+
+        if ((t = pa_proplist_gets (l, PA_PROP_MEDIA_ROLE))) {
+                if (g_str_equal (t, "event"))
+                        is_event_stream = TRUE;
+        }
+
+        gvc_mixer_stream_set_is_event_stream (stream, is_event_stream);
+}
+
+static void
+set_application_id_from_proplist (GvcMixerStream *stream,
+                                  pa_proplist    *l)
+{
+        const char *t;
+
+        if ((t = pa_proplist_gets (l, PA_PROP_APPLICATION_ID))) {
+                gvc_mixer_stream_set_application_id (stream, t);
+        }
+}
+
+static void
+update_sink_input (GvcMixerControl          *control,
+                   const pa_sink_input_info *info)
+{
+        GvcMixerStream *stream;
+        gboolean        is_new;
+        pa_volume_t     max_volume;
+        const char     *name;
+
+#if 0
+        g_debug ("Updating sink input: index=%u name='%s' client=%u sink=%u",
+                 info->index,
+                 info->name,
+                 info->client,
+                 info->sink);
+#endif
+
+        is_new = FALSE;
+
+        stream = g_hash_table_lookup (control->priv->sink_inputs,
+                                      GUINT_TO_POINTER (info->index));
+        if (stream == NULL) {
+                GvcChannelMap *map;
+                map = gvc_channel_map_new_from_pa_channel_map (&info->channel_map);
+                stream = gvc_mixer_sink_input_new (control->priv->pa_context,
+                                                   info->index,
+                                                   map);
+                g_object_unref (map);
+                is_new = TRUE;
+        } else if (gvc_mixer_stream_is_running (stream)) {
+                /* Ignore events if volume changes are outstanding */
+                g_debug ("Ignoring event, volume changes are outstanding");
+                return;
+        }
+
+        max_volume = pa_cvolume_max (&info->volume);
+
+        name = (const char *)g_hash_table_lookup (control->priv->clients,
+                                                  GUINT_TO_POINTER (info->client));
+        gvc_mixer_stream_set_name (stream, name);
+        gvc_mixer_stream_set_description (stream, info->name);
+
+        set_application_id_from_proplist (stream, info->proplist);
+        set_is_event_stream_from_proplist (stream, info->proplist);
+        set_icon_name_from_proplist (stream, info->proplist, "applications-multimedia");
+        gvc_mixer_stream_set_volume (stream, (guint)max_volume);
+        gvc_mixer_stream_set_is_muted (stream, info->mute);
+        gvc_mixer_stream_set_is_virtual (stream, info->client == PA_INVALID_INDEX);
+
+        if (is_new) {
+                g_hash_table_insert (control->priv->sink_inputs,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (stream));
+                add_stream (control, stream);
+        }
+}
+
+static void
+update_source_output (GvcMixerControl             *control,
+                      const pa_source_output_info *info)
+{
+        GvcMixerStream *stream;
+        gboolean        is_new;
+        const char     *name;
+
+#if 1
+        g_debug ("Updating source output: index=%u name='%s' client=%u source=%u",
+                 info->index,
+                 info->name,
+                 info->client,
+                 info->source);
+#endif
+
+        is_new = FALSE;
+        stream = g_hash_table_lookup (control->priv->source_outputs,
+                                      GUINT_TO_POINTER (info->index));
+        if (stream == NULL) {
+                GvcChannelMap *map;
+                map = gvc_channel_map_new_from_pa_channel_map (&info->channel_map);
+                stream = gvc_mixer_source_output_new (control->priv->pa_context,
+                                                      info->index,
+                                                      map);
+                g_object_unref (map);
+                is_new = TRUE;
+        }
+
+        name = (const char *)g_hash_table_lookup (control->priv->clients,
+                                                  GUINT_TO_POINTER (info->client));
+
+        gvc_mixer_stream_set_name (stream, name);
+        gvc_mixer_stream_set_description (stream, info->name);
+        set_application_id_from_proplist (stream, info->proplist);
+        set_is_event_stream_from_proplist (stream, info->proplist);
+        set_icon_name_from_proplist (stream, info->proplist, "audio-input-microphone");
+
+        if (is_new) {
+                g_hash_table_insert (control->priv->source_outputs,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (stream));
+                add_stream (control, stream);
+        }
+}
+
+static void
+update_client (GvcMixerControl      *control,
+               const pa_client_info *info)
+{
+#if 1
+        g_debug ("Updating client: index=%u name='%s'",
+                 info->index,
+                 info->name);
+#endif
+        g_hash_table_insert (control->priv->clients,
+                             GUINT_TO_POINTER (info->index),
+                             g_strdup (info->name));
+}
+
+static char *
+card_num_streams_to_status (guint sinks,
+                            guint sources)
+{
+        char *sinks_str;
+        char *sources_str;
+        char *ret;
+
+        if (sinks == 0 && sources == 0) {
+                /* translators:
+                 * The device has been disabled */
+                return g_strdup (_("Disabled"));
+        }
+        if (sinks == 0) {
+                sinks_str = NULL;
+        } else {
+                /* translators:
+                 * The number of sound outputs on a particular device */
+                sinks_str = g_strdup_printf (ngettext ("%u Output",
+                                                       "%u Outputs",
+                                                       sinks),
+                                             sinks);
+        }
+        if (sources == 0) {
+                sources_str = NULL;
+        } else {
+                /* translators:
+                 * The number of sound inputs on a particular device */
+                sources_str = g_strdup_printf (ngettext ("%u Input",
+                                                         "%u Inputs",
+                                                         sources),
+                                               sources);
+        }
+        if (sources_str == NULL)
+                return sinks_str;
+        if (sinks_str == NULL)
+                return sources_str;
+        ret = g_strdup_printf ("%s / %s", sinks_str, sources_str);
+        g_free (sinks_str);
+        g_free (sources_str);
+        return ret;
+}
+/**
+* A utility method to gather which card profiles are relevant to the port .
+*/
+static GList* 
+determine_profiles_for_port (pa_card_port_info *port,
+			     GList* card_profiles)
+{
+	gint i;
+	GList *supported_profiles = NULL;
+	GList *p;
+	for (i = 0; i < port->n_profiles; i++) {
+		for ( p = card_profiles; p != NULL; p = p->next) {
+			GvcMixerCardProfile *prof;
+			prof = p->data;
+			if (g_strcmp0 (port->profiles[i]->name, prof->profile) == 0) {
+				supported_profiles = g_list_append (supported_profiles, prof);	
+			}
+		}
+	}
+	g_debug ("\n %i profiles supported on port %s \n",
+		 g_list_length (supported_profiles),
+		 port->description);
+	return g_list_sort (supported_profiles, (GCompareFunc) sort_profiles);
+}
+
+static gboolean
+is_card_port_an_output (GvcMixerCardPort* port)
+{
+	return port->direction == PA_DIRECTION_OUTPUT ? TRUE : FALSE;
+} 
+
+/*
+* This method will create a ui device for the given port. 
+*/
+static void
+create_ui_device_from_port (GvcMixerControl* control,
+			    GvcMixerCardPort* port,
+			    GvcMixerCard* card)
+{
+	UiDeviceDirection direction;
+	
+	direction = (is_card_port_an_output(port) == TRUE) ? UiDeviceOutput : UiDeviceInput;
+	GObject *object;
+	gboolean available = port->available == 0 || port->available == 2;
+
+	object = g_object_new (GVC_TYPE_MIXER_UI_DEVICE,
+			       "type", (uint)direction,
+			       "card-id", (gint)gvc_mixer_card_get_index (card),
+			       "port-name", port->port,
+			       "description", port->human_port,
+			       "origin", gvc_mixer_card_get_name (card),
+			       "port-available", available,
+			       NULL);
+			       
+	GvcMixerUIDevice* uidevice = GVC_MIXER_UI_DEVICE (object);
+	gvc_mixer_ui_device_set_profiles (uidevice, port->profiles);
+
+        g_hash_table_insert (is_card_port_an_output (port) ? control->priv->ui_outputs : control->priv->ui_inputs,
+                             GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (uidevice)),
+                             g_object_ref (uidevice));
+
+
+        if (available) {
+                g_signal_emit (G_OBJECT (control),
+                               signals[is_card_port_an_output (port) ? OUTPUT_ADDED : INPUT_ADDED],
+                               0,
+                               gvc_mixer_ui_device_get_id (uidevice));
+        }       
+
+	g_debug ("\n create_ui_device_from_port, direction %u \n description %s \n origin %s \n port available %i \n \n", 
+		 direction,
+		 port->human_port,
+		 gvc_mixer_card_get_name (card),
+		 available);
+}
+
+/*
+This method will match up GvcMixerCardPorts with existing devices. 
+A match is achieved if the device's card-id and the port's card-id are the same
+&& the device's port-name and the card-port's port member are the same. 
+A signal is then sent adding or removing that device from the UI depending on the availability of the port.
+*/
+static void
+match_card_port_with_existing_device (GvcMixerControl *control,
+				      GvcMixerCardPort* card_port,
+				      GvcMixerCard* card,
+				      gboolean available)
+{
+        GList 			*d;
+        GList                   *devices;
+        GvcMixerUIDevice	*device;			
+        gboolean in_possession 	= FALSE;
+        gboolean is_output      = is_card_port_an_output (card_port);
+
+        devices  = g_hash_table_get_values (is_output ? control->priv->ui_outputs : control->priv->ui_inputs);
+
+	for (d = devices; d != NULL; d = d->next) {					
+                device = d->data;
+                gint     card_id;
+                gchar    *device_port_name;
+		
+                g_object_get (G_OBJECT (device),
+                             "card-id", &card_id,
+                             "port-name", &device_port_name,
+                              NULL);
+
+                if (g_strcmp0 (card_port->port, device_port_name) == 0 && 
+                        card_id == gvc_mixer_card_get_index (card)) { 
+                        g_debug ("\n Found the relevant device %s \n update it's port availability flag to %i \n is_output %i",
+                        	 device_port_name,
+                                 available,
+                                 is_output);
+                        g_object_set ( G_OBJECT (device),
+                                       "port-available", available, NULL);
+                        g_signal_emit (G_OBJECT (control),
+                                       is_output ? signals[available ? OUTPUT_ADDED : OUTPUT_REMOVED] : signals[available ? INPUT_ADDED : INPUT_REMOVED],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (device));	
+	       }
+	       g_free (device_port_name);
+	}
+}
+/*
+At this point we can determine all devices available to us (besides network 'ports')
+This is done by the following:
+
+ - gvc_mixer_card and gvc_mixer_card_ports are created and relevant setters are called.
+ - First it checks to see if it's a portless card. Bluetooth devices are portless AFAIHS.
+        If so it creates two devices, an input and an output.
+ - If it's a 'normal' card with ports it will create a new ui-device or 
+   synchronise port availability with the existing device cached for that port on this card.
+*/		    
+static void
+update_card (GvcMixerControl      *control,
+             const pa_card_info   *info)
+{
+        GvcMixerCard *card;
+        gboolean      is_new = FALSE;
+#if 1
+        guint i,t;
+        const char *key;
+        void *state;
+
+        for (i = 0; i < info->n_profiles; i++) {
+                struct pa_card_profile_info pi = info->profiles[i];
+                gboolean is_default;
+
+                is_default = (g_strcmp0 (pi.name, info->active_profile->name) == 0);
+                g_debug ("\tProfile '%s': %d sources %d sinks%s",
+                         pi.name, pi.n_sources, pi.n_sinks,
+                         is_default ? " (Current)" : "");
+        }
+        state = NULL;
+        key = pa_proplist_iterate (info->proplist, &state);
+        while (key != NULL) {
+                g_debug ("\tProperty: '%s' = '%s'",
+                        key, pa_proplist_gets (info->proplist, key));
+                key = pa_proplist_iterate (info->proplist, &state);
+        }
+#endif
+        card = g_hash_table_lookup (control->priv->cards,
+                                    GUINT_TO_POINTER (info->index));
+        if (card == NULL) {
+                GList *profile_list = NULL;
+
+                for (i = 0; i < info->n_profiles; i++) {
+                        struct pa_card_profile_info pi = info->profiles[i];
+                        GvcMixerCardProfile *profile;
+
+                        profile = g_new0 (GvcMixerCardProfile, 1);
+                        profile->profile = g_strdup (pi.name);
+                        profile->human_profile = g_strdup (pi.description);
+                        profile->status = card_num_streams_to_status (pi.n_sinks, pi.n_sources);
+                        profile->n_sinks = pi.n_sinks;
+                        profile->n_sources = pi.n_sources;
+                        profile->priority = pi.priority;
+                        profile_list = g_list_prepend (profile_list, profile);
+                }
+                card = gvc_mixer_card_new (control->priv->pa_context,
+                                           info->index);
+                gvc_mixer_card_set_profiles (card, profile_list);
+
+		GList *port_list = NULL;
+                for (i = 0; i < info->n_ports; i++) {
+                        GvcMixerCardPort *port;
+                        port = g_new0 (GvcMixerCardPort, 1);
+                        port->port = g_strdup (info->ports[i]->name);
+                        port->human_port = g_strdup (info->ports[i]->description);
+                        port->priority = info->ports[i]->priority;
+                        port->available = info->ports[i]->available;
+                        port->direction = info->ports[i]->direction;
+			port->profiles = determine_profiles_for_port (info->ports[i], profile_list);
+                        port_list = g_list_prepend (port_list, port);                      
+                }                
+                gvc_mixer_card_set_ports (card, port_list);                
+                is_new = TRUE;
+        }
+
+        gvc_mixer_card_set_name (card, pa_proplist_gets (info->proplist, "device.description"));
+        gvc_mixer_card_set_icon_name (card, pa_proplist_gets (info->proplist, "device.icon_name"));
+        gvc_mixer_card_set_profile (card, info->active_profile->name);
+
+        if (is_new) {
+                g_hash_table_insert (control->priv->cards,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (card));
+        }
+        
+        const GList *card_ports = NULL;
+        const GList *m = NULL;
+        
+        card_ports = gvc_mixer_card_get_ports (card);
+        
+        guint port_count;
+        port_count = g_list_length (card_ports);
+
+        if (port_count == 0 && is_new){
+                // TODO : move to its own method.
+                g_debug ("\n Portless card just registered - %s \n", gvc_mixer_card_get_name (card));
+                // For now just create two devices and presume this device is multi directional
+                // Ensure to remove both on card removal (available to false by default)
+                const GList *profiles = NULL;
+                profiles = gvc_mixer_card_get_profiles (card);
+
+                g_debug ("\n Portless card just registered - %i \n", gvc_mixer_card_get_index (card));
+
+                GObject *object;
+                object = g_object_new (GVC_TYPE_MIXER_UI_DEVICE,
+                                       "type", 0,
+                                       "description", gvc_mixer_card_get_name (card),
+                                       "origin", "", /*Leave it empty for these special cases*/
+                                       "port-name", NULL,
+                                       "port-available", FALSE,
+                                       "card-id", gvc_mixer_card_get_index (card),
+                                       NULL);
+                GvcMixerUIDevice* in = GVC_MIXER_UI_DEVICE (object);
+                gvc_mixer_ui_device_set_profiles (in, profiles);                     
+
+                g_hash_table_insert (control->priv->ui_inputs,
+                                     GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (in)),
+                                     g_object_ref (in));
+                object = g_object_new (GVC_TYPE_MIXER_UI_DEVICE,
+                                       "type", 1,
+                                       "description", gvc_mixer_card_get_name (card),
+                                       "origin", "", /*Leave it empty for these special cases*/
+                                       "port-name", NULL,
+                                       "port-available", FALSE,
+                                       "card-id", gvc_mixer_card_get_index (card),
+                                       NULL);
+                GvcMixerUIDevice* out = GVC_MIXER_UI_DEVICE (object);
+                gvc_mixer_ui_device_set_profiles (out, profiles);                     
+
+                g_hash_table_insert (control->priv->ui_outputs,
+                                     GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (out)),
+                                     g_object_ref (out));
+        }
+
+        for (m = card_ports; m != NULL; m = m->next) {
+                GvcMixerCardPort *card_port;
+                card_port = m->data;
+                if (is_new) {
+                        create_ui_device_from_port (control, card_port, card);
+                }
+                else{
+                        for (i = 0; i < info->n_ports; i++) {
+                                if (g_strcmp0 (card_port->port, info->ports[i]->name) == 0){
+                                        if (card_port->available != info->ports[i]->available) {
+                                                card_port->available = info->ports[i]->available;
+                                                g_debug ("\n !!! sync port availability on card %i \n card port name %s \n new available value %i \n",
+                                                          gvc_mixer_card_get_index (card),
+                                                          card_port->port,
+                                                          card_port->available);
+                                                match_card_port_with_existing_device (control,
+                                                                                      card_port,
+                                                                                      card,
+                                                                                      card_port->available == 0 ||
+                                                                                      card_port->available == 2);	
+                                        }
+                                }				
+                        }
+                }
+        }
+        g_signal_emit (G_OBJECT (control),
+                       signals[CARD_ADDED],
+                       0,
+                       info->index);
+}
+
+
+
+static void
+_pa_context_get_sink_info_cb (pa_context         *context,
+                              const pa_sink_info *i,
+                              int                 eol,
+                              void               *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Sink callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_sink (control, i);
+}
+
+static void
+_pa_context_get_source_info_cb (pa_context           *context,
+                                const pa_source_info *i,
+                                int                   eol,
+                                void                 *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Source callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_source (control, i);
+}
+
+static void
+_pa_context_get_sink_input_info_cb (pa_context               *context,
+                                    const pa_sink_input_info *i,
+                                    int                       eol,
+                                    void                     *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Sink input callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_sink_input (control, i);
+}
+
+static void
+_pa_context_get_source_output_info_cb (pa_context                  *context,
+                                       const pa_source_output_info *i,
+                                       int                          eol,
+                                       void                        *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Source output callback failure");
+                return;
+        }
+
+        if (eol > 0)  {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_source_output (control, i);
+}
+
+static void
+_pa_context_get_client_info_cb (pa_context           *context,
+                                const pa_client_info *i,
+                                int                   eol,
+                                void                 *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Client callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_client (control, i);
+}
+
+static void
+_pa_context_get_card_info_by_index_cb (pa_context *context,
+                                       const pa_card_info *i,
+                                       int eol,
+                                       void *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY)
+                        return;
+
+                g_warning ("Card callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_card (control, i);
+}
+
+static void
+_pa_context_get_server_info_cb (pa_context           *context,
+                                const pa_server_info *i,
+                                void                 *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (i == NULL) {
+                g_warning ("Server info callback failure");
+                return;
+        }
+        g_debug ("\n get server info \n");
+        update_server (control, i);
+        dec_outstanding (control);
+}
+
+static void
+remove_event_role_stream (GvcMixerControl *control)
+{
+        g_debug ("Removing event role");
+}
+
+static void
+update_event_role_stream (GvcMixerControl                  *control,
+                          const pa_ext_stream_restore_info *info)
+{
+        GvcMixerStream *stream;
+        gboolean        is_new;
+        pa_volume_t     max_volume;
+
+        if (strcmp (info->name, "sink-input-by-media-role:event") != 0) {
+                return;
+        }
+
+#if 0
+        g_debug ("Updating event role: name='%s' device='%s'",
+                 info->name,
+                 info->device);
+#endif
+
+        is_new = FALSE;
+
+        if (!control->priv->event_sink_input_is_set) {
+                pa_channel_map pa_map;
+                GvcChannelMap *map;
+
+                pa_map.channels = 1;
+                pa_map.map[0] = PA_CHANNEL_POSITION_MONO;
+                map = gvc_channel_map_new_from_pa_channel_map (&pa_map);
+
+                stream = gvc_mixer_event_role_new (control->priv->pa_context,
+                                                   info->device,
+                                                   map);
+                control->priv->event_sink_input_id = gvc_mixer_stream_get_id (stream);
+                control->priv->event_sink_input_is_set = TRUE;
+
+                is_new = TRUE;
+        } else {
+                stream = g_hash_table_lookup (control->priv->all_streams,
+                                              GUINT_TO_POINTER (control->priv->event_sink_input_id));
+        }
+
+        max_volume = pa_cvolume_max (&info->volume);
+
+        gvc_mixer_stream_set_name (stream, _("System Sounds"));
+        gvc_mixer_stream_set_icon_name (stream, "multimedia-volume-control");
+        gvc_mixer_stream_set_volume (stream, (guint)max_volume);
+        gvc_mixer_stream_set_is_muted (stream, info->mute);
+
+        if (is_new) {
+                add_stream (control, stream);
+        }
+}
+
+static void
+_pa_ext_stream_restore_read_cb (pa_context                       *context,
+                                const pa_ext_stream_restore_info *i,
+                                int                               eol,
+                                void                             *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                g_debug ("Failed to initialized stream_restore extension: %s",
+                         pa_strerror (pa_context_errno (context)));
+                remove_event_role_stream (control);
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                /* If we don't have an event stream to restore, then
+                 * set one up with a default 100% volume */
+                if (!control->priv->event_sink_input_is_set) {
+                        pa_ext_stream_restore_info info;
+
+                        memset (&info, 0, sizeof(info));
+                        info.name = "sink-input-by-media-role:event";
+                        info.volume.channels = 1;
+                        info.volume.values[0] = PA_VOLUME_NORM;
+                        update_event_role_stream (control, &info);
+                }
+                return;
+        }
+
+        update_event_role_stream (control, i);
+}
+
+static void
+_pa_ext_stream_restore_subscribe_cb (pa_context *context,
+                                     void       *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+        pa_operation    *o;
+
+        o = pa_ext_stream_restore_read (context,
+                                        _pa_ext_stream_restore_read_cb,
+                                        control);
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_read() failed");
+                return;
+        }
+
+        pa_operation_unref (o);
+}
+
+static void
+req_update_server_info (GvcMixerControl *control,
+                        int              index)
+{
+        pa_operation *o;
+
+        o = pa_context_get_server_info (control->priv->pa_context,
+                                        _pa_context_get_server_info_cb,
+                                        control);
+        if (o == NULL) {
+                g_warning ("pa_context_get_server_info() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_client_info (GvcMixerControl *control,
+                        int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_client_info_list (control->priv->pa_context,
+                                                     _pa_context_get_client_info_cb,
+                                                     control);
+        } else {
+                o = pa_context_get_client_info (control->priv->pa_context,
+                                                index,
+                                                _pa_context_get_client_info_cb,
+                                                control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_client_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_card (GvcMixerControl *control,
+                 int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_card_info_list (control->priv->pa_context,
+                                                   _pa_context_get_card_info_by_index_cb,
+                                                   control);
+        } else {
+                o = pa_context_get_card_info_by_index (control->priv->pa_context,
+                                                       index,
+                                                       _pa_context_get_card_info_by_index_cb,
+                                                       control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_card_info_by_index() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_sink_info (GvcMixerControl *control,
+                      int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_sink_info_list (control->priv->pa_context,
+                                                   _pa_context_get_sink_info_cb,
+                                                   control);
+        } else {
+                o = pa_context_get_sink_info_by_index (control->priv->pa_context,
+                                                       index,
+                                                       _pa_context_get_sink_info_cb,
+                                                       control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_sink_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_source_info (GvcMixerControl *control,
+                        int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_source_info_list (control->priv->pa_context,
+                                                     _pa_context_get_source_info_cb,
+                                                     control);
+        } else {
+                o = pa_context_get_source_info_by_index(control->priv->pa_context,
+                                                        index,
+                                                        _pa_context_get_source_info_cb,
+                                                        control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_source_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_sink_input_info (GvcMixerControl *control,
+                            int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_sink_input_info_list (control->priv->pa_context,
+                                                         _pa_context_get_sink_input_info_cb,
+                                                         control);
+        } else {
+                o = pa_context_get_sink_input_info (control->priv->pa_context,
+                                                    index,
+                                                    _pa_context_get_sink_input_info_cb,
+                                                    control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_sink_input_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_source_output_info (GvcMixerControl *control,
+                               int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_source_output_info_list (control->priv->pa_context,
+                                                            _pa_context_get_source_output_info_cb,
+                                                            control);
+        } else {
+                o = pa_context_get_source_output_info (control->priv->pa_context,
+                                                       index,
+                                                       _pa_context_get_source_output_info_cb,
+                                                       control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_source_output_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+remove_client (GvcMixerControl *control,
+               guint            index)
+{
+        g_hash_table_remove (control->priv->clients,
+                             GUINT_TO_POINTER (index));
+}
+
+static void
+remove_card (GvcMixerControl *control,
+             guint            index)
+{
+
+        GList *devices;
+        devices = g_list_concat (g_hash_table_get_values (control->priv->ui_inputs),
+                                 g_hash_table_get_values (control->priv->ui_outputs));
+
+        GList            *d;
+        GvcMixerUIDevice *device;
+
+        for (d = devices; d != NULL; d = d->next) {
+                gint card_id = GVC_MIXER_UI_DEVICE_INVALID;
+                device = d->data;
+                g_object_get (G_OBJECT (device),
+                             "card-id", &card_id,
+                              NULL);
+                if (card_id == index) {
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[gvc_mixer_ui_device_is_output (device) ? OUTPUT_REMOVED : INPUT_REMOVED],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (device));
+                        g_debug ("\n Card removal remove device %s \n",
+                                 gvc_mixer_ui_device_get_description (device)); 
+                        g_hash_table_remove (gvc_mixer_ui_device_is_output (device) ? control->priv->ui_outputs : control->priv->ui_inputs, 
+                                             GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (device)));
+                }
+        }
+        
+        g_hash_table_remove (control->priv->cards,
+                             GUINT_TO_POINTER (index));
+
+        g_signal_emit (G_OBJECT (control),
+                       signals[CARD_REMOVED],
+                       0,
+                       index);
+}
+
+static void
+remove_sink (GvcMixerControl *control,
+             guint            index)
+{
+        GvcMixerStream *stream;
+
+#if 0
+        g_debug ("Removing sink: index=%u", index);
+#endif
+
+        stream = g_hash_table_lookup (control->priv->sinks,
+                                      GUINT_TO_POINTER (index));
+        if (stream == NULL) {
+                return;
+        }   
+
+        GvcMixerUIDevice *device;
+        device = gvc_mixer_control_lookup_device_from_stream (control, stream);
+
+        if (device != NULL){
+                g_debug ("\n invalidate stream on device - remove-sinks - %s \n", gvc_mixer_ui_device_get_description (device));        
+
+                gvc_mixer_ui_device_invalidate_stream (device);
+                // If its a software device - get rid of it
+                if (gvc_mixer_ui_device_is_software (device) || gvc_mixer_ui_device_is_bluetooth (device)) {
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[OUTPUT_REMOVED],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (device));  
+                }
+                // otherwise check to make sure to invalidate other devices which may have that stream
+                else{
+                        GList   *d;
+                        GList   *devices;
+
+                        devices = g_hash_table_get_values (control->priv->ui_outputs);          
+
+                        for (d = devices; d != NULL; d = d->next) {             
+                                gint stream_id = GVC_MIXER_UI_DEVICE_INVALID;
+                                device = d->data;
+                                g_object_get (G_OBJECT (device),
+                                             "stream-id", &stream_id,
+                                              NULL);
+                                if (stream_id == gvc_mixer_stream_get_id (stream)){
+                                        g_debug ("\n invalidate stream on another relevant device - %s \n", gvc_mixer_ui_device_get_description (device)); 
+                                        gvc_mixer_ui_device_invalidate_stream (device);
+                                }
+                        }
+                }
+        }
+
+        g_hash_table_remove (control->priv->sinks,
+                             GUINT_TO_POINTER (index));
+        remove_stream (control, stream);
+}
+
+static void
+remove_source (GvcMixerControl *control,
+               guint            index)
+{
+        GvcMixerStream *stream;
+
+#if 0
+        g_debug ("Removing source: index=%u", index);
+#endif
+
+        stream = g_hash_table_lookup (control->priv->sources,
+                                      GUINT_TO_POINTER (index));
+        if (stream == NULL) {
+                return;
+        }
+
+        GvcMixerUIDevice *device;
+        device = gvc_mixer_control_lookup_device_from_stream (control, stream);
+
+        if (device != NULL){
+                g_debug ("\n invalidate stream on device - %s \n", gvc_mixer_ui_device_get_description (device));        
+
+                gvc_mixer_ui_device_invalidate_stream (device);
+                // If its a software device - get rid of it
+                if (gvc_mixer_ui_device_is_software (device) || gvc_mixer_ui_device_is_bluetooth (device)) {
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[INPUT_REMOVED],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (device));                            
+                }
+                // otherwise check to make sure to invalidate other devices which may have that stream
+                else{
+
+                        GList           *d;
+                        GList           *devices;
+
+                        devices = g_hash_table_get_values (control->priv->ui_inputs);          
+
+                        for (d = devices; d != NULL; d = d->next) {             
+                                gint stream_id = GVC_MIXER_UI_DEVICE_INVALID;
+                                device = d->data;
+                                g_object_get (G_OBJECT (device),
+                                             "stream-id", &stream_id,
+                                              NULL);
+                                if (stream_id == gvc_mixer_stream_get_id (stream)){
+                                        g_debug ("\n invalidate stream on another relevant device - %s \n", gvc_mixer_ui_device_get_description (device)); 
+                                        gvc_mixer_ui_device_invalidate_stream (device);
+                                }
+                        }
+                }
+        }
+
+
+        g_hash_table_remove (control->priv->sources,
+                             GUINT_TO_POINTER (index));
+
+        remove_stream (control, stream);
+}
+
+static void
+remove_sink_input (GvcMixerControl *control,
+                   guint            index)
+{
+        GvcMixerStream *stream;
+
+#if 0
+        g_debug ("Removing sink input: index=%u", index);
+#endif
+        stream = g_hash_table_lookup (control->priv->sink_inputs,
+                                      GUINT_TO_POINTER (index));
+        if (stream == NULL) {
+                return;
+        }
+        g_hash_table_remove (control->priv->sink_inputs,
+                             GUINT_TO_POINTER (index));
+
+        remove_stream (control, stream);
+}
+
+static void
+remove_source_output (GvcMixerControl *control,
+                      guint            index)
+{
+        GvcMixerStream *stream;
+
+#if 0
+        g_debug ("Removing source output: index=%u", index);
+#endif
+
+        stream = g_hash_table_lookup (control->priv->source_outputs,
+                                      GUINT_TO_POINTER (index));
+        if (stream == NULL) {
+                return;
+        }
+        g_hash_table_remove (control->priv->source_outputs,
+                             GUINT_TO_POINTER (index));
+
+        remove_stream (control, stream);
+}
+
+static void
+_pa_context_subscribe_cb (pa_context                  *context,
+                          pa_subscription_event_type_t t,
+                          uint32_t                     index,
+                          void                        *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        switch (t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) {
+        case PA_SUBSCRIPTION_EVENT_SINK:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_sink (control, index);
+                } else {
+                        req_update_sink_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_SOURCE:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_source (control, index);
+                } else {
+                        req_update_source_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_SINK_INPUT:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_sink_input (control, index);
+                } else {
+                        req_update_sink_input_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_source_output (control, index);
+                } else {
+                        req_update_source_output_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_CLIENT:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_client (control, index);
+                } else {
+                        req_update_client_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_SERVER:
+                req_update_server_info (control, index);
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_CARD:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_card (control, index);
+                } else {
+                        req_update_card (control, index);
+                }
+                break;
+        }
+}
+
+static void
+gvc_mixer_control_ready (GvcMixerControl *control)
+{
+        pa_operation *o;
+
+        pa_context_set_subscribe_callback (control->priv->pa_context,
+                                           _pa_context_subscribe_cb,
+                                           control);
+        o = pa_context_subscribe (control->priv->pa_context,
+                                  (pa_subscription_mask_t)
+                                  (PA_SUBSCRIPTION_MASK_SINK|
+                                   PA_SUBSCRIPTION_MASK_SOURCE|
+                                   PA_SUBSCRIPTION_MASK_SINK_INPUT|
+                                   PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT|
+                                   PA_SUBSCRIPTION_MASK_CLIENT|
+                                   PA_SUBSCRIPTION_MASK_SERVER|
+                                   PA_SUBSCRIPTION_MASK_CARD),
+                                  NULL,
+                                  NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_subscribe() failed");
+                return;
+        }
+        pa_operation_unref (o);
+
+        req_update_server_info (control, -1);
+        req_update_card (control, -1);
+        req_update_client_info (control, -1);
+        req_update_sink_info (control, -1);
+        req_update_source_info (control, -1);
+        req_update_sink_input_info (control, -1);
+        req_update_source_output_info (control, -1);
+
+        control->priv->n_outstanding = 6;
+
+        /* This call is not always supported */
+        o = pa_ext_stream_restore_read (control->priv->pa_context,
+                                        _pa_ext_stream_restore_read_cb,
+                                        control);
+        if (o != NULL) {
+                pa_operation_unref (o);
+                control->priv->n_outstanding++;
+
+                pa_ext_stream_restore_set_subscribe_cb (control->priv->pa_context,
+                                                        _pa_ext_stream_restore_subscribe_cb,
+                                                        control);
+
+                o = pa_ext_stream_restore_subscribe (control->priv->pa_context,
+                                                     1,
+                                                     NULL,
+                                                     NULL);
+                if (o != NULL) {
+                        pa_operation_unref (o);
+                }
+
+        } else {
+                g_debug ("Failed to initialized stream_restore extension: %s",
+                         pa_strerror (pa_context_errno (control->priv->pa_context)));
+        }
+}
+
+static void
+gvc_mixer_new_pa_context (GvcMixerControl *self)
+{
+        pa_proplist     *proplist;
+
+        g_return_if_fail (self);
+        g_return_if_fail (!self->priv->pa_context);
+
+        proplist = pa_proplist_new ();
+        pa_proplist_sets (proplist,
+                          PA_PROP_APPLICATION_NAME,
+                          self->priv->name);
+        pa_proplist_sets (proplist,
+                          PA_PROP_APPLICATION_ID,
+                          "org.gnome.VolumeControl");
+        pa_proplist_sets (proplist,
+                          PA_PROP_APPLICATION_ICON_NAME,
+                          "multimedia-volume-control");
+        pa_proplist_sets (proplist,
+                          PA_PROP_APPLICATION_VERSION,
+                          PACKAGE_VERSION);
+
+        self->priv->pa_context = pa_context_new_with_proplist (self->priv->pa_api, NULL, proplist);
+
+        pa_proplist_free (proplist);
+        g_assert (self->priv->pa_context);
+}
+
+static void
+remove_all_streams (GvcMixerControl *control, GHashTable *hash_table)
+{
+        GHashTableIter iter;
+        gpointer key, value;
+
+        g_hash_table_iter_init (&iter, hash_table);
+        while (g_hash_table_iter_next (&iter, &key, &value)) {
+                remove_stream (control, value);
+                g_hash_table_iter_remove (&iter);
+        }
+}
+
+static gboolean
+idle_reconnect (gpointer data)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (data);
+        GHashTableIter iter;
+        gpointer key, value;
+
+        g_return_val_if_fail (control, FALSE);
+
+        if (control->priv->pa_context) {
+                pa_context_unref (control->priv->pa_context);
+                control->priv->pa_context = NULL;
+                gvc_mixer_new_pa_context (control);
+        }
+
+        remove_all_streams (control, control->priv->sinks);
+        remove_all_streams (control, control->priv->sources);
+        remove_all_streams (control, control->priv->sink_inputs);
+        remove_all_streams (control, control->priv->source_outputs);
+
+        g_hash_table_iter_init (&iter, control->priv->clients);
+        while (g_hash_table_iter_next (&iter, &key, &value))
+                g_hash_table_iter_remove (&iter);
+
+        gvc_mixer_control_open (control); /* cannot fail */
+
+        control->priv->reconnect_id = 0;
+        return FALSE;
+}
+
+static void
+_pa_context_state_cb (pa_context *context,
+                      void       *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        switch (pa_context_get_state (context)) {
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+                break;
+
+        case PA_CONTEXT_READY:
+                gvc_mixer_control_ready (control);
+                break;
+
+        case PA_CONTEXT_FAILED:
+                control->priv->state = GVC_STATE_FAILED;
+                g_signal_emit (control, signals[STATE_CHANGED], 0, GVC_STATE_FAILED);
+                if (control->priv->reconnect_id == 0)
+                        control->priv->reconnect_id = g_timeout_add_seconds (RECONNECT_DELAY, idle_reconnect, control);
+                break;
+
+        case PA_CONTEXT_TERMINATED:
+        default:
+                /* FIXME: */
+                break;
+        }
+}
+
+gboolean
+gvc_mixer_control_open (GvcMixerControl *control)
+{
+        int res;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+        g_return_val_if_fail (control->priv->pa_context != NULL, FALSE);
+        g_return_val_if_fail (pa_context_get_state (control->priv->pa_context) == PA_CONTEXT_UNCONNECTED, FALSE);
+
+        pa_context_set_state_callback (control->priv->pa_context,
+                                       _pa_context_state_cb,
+                                       control);
+
+        control->priv->state = GVC_STATE_CONNECTING;
+        g_signal_emit (G_OBJECT (control), signals[STATE_CHANGED], 0, GVC_STATE_CONNECTING);
+        res = pa_context_connect (control->priv->pa_context, NULL, (pa_context_flags_t) PA_CONTEXT_NOFAIL, NULL);
+        if (res < 0) {
+                g_warning ("Failed to connect context: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+        }
+
+        return res;
+}
+
+gboolean
+gvc_mixer_control_close (GvcMixerControl *control)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+        g_return_val_if_fail (control->priv->pa_context != NULL, FALSE);
+
+        pa_context_disconnect (control->priv->pa_context);
+
+        control->priv->state = GVC_STATE_CLOSED;
+        g_signal_emit (G_OBJECT (control), signals[STATE_CHANGED], 0, GVC_STATE_CLOSED);
+        return TRUE;
+}
+
+static void
+gvc_mixer_control_dispose (GObject *object)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (object);
+
+        if (control->priv->reconnect_id != 0) {
+                g_source_remove (control->priv->reconnect_id);
+                control->priv->reconnect_id = 0;
+        }
+
+        if (control->priv->pa_context != NULL) {
+                pa_context_unref (control->priv->pa_context);
+                control->priv->pa_context = NULL;
+        }
+
+        if (control->priv->default_source_name != NULL) {
+                g_free (control->priv->default_source_name);
+                control->priv->default_source_name = NULL;
+        }
+        if (control->priv->default_sink_name != NULL) {
+                g_free (control->priv->default_sink_name);
+                control->priv->default_sink_name = NULL;
+        }
+
+        if (control->priv->pa_mainloop != NULL) {
+                pa_glib_mainloop_free (control->priv->pa_mainloop);
+                control->priv->pa_mainloop = NULL;
+        }
+
+        if (control->priv->all_streams != NULL) {
+                g_hash_table_destroy (control->priv->all_streams);
+                control->priv->all_streams = NULL;
+        }
+
+        if (control->priv->sinks != NULL) {
+                g_hash_table_destroy (control->priv->sinks);
+                control->priv->sinks = NULL;
+        }
+        if (control->priv->sources != NULL) {
+                g_hash_table_destroy (control->priv->sources);
+                control->priv->sources = NULL;
+        }
+        if (control->priv->sink_inputs != NULL) {
+                g_hash_table_destroy (control->priv->sink_inputs);
+                control->priv->sink_inputs = NULL;
+        }
+        if (control->priv->source_outputs != NULL) {
+                g_hash_table_destroy (control->priv->source_outputs);
+                control->priv->source_outputs = NULL;
+        }
+        if (control->priv->clients != NULL) {
+                g_hash_table_destroy (control->priv->clients);
+                control->priv->clients = NULL;
+        }
+        if (control->priv->cards != NULL) {
+                g_hash_table_destroy (control->priv->cards);
+                control->priv->cards = NULL;
+        }
+        if (control->priv->ui_outputs != NULL) {
+                g_hash_table_destroy (control->priv->ui_outputs);
+                control->priv->ui_outputs = NULL;
+        }
+        if (control->priv->ui_inputs != NULL) {
+                g_hash_table_destroy (control->priv->ui_inputs);
+                control->priv->ui_inputs = NULL;
+        }
+        
+
+        G_OBJECT_CLASS (gvc_mixer_control_parent_class)->dispose (object);
+}
+
+static void
+gvc_mixer_control_set_property (GObject       *object,
+                                guint          prop_id,
+                                const GValue  *value,
+                                GParamSpec    *pspec)
+{
+        GvcMixerControl *self = GVC_MIXER_CONTROL (object);
+
+        switch (prop_id) {
+        case PROP_NAME:
+                g_free (self->priv->name);
+                self->priv->name = g_value_dup_string (value);
+                g_object_notify (G_OBJECT (self), "name");
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_control_get_property (GObject     *object,
+                                guint        prop_id,
+                                GValue      *value,
+                                GParamSpec  *pspec)
+{
+        GvcMixerControl *self = GVC_MIXER_CONTROL (object);
+
+        switch (prop_id) {
+        case PROP_NAME:
+                g_value_set_string (value, self->priv->name);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+
+static GObject *
+gvc_mixer_control_constructor (GType                  type,
+                               guint                  n_construct_properties,
+                               GObjectConstructParam *construct_params)
+{
+        GObject         *object;
+        GvcMixerControl *self;
+
+        object = G_OBJECT_CLASS (gvc_mixer_control_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_CONTROL (object);
+
+        gvc_mixer_new_pa_context (self);
+        self->priv->profile_swapping_device_id = GVC_MIXER_UI_DEVICE_INVALID;
+
+        return object;
+}
+
+static void
+gvc_mixer_control_class_init (GvcMixerControlClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_mixer_control_constructor;
+        object_class->dispose = gvc_mixer_control_dispose;
+        object_class->finalize = gvc_mixer_control_finalize;
+        object_class->set_property = gvc_mixer_control_set_property;
+        object_class->get_property = gvc_mixer_control_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_NAME,
+                                         g_param_spec_string ("name",
+                                                              "Name",
+                                                              "Name to display for this mixer control",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+
+        signals [STATE_CHANGED] =
+                g_signal_new ("state-changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, state_changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [STREAM_ADDED] =
+                g_signal_new ("stream-added",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, stream_added),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [STREAM_REMOVED] =
+                g_signal_new ("stream-removed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, stream_removed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [CARD_ADDED] =
+                g_signal_new ("card-added",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, card_added),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [CARD_REMOVED] =
+                g_signal_new ("card-removed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, card_removed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [DEFAULT_SINK_CHANGED] =
+                g_signal_new ("default-sink-changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, default_sink_changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [DEFAULT_SOURCE_CHANGED] =
+                g_signal_new ("default-source-changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, default_source_changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [OUTPUT_ADDED] =
+                g_signal_new ("output-added",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, output_added),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+
+        signals [ACTIVE_OUTPUT_UPDATE] =
+                g_signal_new ("active-output-update",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, active_output_update),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+
+        signals [OUTPUT_REMOVED] =
+                g_signal_new ("output-removed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, output_removed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [INPUT_ADDED] =
+                g_signal_new ("input-added",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, input_added),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [INPUT_REMOVED] =
+                g_signal_new ("input-removed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, input_removed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [ACTIVE_INPUT_UPDATE] =
+                g_signal_new ("active-input-update",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, active_input_update),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);                              
+        g_type_class_add_private (klass, sizeof (GvcMixerControlPrivate));
+}
+
+
+static void
+gvc_mixer_control_init (GvcMixerControl *control)
+{
+        control->priv = GVC_MIXER_CONTROL_GET_PRIVATE (control);
+
+        control->priv->pa_mainloop = pa_glib_mainloop_new (g_main_context_default ());
+        g_assert (control->priv->pa_mainloop);
+
+        control->priv->pa_api = pa_glib_mainloop_get_api (control->priv->pa_mainloop);
+        g_assert (control->priv->pa_api);
+
+        control->priv->all_streams = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->sinks = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->sources = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->sink_inputs = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->source_outputs = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->cards = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->ui_outputs = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->ui_inputs = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+
+        control->priv->clients = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_free);
+
+        control->priv->state = GVC_STATE_CLOSED;
+}
+
+static void
+gvc_mixer_control_finalize (GObject *object)
+{
+        GvcMixerControl *mixer_control;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_CONTROL (object));
+
+        mixer_control = GVC_MIXER_CONTROL (object);
+        g_free (mixer_control->priv->name);
+        mixer_control->priv->name = NULL;
+
+        g_return_if_fail (mixer_control->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_control_parent_class)->finalize (object);
+}
+
+GvcMixerControl *
+gvc_mixer_control_new (const char *name)
+{
+        GObject *control;
+        control = g_object_new (GVC_TYPE_MIXER_CONTROL,
+                                "name", name,
+                                NULL);
+        return GVC_MIXER_CONTROL (control);
+}
+
+/* FIXME: Remove when PA 0.9.23 is used */
+#ifndef PA_VOLUME_UI_MAX
+#define PA_VOLUME_UI_MAX pa_sw_volume_from_dB(+11.0)
+#endif
+
+gdouble
+gvc_mixer_control_get_vol_max_norm (GvcMixerControl *control)
+{
+	return (gdouble) PA_VOLUME_NORM;
+}
+
+gdouble
+gvc_mixer_control_get_vol_max_amplified (GvcMixerControl *control)
+{
+	return (gdouble) PA_VOLUME_UI_MAX;
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-control.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-control.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-control.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-control.h	2012-09-28 19:08:52.486641705 -0400
@@ -0,0 +1,139 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_CONTROL_H
+#define __GVC_MIXER_CONTROL_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+#include "gvc-mixer-card.h"
+#include "gvc-mixer-ui-device.h"
+
+G_BEGIN_DECLS
+
+typedef enum
+{
+        GVC_STATE_CLOSED,
+        GVC_STATE_READY,
+        GVC_STATE_CONNECTING,
+        GVC_STATE_FAILED
+} GvcMixerControlState;
+
+#define GVC_TYPE_MIXER_CONTROL         (gvc_mixer_control_get_type ())
+#define GVC_MIXER_CONTROL(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_CONTROL, GvcMixerControl))
+#define GVC_MIXER_CONTROL_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_CONTROL, GvcMixerControlClass))
+#define GVC_IS_MIXER_CONTROL(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_CONTROL))
+#define GVC_IS_MIXER_CONTROL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_CONTROL))
+#define GVC_MIXER_CONTROL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_CONTROL, GvcMixerControlClass))
+
+typedef struct GvcMixerControlPrivate GvcMixerControlPrivate;
+
+typedef struct
+{
+        GObject                 parent;
+        GvcMixerControlPrivate *priv;
+} GvcMixerControl;
+
+typedef struct
+{
+        GObjectClass            parent_class;
+
+        void (*state_changed)          (GvcMixerControl      *control,
+                                        GvcMixerControlState  new_state);
+        void (*stream_added)           (GvcMixerControl *control,
+                                        guint            id);
+        void (*stream_removed)         (GvcMixerControl *control,
+                                        guint            id);
+        void (*card_added)             (GvcMixerControl *control,
+                                        guint            id);
+        void (*card_removed)           (GvcMixerControl *control,
+                                        guint            id);
+        void (*default_sink_changed)   (GvcMixerControl *control,
+                                        guint            id);
+        void (*default_source_changed) (GvcMixerControl *control,
+                                        guint            id);
+        void (*output_added)           (GvcMixerControl *control,
+                                        guint            id);
+        void (*output_removed)         (GvcMixerControl *control,
+                                        guint            id);
+        void (*active_output_update)   (GvcMixerControl *control,
+                                        guint            id);
+        void (*active_input_update)    (GvcMixerControl *control,
+                                        guint            id);
+        void (*input_added)            (GvcMixerControl *control,
+                                        guint            id);
+        void (*input_removed)          (GvcMixerControl *control,
+                                        guint            id);
+                                        
+} GvcMixerControlClass;
+
+GType               gvc_mixer_control_get_type            (void);
+
+GvcMixerControl *   gvc_mixer_control_new                 (const char *name);
+
+gboolean            gvc_mixer_control_open                (GvcMixerControl *control);
+gboolean            gvc_mixer_control_close               (GvcMixerControl *control);
+
+GSList *            gvc_mixer_control_get_cards           (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_streams         (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_sinks           (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_sources         (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_sink_inputs     (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_source_outputs  (GvcMixerControl *control);
+
+GvcMixerStream *        gvc_mixer_control_lookup_stream_id    (GvcMixerControl *control,
+                                                           guint            id);
+GvcMixerCard   *        gvc_mixer_control_lookup_card_id      (GvcMixerControl *control,
+                                                           guint            id);
+GvcMixerUIDevice *      gvc_mixer_control_lookup_output_id    (GvcMixerControl *control,
+                                                           guint            id);	                                                               
+GvcMixerUIDevice *      gvc_mixer_control_lookup_input_id    (GvcMixerControl *control,
+                                                          guint            id);	                                                               
+
+GvcMixerStream *        gvc_mixer_control_get_default_sink     (GvcMixerControl *control);
+GvcMixerStream *        gvc_mixer_control_get_default_source   (GvcMixerControl *control);
+GvcMixerStream *        gvc_mixer_control_get_event_sink_input (GvcMixerControl *control);
+
+gboolean                gvc_mixer_control_set_default_sink     (GvcMixerControl *control,
+                                                            GvcMixerStream  *stream);
+gboolean                gvc_mixer_control_set_default_source   (GvcMixerControl *control,
+                                                            GvcMixerStream  *stream);
+
+gdouble                 gvc_mixer_control_get_vol_max_norm      (GvcMixerControl *control);
+gdouble                 gvc_mixer_control_get_vol_max_amplified (GvcMixerControl *control);
+void                    gvc_mixer_control_change_output         (GvcMixerControl *control,
+                                                                 GvcMixerUIDevice* output);
+void                    gvc_mixer_control_change_input          (GvcMixerControl *control,
+                                                                 GvcMixerUIDevice* input);
+const gchar*            gvc_mixer_control_get_active_profile_from_ui_device (GvcMixerControl* control,
+                                                                             GvcMixerUIDevice* device);
+GvcMixerStream*         gvc_mixer_control_get_stream_from_device (GvcMixerControl *control,
+                                                                  GvcMixerUIDevice *dev);
+gboolean                gvc_mixer_control_change_profile_on_selected_device (GvcMixerControl *control,
+                                                                             GvcMixerUIDevice *device,
+                                                                             const gchar* profile);
+
+
+GvcMixerControlState gvc_mixer_control_get_state            (GvcMixerControl *control);
+
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_CONTROL_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-control-private.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-control-private.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-control-private.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-control-private.h	2012-09-28 19:08:52.487641703 -0400
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_CONTROL_PRIVATE_H
+#define __GVC_MIXER_CONTROL_PRIVATE_H
+
+#include <glib-object.h>
+#include <pulse/pulseaudio.h>
+#include "gvc-mixer-stream.h"
+#include "gvc-mixer-card.h"
+
+G_BEGIN_DECLS
+
+pa_context *        gvc_mixer_control_get_pa_context      (GvcMixerControl *control);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_CONTROL_PRIVATE_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-dialog.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-dialog.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-dialog.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-dialog.c	2012-09-28 19:08:52.489641704 -0400
@@ -0,0 +1,2203 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ * Copyright (C) 2012 Conor Curran
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <math.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtk.h>
+#include <pulse/pulseaudio.h>
+
+
+#include "gvc-channel-bar.h"
+#include "gvc-balance-bar.h"
+#include "gvc-combo-box.h"
+#include "gvc-mixer-control.h"
+#include "gvc-mixer-card.h"
+#include "gvc-mixer-ui-device.h"
+#include "gvc-mixer-sink.h"
+#include "gvc-mixer-source.h"
+#include "gvc-mixer-source-output.h"
+#include "gvc-mixer-dialog.h"
+#include "gvc-sound-theme-chooser.h"
+#include "gvc-level-bar.h"
+#include "gvc-speaker-test.h"
+#include "gvc-mixer-control-private.h"
+
+#define SCALE_SIZE 128
+
+#define GVC_MIXER_DIALOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_DIALOG, GvcMixerDialogPrivate))
+
+struct GvcMixerDialogPrivate
+{
+        GvcMixerControl *mixer_control;
+        GHashTable      *bars;        
+        GtkWidget       *notebook;
+        GtkWidget       *output_bar;
+        GtkWidget       *input_bar;
+        GtkWidget       *input_level_bar;
+        GtkWidget       *effects_bar;
+        GtkWidget       *output_stream_box;
+        GtkWidget       *sound_effects_box;
+        GtkWidget       *hw_box;
+        GtkWidget       *hw_treeview;
+        GtkWidget       *hw_settings_box;
+        GtkWidget       *hw_profile_combo;
+        GtkWidget       *input_box;
+        GtkWidget       *output_box;
+        GtkWidget       *applications_box;
+        GtkWidget       *no_apps_label;
+        GtkWidget       *output_treeview;
+        GtkWidget       *output_settings_box;
+        GtkWidget       *output_balance_bar;
+        GtkWidget       *output_fade_bar;
+        GtkWidget       *output_lfe_bar;
+        GtkWidget       *output_profile_combo;
+        GtkWidget       *input_profile_combo;
+        GtkWidget       *input_treeview;
+        GtkWidget       *input_settings_box;
+        GtkWidget       *sound_theme_chooser;
+        GtkWidget       *click_feedback_button;
+        GtkWidget       *audible_bell_button;
+        GtkSizeGroup    *size_group;
+        GtkWidget       *selected_output_label;
+        GtkWidget       *selected_input_label;
+        GtkWidget       *test_output_button;
+        GSettings       *indicator_settings;
+
+        gdouble          last_input_peak;
+        guint            num_apps;
+};
+
+enum {
+        NAME_COLUMN,
+        DEVICE_COLUMN,
+        ACTIVE_COLUMN,
+        ID_COLUMN,
+        SPEAKERS_COLUMN,
+        ICON_COLUMN,
+        NUM_COLUMNS
+};
+
+enum {
+        HW_ID_COLUMN,
+        HW_ICON_COLUMN,
+        HW_NAME_COLUMN,
+        HW_STATUS_COLUMN,
+        HW_PROFILE_COLUMN,
+        HW_PROFILE_HUMAN_COLUMN,
+        HW_SENSITIVE_COLUMN,
+        HW_NUM_COLUMNS
+};
+
+enum
+{
+        PROP_0,
+        PROP_MIXER_CONTROL
+};
+
+static void     gvc_mixer_dialog_class_init (GvcMixerDialogClass *klass);
+static void     gvc_mixer_dialog_init       (GvcMixerDialog      *mixer_dialog);
+static void     gvc_mixer_dialog_finalize   (GObject             *object);
+
+static void     bar_set_stream              (GvcMixerDialog      *dialog,
+                                             GtkWidget           *bar,
+                                             GvcMixerStream      *stream);
+
+static void     on_adjustment_value_changed (GtkAdjustment  *adjustment,
+                                             GvcMixerDialog *dialog);
+static void  	on_control_output_added (GvcMixerControl *control,
+                                       guint            id,
+                                       GvcMixerDialog  *dialog);
+static void   on_control_active_output_update (GvcMixerControl *control,
+                                               guint            id,
+                                               GvcMixerDialog  *dialog);
+                                       
+static void   on_control_active_input_update (GvcMixerControl *control,
+                                              guint            id,
+                                              GvcMixerDialog  *dialog);
+
+G_DEFINE_TYPE (GvcMixerDialog, gvc_mixer_dialog, GTK_TYPE_VBOX)
+
+
+static void
+update_description (GvcMixerDialog *dialog,
+                    guint column,
+                    const char *value,
+                    GvcMixerStream *stream)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        guint         id;
+
+        if (GVC_IS_MIXER_SOURCE (stream))
+                model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->input_treeview));
+        else if (GVC_IS_MIXER_SINK (stream))
+                model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        else
+                g_assert_not_reached ();
+
+        if (gtk_tree_model_get_iter_first (model, &iter) == FALSE){
+                g_warning ("The tree is empty => Cannot update the description");
+                return;        
+        }
+
+        id = gvc_mixer_stream_get_id (stream);
+        do {
+                guint       current_id;
+
+                gtk_tree_model_get (model, &iter,
+                                    ID_COLUMN, &current_id,
+                                    -1);
+                if (id != current_id)
+                        continue;
+
+                gtk_list_store_set (GTK_LIST_STORE (model),
+                                    &iter,
+                                    column, value,
+                                    -1);
+                break;
+        } while (gtk_tree_model_iter_next (model, &iter));
+}
+
+static void
+profile_selection_changed (GvcComboBox *combo_box,
+                           const char  *profile,
+                           GvcMixerDialog *dialog)
+{	
+        g_debug ("profile_selection_changed - %s", profile);
+        GvcMixerUIDevice *out;
+        out = g_object_get_data (G_OBJECT (combo_box), "uidevice");
+        
+        if (out == NULL) {
+                g_warning ("Could not find Output for profile combo box");
+                return;
+        }
+
+        g_debug (" \n on profile selection changed on output with \n description %s \n origin %s \n id %i \n \n",
+                gvc_mixer_ui_device_get_description (out),
+                gvc_mixer_ui_device_get_origin (out),
+                gvc_mixer_ui_device_get_id (out));
+
+        if (gvc_mixer_control_change_profile_on_selected_device (dialog->priv->mixer_control, out, profile) == FALSE) {
+                g_warning ("Could not change profile on device %s",
+                           gvc_mixer_ui_device_get_description (out));
+        }
+}
+
+#define DECAY_STEP .15
+
+static void
+update_input_peak (GvcMixerDialog *dialog,
+                   gdouble         v)
+{
+        GtkAdjustment *adj;
+
+        if (dialog->priv->last_input_peak >= DECAY_STEP) {
+                if (v < dialog->priv->last_input_peak - DECAY_STEP) {
+                        v = dialog->priv->last_input_peak - DECAY_STEP;
+                }
+        }
+
+        dialog->priv->last_input_peak = v;
+
+        adj = gvc_level_bar_get_peak_adjustment (GVC_LEVEL_BAR (dialog->priv->input_level_bar));
+        if (v >= 0) {
+                gtk_adjustment_set_value (adj, v);
+        } else {
+                gtk_adjustment_set_value (adj, 0.0);
+        }
+}
+
+static void
+update_input_meter (GvcMixerDialog *dialog,
+                    uint32_t        source_index,
+                    uint32_t        sink_input_idx,
+                    double          v)
+{
+        update_input_peak (dialog, v);
+}
+
+static void
+on_monitor_suspended_callback (pa_stream *s,
+                               void      *userdata)
+{
+        GvcMixerDialog *dialog;
+
+        dialog = userdata;
+
+        if (pa_stream_is_suspended (s)) {
+                g_debug ("Stream suspended");
+                update_input_meter (dialog,
+                                    pa_stream_get_device_index (s),
+                                    PA_INVALID_INDEX,
+                                    -1);
+        }
+}
+
+static void
+on_monitor_read_callback (pa_stream *s,
+                          size_t     length,
+                          void      *userdata)
+{
+        GvcMixerDialog *dialog;
+        const void     *data;
+        double          v;
+
+        dialog = userdata;
+
+        if (pa_stream_peek (s, &data, &length) < 0) {
+                g_warning ("Failed to read data from stream");
+                return;
+        }
+
+        assert (length > 0);
+        assert (length % sizeof (float) == 0);
+
+        v = ((const float *) data)[length / sizeof (float) -1];
+
+        pa_stream_drop (s);
+
+        if (v < 0) {
+                v = 0;
+        }
+        if (v > 1) {
+                v = 1;
+        }
+
+        update_input_meter (dialog,
+                            pa_stream_get_device_index (s),
+                            pa_stream_get_monitor_stream (s),
+                            v);
+}
+
+static void
+create_monitor_stream_for_source (GvcMixerDialog *dialog,
+                                  GvcMixerStream *stream)
+{
+        pa_stream     *s;
+        char           t[16];
+        pa_buffer_attr attr;
+        pa_sample_spec ss;
+        pa_context    *context;
+        int            res;
+        pa_proplist   *proplist;
+        gboolean       has_monitor;
+
+        if (stream == NULL) {
+                g_debug ("\n create_monitor_stream_for_source - stream is null - returning\n");
+                return;
+        }
+        has_monitor = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (stream), "has-monitor"));
+        if (has_monitor != FALSE) {
+                g_debug ("\n create_monitor_stream_for_source, has monitor is not false - returning \n");
+                return;
+        }
+
+        g_debug ("Create monitor for %u",
+                 gvc_mixer_stream_get_index (stream));
+
+        context = gvc_mixer_control_get_pa_context (dialog->priv->mixer_control);
+
+        if (pa_context_get_server_protocol_version (context) < 13) {
+                g_debug ("\n create_monitor_stream_for_source - protocol version is less 13 \n");
+                return;
+        }
+
+        ss.channels = 1;
+        ss.format = PA_SAMPLE_FLOAT32;
+        ss.rate = 25;
+
+        memset (&attr, 0, sizeof (attr));
+        attr.fragsize = sizeof (float);
+        attr.maxlength = (uint32_t) -1;
+
+        snprintf (t, sizeof (t), "%u", gvc_mixer_stream_get_index (stream));
+
+        proplist = pa_proplist_new ();
+        pa_proplist_sets (proplist, PA_PROP_APPLICATION_ID, "org.gnome.VolumeControl");
+        s = pa_stream_new_with_proplist (context, _("Peak detect"), &ss, NULL, proplist);
+        pa_proplist_free (proplist);
+        if (s == NULL) {
+                g_warning ("Failed to create monitoring stream");
+                return;
+        }
+
+        pa_stream_set_read_callback (s, on_monitor_read_callback, dialog);
+        pa_stream_set_suspended_callback (s, on_monitor_suspended_callback, dialog);
+
+        res = pa_stream_connect_record (s,
+                                        t,
+                                        &attr,
+                                        (pa_stream_flags_t) (PA_STREAM_DONT_MOVE
+                                                             |PA_STREAM_PEAK_DETECT
+                                                             |PA_STREAM_ADJUST_LATENCY));
+        if (res < 0) {
+                g_warning ("Failed to connect monitoring stream");
+                pa_stream_unref (s);
+        } else {
+                g_object_set_data (G_OBJECT (stream), "has-monitor", GINT_TO_POINTER (TRUE));
+                g_object_set_data (G_OBJECT (dialog->priv->input_level_bar), "pa_stream", s);
+                g_object_set_data (G_OBJECT (dialog->priv->input_level_bar), "stream", stream);
+        }
+}
+
+
+static void
+stop_monitor_stream_for_source (GvcMixerDialog *dialog)
+{
+        pa_stream      *s;
+        pa_context     *context;
+        int             res;
+        GvcMixerStream *stream;
+
+        stream = g_object_get_data (G_OBJECT (dialog->priv->input_level_bar), "stream");
+
+        if (stream == NULL){
+                g_debug ("\n stop_monitor_stream_for_source - gvcstream is null - returning \n");                
+                return;
+        }
+        else{
+                g_debug ("\n stop_monitor_stream_for_source - gvcstream is not null - continue \n");                                
+        }
+
+        s = g_object_get_data (G_OBJECT (dialog->priv->input_level_bar), "pa_stream");
+
+        if (s != NULL){
+                res = pa_stream_disconnect (s);
+                if (res == 0) {
+                        g_debug("stream has been disconnected");
+                        pa_stream_unref (s);
+                }
+                g_object_set_data (G_OBJECT (dialog->priv->input_level_bar), "pa_stream", NULL);        
+        }
+                
+        context = gvc_mixer_control_get_pa_context (dialog->priv->mixer_control);
+
+        if (pa_context_get_server_protocol_version (context) < 13) {
+                return;
+        }
+        if (res == 0) {
+                g_object_set_data (G_OBJECT (stream), "has-monitor", GINT_TO_POINTER (FALSE));
+        }
+        g_debug ("Stopping monitor for %u", pa_stream_get_index (s));
+        g_object_set_data (G_OBJECT (dialog->priv->input_level_bar), "stream", NULL);
+}
+
+static void
+gvc_mixer_dialog_set_mixer_control (GvcMixerDialog  *dialog,
+                                    GvcMixerControl *control)
+{
+        g_return_if_fail (GVC_MIXER_DIALOG (dialog));
+        g_return_if_fail (GVC_IS_MIXER_CONTROL (control));
+
+        g_object_ref (control);
+
+        if (dialog->priv->mixer_control != NULL) {
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      G_CALLBACK (on_control_active_output_update),
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      G_CALLBACK (on_control_active_input_update),
+                                                      dialog);
+                g_object_unref (dialog->priv->mixer_control);
+        }
+
+        dialog->priv->mixer_control = control;
+
+        g_signal_connect (dialog->priv->mixer_control,
+                          "active-output-update",
+                          G_CALLBACK (on_control_active_output_update),
+                          dialog);
+        g_signal_connect (dialog->priv->mixer_control,
+                          "active-input-update",
+                          G_CALLBACK (on_control_active_input_update),
+                          dialog);
+
+        g_object_notify (G_OBJECT (dialog), "mixer-control");
+}
+
+static GvcMixerControl *
+gvc_mixer_dialog_get_mixer_control (GvcMixerDialog *dialog)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_DIALOG (dialog), NULL);
+
+        return dialog->priv->mixer_control;
+}
+
+static void
+gvc_mixer_dialog_set_property (GObject       *object,
+                               guint          prop_id,
+                               const GValue  *value,
+                               GParamSpec    *pspec)
+{
+        GvcMixerDialog *self = GVC_MIXER_DIALOG (object);
+
+        switch (prop_id) {
+        case PROP_MIXER_CONTROL:
+                gvc_mixer_dialog_set_mixer_control (self, g_value_get_object (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_dialog_get_property (GObject     *object,
+                               guint        prop_id,
+                               GValue      *value,
+                               GParamSpec  *pspec)
+{
+        GvcMixerDialog *self = GVC_MIXER_DIALOG (object);
+
+        switch (prop_id) {
+        case PROP_MIXER_CONTROL:
+                g_value_set_object (value, gvc_mixer_dialog_get_mixer_control (self));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+on_adjustment_value_changed (GtkAdjustment  *adjustment,
+                             GvcMixerDialog *dialog)
+{
+        GvcMixerStream *stream;
+
+        stream = g_object_get_data (G_OBJECT (adjustment), "gvc-mixer-dialog-stream");
+        if (stream != NULL) {
+                GObject *bar;
+                gdouble volume, rounded;
+                char *name;
+
+                volume = gtk_adjustment_get_value (adjustment);
+                rounded = round (volume);
+
+                bar = g_object_get_data (G_OBJECT (adjustment), "gvc-mixer-dialog-bar");
+                g_object_get (bar, "name", &name, NULL);
+                g_debug ("Setting stream volume %lf (rounded: %lf) for bar '%s'", volume, rounded, name);
+                g_free (name);
+
+                /* FIXME would need to do that in the balance bar really... */
+                /* Make sure we do not unmute muted streams, there's a button for that */
+                if (volume == 0.0)
+                        gvc_mixer_stream_set_is_muted (stream, TRUE);
+                /* Only push the volume if it's actually changed */
+                if (gvc_mixer_stream_set_volume(stream, (pa_volume_t) rounded) != FALSE)
+                        gvc_mixer_stream_push_volume (stream);
+        }
+}
+
+static void
+on_bar_is_muted_notify (GObject        *object,
+                        GParamSpec     *pspec,
+                        GvcMixerDialog *dialog)
+{
+        gboolean        is_muted;
+        GvcMixerStream *stream;
+
+        is_muted = gvc_channel_bar_get_is_muted (GVC_CHANNEL_BAR (object));
+
+        stream = g_object_get_data (object, "gvc-mixer-dialog-stream");
+        if (stream != NULL) {
+                gvc_mixer_stream_change_is_muted (stream, is_muted);
+        } else {
+                char *name;
+                g_object_get (object, "name", &name, NULL);
+                g_warning ("Unable to find stream for bar '%s'", name);
+                g_free (name);
+        }
+}
+
+static GtkWidget *
+lookup_bar_for_stream (GvcMixerDialog *dialog,
+                       GvcMixerStream *stream)
+{
+        GtkWidget *bar;
+
+        bar = g_hash_table_lookup (dialog->priv->bars, GUINT_TO_POINTER (gvc_mixer_stream_get_id (stream)));
+
+        return bar;
+}
+
+// TODO
+// Do we need this ?
+// UI devices now pull description material mainly for the card ports.
+// Therefore the need for stream description dynamic changes more than ever seems unneccessary. 
+static void
+on_stream_description_notify (GvcMixerStream *stream,
+                              GParamSpec     *pspec,
+                              GvcMixerDialog *dialog)
+{
+        update_description (dialog, NAME_COLUMN,
+                            gvc_mixer_stream_get_description (stream),
+                            stream);
+}
+
+static void
+on_stream_volume_notify (GObject        *object,
+                         GParamSpec     *pspec,
+                         GvcMixerDialog *dialog)
+{
+        GvcMixerStream *stream;
+        GtkWidget      *bar;
+        GtkAdjustment  *adj;
+        stream = GVC_MIXER_STREAM (object);
+
+        bar = lookup_bar_for_stream (dialog, stream);
+
+        if (bar == NULL) {
+                if (stream == gvc_mixer_control_get_default_sink(dialog->priv->mixer_control)) {
+                        bar = dialog->priv->output_bar;
+                }
+                else if(stream == gvc_mixer_control_get_default_source(dialog->priv->mixer_control)) {
+                        bar = dialog->priv->input_bar;
+                }
+                else{
+                        g_warning ("Unable to find bar for stream %s in on_stream_volume_notify()",
+                                   gvc_mixer_stream_get_name (stream));
+                        return;
+                }
+        }
+
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (bar)));
+
+        g_signal_handlers_block_by_func (adj,
+                                         on_adjustment_value_changed,
+                                         dialog);
+
+        gtk_adjustment_set_value (adj,
+                                  gvc_mixer_stream_get_volume (stream));
+
+        g_signal_handlers_unblock_by_func (adj,
+                                           on_adjustment_value_changed,
+                                           dialog);
+}
+
+static void
+on_stream_is_muted_notify (GObject        *object,
+                           GParamSpec     *pspec,
+                           GvcMixerDialog *dialog)
+{
+        GvcMixerStream *stream;
+        GtkWidget      *bar;
+        gboolean        is_muted;
+
+        stream = GVC_MIXER_STREAM (object);
+
+        bar = lookup_bar_for_stream (dialog, stream);
+
+        if (bar == NULL) {
+                if (stream == gvc_mixer_control_get_default_sink(dialog->priv->mixer_control)) {
+                        bar = dialog->priv->output_bar;
+                }
+                else if(stream == gvc_mixer_control_get_default_source(dialog->priv->mixer_control)) {
+                        bar = dialog->priv->input_bar;
+                }                
+                else{
+                        g_warning ("Unable to find bar for stream %s in on_stream_muted_notify()",
+                                   gvc_mixer_stream_get_name (stream));
+                        return;
+                }
+        }
+
+
+        is_muted = gvc_mixer_stream_get_is_muted (stream);
+        gvc_channel_bar_set_is_muted (GVC_CHANNEL_BAR (bar),
+                                      is_muted);
+
+        if (stream == gvc_mixer_control_get_default_sink (dialog->priv->mixer_control)) {
+                gtk_widget_set_sensitive (dialog->priv->applications_box,
+                                          !is_muted);
+        }
+
+}
+
+static void
+save_bar_for_stream (GvcMixerDialog *dialog,
+                     GvcMixerStream *stream,
+                     GtkWidget      *bar)
+{
+        g_debug ("\n saving bar for stream %s",
+                 gvc_mixer_stream_get_name (stream));
+        g_hash_table_insert (dialog->priv->bars,
+                             GUINT_TO_POINTER (gvc_mixer_stream_get_id (stream)),
+                             bar);
+}
+
+static GtkWidget *
+create_bar (GvcMixerDialog *dialog,
+            gboolean        add_to_size_group,
+            gboolean        symmetric)
+{
+        GtkWidget *bar;
+
+        bar = gvc_channel_bar_new ();
+        gtk_widget_set_sensitive (bar, FALSE);
+        if (add_to_size_group && dialog->priv->size_group != NULL) {
+                gvc_channel_bar_set_size_group (GVC_CHANNEL_BAR (bar),
+                                                dialog->priv->size_group,
+                                                symmetric);
+        }
+        gvc_channel_bar_set_orientation (GVC_CHANNEL_BAR (bar),
+                                         GTK_ORIENTATION_HORIZONTAL);
+        gvc_channel_bar_set_show_mute (GVC_CHANNEL_BAR (bar),
+                                       TRUE);
+        g_signal_connect (bar,
+                          "notify::is-muted",
+                          G_CALLBACK (on_bar_is_muted_notify),
+                          dialog);
+        return bar;
+}
+
+static GtkWidget *
+create_app_bar (GvcMixerDialog *dialog,
+                const char     *name,
+                const char     *icon_name)
+{
+        GtkWidget *bar;
+
+        bar = create_bar (dialog, FALSE, FALSE);
+        gvc_channel_bar_set_ellipsize (GVC_CHANNEL_BAR (bar), TRUE);
+        gvc_channel_bar_set_icon_name (GVC_CHANNEL_BAR (bar), icon_name);
+        if (name == NULL || strchr (name, '_') == NULL) {
+                gvc_channel_bar_set_name (GVC_CHANNEL_BAR (bar), name);
+        } else {
+                char **tokens, *escaped;
+
+                tokens = g_strsplit (name, "_", -1);
+                escaped = g_strjoinv ("__", tokens);
+                g_strfreev (tokens);
+                gvc_channel_bar_set_name (GVC_CHANNEL_BAR (bar), escaped);
+                g_free (escaped);
+        }
+
+        return bar;
+}
+
+static gint test_it = 0;
+
+/* active_input_update
+ * Handle input update change from the backend (control). 
+ * Trust the backend whole-heartedly to deliver the correct input
+ * i.e. keep it MVC.
+ */
+static void
+active_input_update (GvcMixerDialog *dialog,
+                     GvcMixerUIDevice *active_input)
+{         
+        g_debug ("\n active_input_update %s \n", gvc_mixer_ui_device_get_description (active_input));
+        // First make sure the correct UI device is selected.
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->input_treeview));
+
+        if (gtk_tree_model_get_iter_first (model, &iter) == FALSE){
+                g_warning ("The tree is empty => we have no devices so cannot set the active input");
+                return;        
+        }
+        
+        do {
+                gboolean         is_selected = FALSE;
+                gint             id;
+                        
+                gtk_tree_model_get (model, &iter,
+                                    ID_COLUMN, &id,
+                                    -1);
+
+                is_selected = id == gvc_mixer_ui_device_get_id (active_input);
+                
+                gtk_list_store_set (GTK_LIST_STORE (model),
+                                    &iter,
+                                    ACTIVE_COLUMN, is_selected,
+                                    -1);
+
+                if (is_selected) {
+                        GtkTreeSelection *selection;
+                        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->priv->input_treeview));
+                        gtk_tree_selection_select_iter (selection, &iter);
+                }
+                
+        }while (gtk_tree_model_iter_next (model, &iter));
+
+
+          // Not ideal but for now destroy the combo and recreate below.
+        if (dialog->priv->input_profile_combo != NULL) {
+                gtk_container_remove (GTK_CONTAINER (dialog->priv->input_settings_box),
+                                      dialog->priv->input_profile_combo);
+                dialog->priv->input_profile_combo = NULL;
+        }
+
+        GvcMixerStream       *stream;  
+        const GvcChannelMap  *map;
+        GtkAdjustment        *adj;
+  
+        stream = gvc_mixer_control_get_stream_from_device (dialog->priv->mixer_control, 
+                                                           active_input); 
+        if (stream == NULL) {
+                g_warning ("active_input_update - couldn't find a stream from the supposed active input");
+                gtk_widget_set_sensitive (dialog->priv->input_bar, 
+                                          FALSE);                
+                return;
+        }
+
+        // Set the label accordingly
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (dialog->priv->input_bar)));
+        g_signal_handlers_disconnect_by_func(adj, on_adjustment_value_changed, dialog);
+
+        gtk_label_set_label (GTK_LABEL(dialog->priv->selected_input_label),
+                             g_strdup_printf(_("Settings for %s"),
+                                             gvc_mixer_ui_device_get_description (active_input)));  
+
+        gvc_channel_bar_set_base_volume (GVC_CHANNEL_BAR (dialog->priv->input_bar),
+                                         gvc_mixer_stream_get_base_volume (stream));
+        gvc_channel_bar_set_is_amplified (GVC_CHANNEL_BAR (dialog->priv->input_bar),
+                                          gvc_mixer_stream_get_can_decibel (stream));
+        /* Update the adjustment in case the previous bar wasn't decibel
+         * capable, and we clipped it */
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (dialog->priv->input_bar)));
+        gtk_adjustment_set_value (adj,
+                                  gvc_mixer_stream_get_volume (stream));        
+        
+        stop_monitor_stream_for_source (dialog);
+        //if (test_it < 6){
+        create_monitor_stream_for_source (dialog, stream);
+        test_it += 1;
+        //}
+        bar_set_stream (dialog, dialog->priv->input_bar, stream);   
+        // remove any previous stream that might have been pointed at 
+        // the static input bar and connect new signals from new stream.
+
+        const GHashTable *profs_entries;
+        profs_entries = gvc_mixer_ui_device_get_profiles (active_input);
+
+        const GList* profiles = NULL;
+        profiles = g_hash_table_get_values (profs_entries);
+
+        if (profiles != NULL && !gvc_mixer_ui_device_should_profiles_be_hidden (active_input)){
+                const gchar *active_profile;
+                dialog->priv->input_profile_combo = gvc_combo_box_new (_("Mode:"));                
+                gvc_combo_box_set_profiles (GVC_COMBO_BOX (dialog->priv->input_profile_combo),
+                                            profs_entries);
+                                
+                active_profile = gvc_mixer_control_get_active_profile_from_ui_device (dialog->priv->mixer_control,
+                                                                                       active_input);
+                if (active_profile)
+                        gvc_combo_box_set_active (GVC_COMBO_BOX (dialog->priv->input_profile_combo), active_profile);
+
+                g_object_set_data (G_OBJECT (dialog->priv->input_profile_combo),
+                                   "uidevice",
+                                   active_input);
+
+                g_signal_connect (G_OBJECT (dialog->priv->input_profile_combo), "changed",
+                                  G_CALLBACK (profile_selection_changed), dialog);
+
+                gtk_box_pack_start (GTK_BOX (dialog->priv->input_settings_box),
+                                    dialog->priv->input_profile_combo,
+                                    TRUE, FALSE, 0);
+
+                if (dialog->priv->size_group != NULL) {
+                        gvc_combo_box_set_size_group (GVC_COMBO_BOX (dialog->priv->input_profile_combo),
+                                                      dialog->priv->size_group, FALSE);
+                }
+                gtk_widget_show (dialog->priv->input_profile_combo);                
+        }
+}
+
+/* active_output_update
+ * Handle output update change from the backend (control). 
+ * Trust the backend whole heartedly to deliver the correct output
+ * i.e. keep it MVC.
+ */
+static void
+active_output_update (GvcMixerDialog *dialog,
+                      GvcMixerUIDevice *active_output)
+{                 
+        // First make sure the correct UI device is selected.
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        g_debug ("\n\n active output update - device id = %i \n\n",
+                 gvc_mixer_ui_device_get_id (active_output));
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+
+        if (gtk_tree_model_get_iter_first (model, &iter) == FALSE){
+                g_warning ("The tree is empty => we have no devices in the tree => cannot set the active output");
+                return;        
+        }
+        
+        do {
+                gboolean         is_selected;
+                gint             id;
+                        
+                gtk_tree_model_get (model, &iter,
+                                    ID_COLUMN, &id,
+                                    ACTIVE_COLUMN, &is_selected,                  
+                                    -1);
+
+                if (is_selected && id == gvc_mixer_ui_device_get_id (active_output)) {
+                        g_debug ("\n\n unneccessary active output update unless it was a profile change on the same device ? \n\n");
+                }
+
+                is_selected = id == gvc_mixer_ui_device_get_id (active_output);
+                
+                gtk_list_store_set (GTK_LIST_STORE (model),
+                                    &iter,
+                                    ACTIVE_COLUMN, is_selected,
+                                    -1);
+
+                if (is_selected) {
+                        GtkTreeSelection *selection;
+                        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->priv->output_treeview));
+                        gtk_tree_selection_select_iter (selection, &iter);
+                }
+                
+        }while (gtk_tree_model_iter_next (model, &iter));
+        
+          // Not ideal but for now destroy the combo and recreate below.
+        if (dialog->priv->output_profile_combo != NULL) {
+                gtk_container_remove (GTK_CONTAINER (dialog->priv->output_settings_box),
+                                      dialog->priv->output_profile_combo);
+                dialog->priv->output_profile_combo = NULL;
+        }
+
+        GvcMixerStream       *stream;  
+        const GvcChannelMap  *map;
+        GtkAdjustment        *adj;
+  
+        stream = gvc_mixer_control_get_stream_from_device (dialog->priv->mixer_control, 
+                                                           active_output); 
+
+        if (stream == NULL) {
+                g_warning ("active_output_update - couldn't find a stream from the supposed active output");
+                return;
+        }
+
+        gboolean is_muted = gvc_mixer_stream_get_is_muted (stream);
+        gtk_widget_set_sensitive (dialog->priv->applications_box,
+                                  !is_muted);
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (dialog->priv->output_bar)));
+        g_signal_handlers_disconnect_by_func(adj, on_adjustment_value_changed, dialog);
+
+        bar_set_stream (dialog, dialog->priv->output_bar, stream);
+        gvc_channel_bar_set_base_volume (GVC_CHANNEL_BAR (dialog->priv->output_bar),
+                                         gvc_mixer_stream_get_base_volume (stream));
+        gvc_channel_bar_set_is_amplified (GVC_CHANNEL_BAR (dialog->priv->output_bar),
+                                          gvc_mixer_stream_get_can_decibel (stream));
+        /* Update the adjustment in case the previous bar wasn't decibel
+         * capable, and we clipped it */
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (dialog->priv->output_bar)));
+        gtk_adjustment_set_value (adj,
+                                  gvc_mixer_stream_get_volume (stream));
+
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        if (map == NULL) {
+                g_warning ("Active output stream has no channel map");
+                gtk_widget_set_sensitive (dialog->priv->output_bar, FALSE);
+                gtk_widget_set_sensitive (dialog->priv->output_balance_bar, FALSE);
+                gtk_widget_set_sensitive (dialog->priv->output_lfe_bar, FALSE);
+                gtk_widget_set_sensitive (dialog->priv->output_fade_bar, FALSE);                
+                return;
+        }
+
+
+        // Swap bars to the active map
+        gvc_balance_bar_set_map (GVC_BALANCE_BAR (dialog->priv->output_balance_bar), 
+                                 map);  
+        gvc_balance_bar_set_map (GVC_BALANCE_BAR (dialog->priv->output_fade_bar), 
+                                 map);
+        gvc_balance_bar_set_map (GVC_BALANCE_BAR (dialog->priv->output_lfe_bar), 
+                                 map);
+                           
+        // Set sensitivities accordingly.
+        gtk_widget_set_sensitive (dialog->priv->output_balance_bar,
+                                  gvc_channel_map_can_balance (map));                                    
+        gtk_widget_set_sensitive (dialog->priv->output_fade_bar, 
+                                  gvc_channel_map_can_fade (map));
+        gtk_widget_set_sensitive (dialog->priv->output_lfe_bar, 
+                                  gvc_channel_map_has_lfe (map));
+        gtk_widget_set_sensitive (dialog->priv->output_bar, 
+                                  TRUE);
+        // Set the label accordingly
+	gtk_label_set_label (GTK_LABEL(dialog->priv->selected_output_label),
+			     g_strdup_printf(_("Settings for %s"),
+                                             gvc_mixer_ui_device_get_description (active_output)));
+        g_debug ("\n active_output_update %s \n", gvc_mixer_ui_device_get_description (active_output));
+
+        const GHashTable *profs_entries;
+        profs_entries = gvc_mixer_ui_device_get_profiles (active_output);
+
+        GList* profiles = NULL;
+        profiles = g_hash_table_get_values (profs_entries);
+
+        if (profiles != NULL && !gvc_mixer_ui_device_should_profiles_be_hidden (active_output)) {
+                const gchar *active_profile;
+
+                dialog->priv->output_profile_combo = gvc_combo_box_new (_("Mode:"));                
+                gvc_combo_box_set_profiles (GVC_COMBO_BOX (dialog->priv->output_profile_combo),
+                                            profs_entries);
+                                
+                gtk_box_pack_start (GTK_BOX (dialog->priv->output_settings_box),
+                                    dialog->priv->output_profile_combo,
+                                    FALSE, FALSE, 3);
+
+                if (dialog->priv->size_group != NULL) {
+                        gvc_combo_box_set_size_group (GVC_COMBO_BOX (dialog->priv->output_profile_combo),
+                                                      dialog->priv->size_group, FALSE);
+                }
+
+                active_profile = gvc_mixer_control_get_active_profile_from_ui_device (dialog->priv->mixer_control,
+                                                                                       active_output);
+                if (active_profile)
+                        gvc_combo_box_set_active (GVC_COMBO_BOX (dialog->priv->output_profile_combo), active_profile);
+                                          
+                
+                g_object_set_data (G_OBJECT (dialog->priv->output_profile_combo),
+                                   "uidevice",
+                                   active_output);
+                g_signal_connect (G_OBJECT (dialog->priv->output_profile_combo), "changed",
+                                  G_CALLBACK (profile_selection_changed), dialog);
+
+                gtk_widget_show (dialog->priv->output_profile_combo);                
+        }
+
+}
+
+static void
+bar_set_stream (GvcMixerDialog *dialog,
+                GtkWidget      *bar,
+                GvcMixerStream *stream)
+{
+        GtkAdjustment  *adj;
+
+        g_assert (bar != NULL);
+
+        gtk_widget_set_sensitive (bar, (stream != NULL));
+
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (bar)));
+        
+        g_signal_handlers_disconnect_by_func (adj, on_adjustment_value_changed, dialog);
+
+        g_object_set_data (G_OBJECT (bar), "gvc-mixer-dialog-stream", stream);
+        g_object_set_data (G_OBJECT (adj), "gvc-mixer-dialog-stream", stream);
+        g_object_set_data (G_OBJECT (adj), "gvc-mixer-dialog-bar", bar);
+
+        if (stream != NULL) {
+                gboolean is_muted;
+
+                is_muted = gvc_mixer_stream_get_is_muted (stream);
+                gvc_channel_bar_set_is_muted (GVC_CHANNEL_BAR (bar), is_muted);
+
+                gtk_adjustment_set_value (adj,
+                                          gvc_mixer_stream_get_volume (stream));
+                g_signal_connect (stream,
+                                  "notify::is-muted",
+                                  G_CALLBACK (on_stream_is_muted_notify),
+                                  dialog);
+                g_signal_connect (stream,
+                                  "notify::volume",
+                                  G_CALLBACK (on_stream_volume_notify),
+                                  dialog);
+                g_signal_connect (adj,
+                                  "value-changed",
+                                  G_CALLBACK (on_adjustment_value_changed),
+                                  dialog);
+        }
+}
+
+/**
+* This method handles all streams that are not an input or output
+* i.e. effects streams and application streams
+* TODO rename to truly reflect its usage. 
+**/
+static void
+add_stream (GvcMixerDialog *dialog,
+            GvcMixerStream *stream)
+{
+  
+        GtkWidget     *bar;
+        bar = NULL;
+
+        if (stream == gvc_mixer_control_get_event_sink_input (dialog->priv->mixer_control)) {
+                bar = dialog->priv->effects_bar;
+                g_debug ("Adding effects stream");
+        } else {
+                // Must be a sink/source input/output
+                const char *name;
+                name = gvc_mixer_stream_get_name (stream);
+                g_debug ("\n Add bar for application stream : %s",
+                             name);
+
+                bar = create_app_bar (dialog, name,
+                                      gvc_mixer_stream_get_icon_name (stream));
+
+                gtk_box_pack_start (GTK_BOX (dialog->priv->applications_box), bar, FALSE, FALSE, 12);
+                dialog->priv->num_apps++;
+                gtk_widget_hide (dialog->priv->no_apps_label);
+        }
+        // We should have a bar by now.
+        g_assert (bar != NULL);
+        GvcMixerStream *old_stream;
+
+        if (bar != NULL) {
+                old_stream = g_object_get_data (G_OBJECT (bar), "gvc-mixer-dialog-stream");
+                if (old_stream != NULL) {
+                        char *name;
+                        g_object_get (bar, "name", &name, NULL);
+                        g_debug ("Disconnecting old stream '%s' from bar '%s'",
+                                 gvc_mixer_stream_get_name (old_stream), name);
+                        g_free (name);
+
+                        g_signal_handlers_disconnect_by_func (old_stream, on_stream_is_muted_notify, dialog);
+                        g_signal_handlers_disconnect_by_func (old_stream, on_stream_volume_notify, dialog);
+                        g_print ("\n in add stream \n");
+                        g_hash_table_remove (dialog->priv->bars, GUINT_TO_POINTER (gvc_mixer_stream_get_id (old_stream)));
+                }
+                save_bar_for_stream (dialog, stream, bar);
+                bar_set_stream (dialog, bar, stream);
+                gtk_widget_show (bar);
+        }
+}
+
+static void
+remove_stream (GvcMixerDialog  *dialog,
+               guint            id)
+{        
+        GtkWidget *bar;
+        bar = g_hash_table_lookup (dialog->priv->bars, GUINT_TO_POINTER (id));
+        if (bar != NULL) {
+                g_hash_table_remove (dialog->priv->bars, GUINT_TO_POINTER (id));
+                gtk_container_remove (GTK_CONTAINER (gtk_widget_get_parent (bar)),
+                                      bar);
+                dialog->priv->num_apps--;
+                if (dialog->priv->num_apps == 0) {
+                        gtk_widget_show (dialog->priv->no_apps_label);
+                }
+        }
+
+}
+
+static void
+on_control_stream_added (GvcMixerControl *control,
+                         guint            id,
+                         GvcMixerDialog  *dialog)
+{
+        GvcMixerStream *stream;
+        stream = gvc_mixer_control_lookup_stream_id (control, id);
+        
+        if (stream == NULL) 
+                return;
+        
+        const char    *app_id;
+        app_id = gvc_mixer_stream_get_application_id (stream);
+
+        if (stream == gvc_mixer_control_get_event_sink_input (dialog->priv->mixer_control) || (!GVC_IS_MIXER_SOURCE (stream) &&
+                !GVC_IS_MIXER_SINK (stream)
+                && !gvc_mixer_stream_is_virtual (stream)
+                && g_strcmp0 (app_id, "org.gnome.VolumeControl") != 0
+                && g_strcmp0 (app_id, "org.PulseAudio.pavucontrol") != 0)) {
+
+                GtkWidget      *bar;
+
+                bar = g_hash_table_lookup (dialog->priv->bars, GUINT_TO_POINTER (id));
+                if (bar != NULL) {
+                        g_debug ("GvcMixerDialog: Stream %u already added", id);
+                        return;
+                }
+                add_stream (dialog, stream);
+        } 
+}
+
+static void
+on_control_stream_removed (GvcMixerControl *control,
+                           guint            id,
+                           GvcMixerDialog  *dialog)
+{
+        remove_stream (dialog, id);
+}
+
+static gboolean
+find_item_by_id (GtkTreeModel *model,
+                 guint         id,
+                 guint         column,
+                 GtkTreeIter  *iter)
+{
+        gboolean found_item;
+
+        found_item = FALSE;
+
+        if (!gtk_tree_model_get_iter_first (model, iter)) {
+                return FALSE;
+        }
+
+        do {
+                guint t_id;
+
+                gtk_tree_model_get (model, iter,
+                                    column, &t_id, -1);
+
+                if (id == t_id) {
+                        found_item = TRUE;
+                }
+        } while (!found_item && gtk_tree_model_iter_next (model, iter));
+
+        return found_item;
+}
+
+static void
+add_input_ui_entry (GvcMixerDialog *dialog,
+                    GvcMixerUIDevice *input)
+{
+        g_debug ("\n Add input ui entry with id : %u \n",
+                  gvc_mixer_ui_device_get_id (input));
+
+        gchar    *port_name;
+        gchar    *origin;
+        gchar    *description;
+        gboolean active;
+        gboolean available;
+        gint     card_id;
+        gint     stream_id;
+
+        g_object_get (G_OBJECT (input),
+                     "stream-id", &stream_id,
+                     "card-id", &card_id,
+                     "origin", &origin,
+                     "description", &description,
+                     "port-name", &port_name,
+                     "port-available", &available,
+                      NULL);
+        GtkTreeModel        *model;
+        GtkTreeIter          iter;
+        const GvcChannelMap *map;
+        GIcon               *icon;
+
+        if (card_id == GVC_MIXER_UI_DEVICE_INVALID) {
+                GvcMixerStream *stream;
+                g_debug ("just detected a network source");
+                stream = gvc_mixer_control_get_stream_from_device (dialog->priv->mixer_control, input);
+                if (stream == NULL) {
+                        g_warning ("tried to add the network source but the stream was null - fail ?!");
+                        g_free (port_name);					
+                        g_free (origin);							
+                        g_free (description);		  				
+                        return;
+                }
+                icon = gvc_mixer_stream_get_gicon (stream);			
+        }
+        else{
+                GvcMixerCard        *card;
+                card = gvc_mixer_control_lookup_card_id (dialog->priv->mixer_control, card_id);
+                icon = gvc_mixer_card_get_gicon (card);                 
+        }
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->input_treeview));
+        gtk_list_store_append (GTK_LIST_STORE (model), &iter);
+
+        gtk_list_store_set (GTK_LIST_STORE (model),
+                            &iter,
+                            NAME_COLUMN, description,
+                            DEVICE_COLUMN, origin,
+                            ACTIVE_COLUMN, FALSE,
+                            ICON_COLUMN, icon,
+                            ID_COLUMN, gvc_mixer_ui_device_get_id (input),
+                            SPEAKERS_COLUMN,origin,
+                            -1);
+
+        if (icon != NULL)
+                g_object_unref (icon);
+
+        // TODO check this.
+        /*g_signal_connect (output,
+                          "notify::description",
+                          G_CALLBACK (on_output_description_notify),
+                          dialog);*/
+              
+        g_free (port_name);                                        
+        g_free (origin);                                                        
+        g_free (description);                   
+}                                   
+
+static void
+add_output_ui_entry (GvcMixerDialog *dialog,
+                     GvcMixerUIDevice *output)
+{
+        g_debug ("\n Add output ui entry with id : %u \n",
+                  gvc_mixer_ui_device_get_id (output));
+
+        gchar    *sink_port_name;
+        gchar    *origin;
+        gchar    *description;
+        gboolean active;
+        gboolean available;
+        gint     card_id;
+        gint     sink_stream_id;
+
+        g_object_get (G_OBJECT (output),
+                     "stream-id", &sink_stream_id,
+                     "card-id", &card_id,
+                     "origin", &origin,
+                     "description", &description,
+                     "port-name", &sink_port_name,
+                     "port-available", &available,
+                      NULL);
+	
+        GtkTreeModel        *model;
+        GtkTreeIter          iter;
+        const GvcChannelMap *map;
+        GIcon               *icon;
+
+        if (card_id == GVC_MIXER_UI_DEVICE_INVALID) {
+                g_debug ("just detected a network sink");
+                
+                GvcMixerStream *stream;
+                stream = gvc_mixer_control_get_stream_from_device (dialog->priv->mixer_control, output);
+                if (stream == NULL) {
+                        g_warning ("tried to add the network sink but the stream was null - fail ?!");
+                        g_free (sink_port_name);					
+                        g_free (origin);							
+                        g_free (description);		  				
+                        return;
+                }
+                icon = gvc_mixer_stream_get_gicon (stream);			
+        }
+        else{
+                GvcMixerCard	    *card;
+                card = gvc_mixer_control_lookup_card_id (dialog->priv->mixer_control, card_id);
+                icon = gvc_mixer_card_get_gicon (card);			
+        }
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        gtk_list_store_append (GTK_LIST_STORE (model), &iter);
+
+        gtk_list_store_set (GTK_LIST_STORE (model),
+                            &iter,
+                            NAME_COLUMN, description,
+                            DEVICE_COLUMN, origin,
+                            ACTIVE_COLUMN, FALSE,
+                            ICON_COLUMN, icon,
+                            ID_COLUMN, gvc_mixer_ui_device_get_id (output),
+                            SPEAKERS_COLUMN,origin,
+                            -1);
+
+        if (icon != NULL)
+                g_object_unref (icon);
+
+        // TODO check this.
+        /*g_signal_connect (output,
+                          "notify::description",
+                          G_CALLBACK (on_output_description_notify),
+                          dialog);*/
+              
+        g_free (sink_port_name);					
+        g_free (origin);							
+        g_free (description);		  	
+}				    
+
+static void
+on_control_output_added (GvcMixerControl *control,
+                         guint            id,
+                         GvcMixerDialog  *dialog)
+{
+	GvcMixerUIDevice* out = NULL;
+	out = gvc_mixer_control_lookup_output_id (control, id);
+
+	if (out == NULL) {
+		g_warning ("on_control_output_added - tried to fetch an output of id %u but got nothing", id);
+		return;
+	}
+
+	add_output_ui_entry (dialog, out);
+}
+
+static void
+on_control_active_output_update (GvcMixerControl *control,
+                                 guint            id,
+                                 GvcMixerDialog  *dialog)
+{
+	GvcMixerUIDevice* out = NULL;
+	out = gvc_mixer_control_lookup_output_id (control, id);
+
+	if (out == NULL) {
+		g_warning ("\n on_control_active_output_update - tried to fetch an output of id %u but got nothing", id);
+		return;
+	}
+        active_output_update (dialog, out);
+}
+
+static void
+on_control_active_input_update (GvcMixerControl *control,
+                                 guint            id,
+                                 GvcMixerDialog  *dialog)
+{
+	GvcMixerUIDevice* in = NULL;
+	in = gvc_mixer_control_lookup_input_id (control, id);
+
+	if (in == NULL) {
+		g_warning ("on_control_active_input_update - tried to fetch an input of id %u but got nothing", id);
+		return;
+	}
+        active_input_update (dialog, in);
+}
+
+static void
+on_control_input_added (GvcMixerControl *control,
+                        guint            id,
+                        GvcMixerDialog  *dialog)
+{
+	GvcMixerUIDevice* in = NULL;
+	in = gvc_mixer_control_lookup_input_id (control, id);
+
+	if (in == NULL) {
+		g_warning ("on_control_input_added - tried to fetch an input of id %u but got nothing", id);
+		return;
+	}
+	add_input_ui_entry (dialog, in);
+}
+
+static void
+on_control_output_removed (GvcMixerControl *control,
+                           guint	    id,
+                           GvcMixerDialog  *dialog)
+{
+        GtkWidget    *bar;
+        gboolean      found;
+        GtkTreeIter   iter;
+        GtkTreeModel *model;
+
+        GvcMixerUIDevice* out = NULL;
+        out = gvc_mixer_control_lookup_output_id (control, id);
+        
+        gint sink_stream_id;
+        
+        g_object_get (G_OBJECT (out),
+                     "stream-id", &sink_stream_id,
+                      NULL);
+		      
+        g_debug ("Remove output from dialog \n id : %u \n sink stream id : %i \n",
+                  id,
+                  sink_stream_id);
+
+        /* remove from any models */
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        found = find_item_by_id (GTK_TREE_MODEL (model), id, ID_COLUMN, &iter);
+        if (found) {
+                gtk_list_store_remove (GTK_LIST_STORE (model), &iter);
+        }
+}     
+
+
+                 
+static void
+on_control_input_removed (GvcMixerControl *control,
+			   guint	    id,
+			   GvcMixerDialog  *dialog)
+{
+        GtkWidget    *bar;
+        gboolean      found;
+        GtkTreeIter   iter;
+        GtkTreeModel *model;
+
+        GvcMixerUIDevice* in = NULL;
+        in = gvc_mixer_control_lookup_input_id (control, id);
+        
+        gint stream_id;
+        
+        g_object_get (G_OBJECT (in),
+                     "stream-id", &stream_id,
+                      NULL);
+                      
+        g_debug ("Remove input from dialog \n id : %u \n stream id : %i \n",
+                  id,
+                  stream_id);
+
+        /* remove from any models */
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->input_treeview));
+        found = find_item_by_id (GTK_TREE_MODEL (model), id, ID_COLUMN, &iter);
+        if (found) {
+                gtk_list_store_remove (GTK_LIST_STORE (model), &iter);
+        }        
+}
+
+static void
+_gtk_label_make_bold (GtkLabel *label)
+{
+        PangoFontDescription *font_desc;
+
+        font_desc = pango_font_description_new ();
+
+        pango_font_description_set_weight (font_desc,
+                                           PANGO_WEIGHT_BOLD);
+
+        /* This will only affect the weight of the font, the rest is
+         * from the current state of the widget, which comes from the
+         * theme or user prefs, since the font desc only has the
+         * weight flag turned on.
+         */
+        gtk_widget_modify_font (GTK_WIDGET (label), font_desc);
+
+        pango_font_description_free (font_desc);
+}
+
+
+static void
+on_input_selection_changed (GtkTreeSelection *selection,
+                             GvcMixerDialog   *dialog)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        gboolean      toggled;
+        guint         id;
+
+        if (gtk_tree_selection_get_selected (selection, &model, &iter) == FALSE) {
+                g_debug ("Could not get default input from selection");
+                return;
+        }
+
+        gtk_tree_model_get (model, &iter,
+                            ID_COLUMN, &id,
+                            ACTIVE_COLUMN, &toggled,
+                            -1);
+
+        toggled ^= 1;
+        GvcMixerUIDevice *input;
+        //g_debug ("on_input_selection_changed - try swap to input with id %u", id); 
+        input = gvc_mixer_control_lookup_input_id (dialog->priv->mixer_control, id);
+        
+        if (input == NULL) {
+                g_warning ("on_input_selection_changed - Unable to find input with id: %u", id);
+                return;
+        }
+
+        gvc_mixer_control_change_input (dialog->priv->mixer_control, input);
+}
+
+static void
+on_output_selection_changed (GtkTreeSelection *selection,
+                             GvcMixerDialog   *dialog)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        gboolean      active;
+        guint         id;
+
+        if (gtk_tree_selection_get_selected (selection, &model, &iter) == FALSE) {
+                g_debug ("Could not get default output from selection");
+                return;
+        }
+
+        gtk_tree_model_get (model, &iter,
+                            ID_COLUMN, &id,
+                            ACTIVE_COLUMN, &active,
+                            -1);
+        
+        g_debug ("\n\n on_output_selection_changed - active %i \n\n", active); 
+        if (active){
+                return;
+        }
+
+        GvcMixerUIDevice *output;
+        g_debug ("\n on_output_selection_changed - try swap to output with id %u", id); 
+	output = gvc_mixer_control_lookup_output_id (dialog->priv->mixer_control, id);
+        
+	if (output == NULL) {
+		g_warning ("on_output_selection_changed - Unable to find output with id: %u", id);
+		return;
+	}
+
+        gvc_mixer_control_change_output (dialog->priv->mixer_control, output);
+}
+
+static void
+name_to_text (GtkTreeViewColumn *column,
+              GtkCellRenderer *cell,
+              GtkTreeModel *model,
+              GtkTreeIter *iter,
+              gpointer user_data)
+{
+        char *name, *mapping;
+
+        gtk_tree_model_get(model, iter,
+                           NAME_COLUMN, &name,
+                           SPEAKERS_COLUMN, &mapping,
+                           -1);
+
+        if (mapping == NULL) {
+                g_object_set (cell, "text", name, NULL);
+        } else {
+                char *str;
+
+                str = g_strdup_printf ("%s\n<i>%s</i>",
+                                       name, mapping);
+                g_object_set (cell, "markup", str, NULL);
+                g_free (str);
+        }
+
+        g_free (name);
+        g_free (mapping);
+}
+
+static GtkWidget *
+create_stream_treeview (GvcMixerDialog *dialog,
+                        GCallback       on_selection_changed)
+{
+        GtkWidget         *treeview;
+        GtkListStore      *store;
+        GtkCellRenderer   *renderer;
+        GtkTreeViewColumn *column;
+        GtkTreeSelection  *selection;
+
+        treeview = gtk_tree_view_new ();
+        gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview), FALSE);
+
+        store = gtk_list_store_new (NUM_COLUMNS,
+                                    G_TYPE_STRING,
+                                    G_TYPE_STRING,
+                                    G_TYPE_BOOLEAN,
+                                    G_TYPE_UINT,
+                                    G_TYPE_STRING,
+                                    G_TYPE_ICON);
+        gtk_tree_view_set_model (GTK_TREE_VIEW (treeview),
+                                 GTK_TREE_MODEL (store));
+
+        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (treeview));
+        gtk_tree_selection_set_mode (selection, GTK_SELECTION_BROWSE);
+
+        column = gtk_tree_view_column_new ();
+        gtk_tree_view_column_set_title (column, _("Name"));
+        renderer = gtk_cell_renderer_pixbuf_new ();
+        gtk_tree_view_column_pack_start (column, renderer, FALSE);
+        g_object_set (G_OBJECT (renderer), "stock-size", GTK_ICON_SIZE_LARGE_TOOLBAR, NULL);
+        gtk_tree_view_column_set_attributes (column, renderer,
+                                             "gicon", ICON_COLUMN,
+                                             NULL);
+
+        renderer = gtk_cell_renderer_text_new ();
+        gtk_tree_view_column_pack_start (column, renderer, TRUE);
+        gtk_tree_view_column_set_cell_data_func (column, renderer,
+                                                 name_to_text, NULL, NULL);
+        gtk_tree_view_append_column (GTK_TREE_VIEW (treeview), column);
+
+        g_signal_connect ( selection, "changed",
+                          on_selection_changed, dialog);
+#if 0
+        renderer = gtk_cell_renderer_text_new ();
+        column = gtk_tree_view_column_new_with_attributes (_("Device"),
+                                                           renderer,
+                                                           "text", DEVICE_COLUMN,
+                                                           NULL);
+        gtk_tree_view_append_column (GTK_TREE_VIEW (treeview), column);
+#endif
+        return treeview;
+}
+
+static void
+on_profile_changed (GvcComboBox *widget,
+                    const char  *profile,
+                    gpointer     user_data)
+{
+        GvcMixerCard        *card;
+
+        card = g_object_get_data (G_OBJECT (widget), "card");
+        if (card == NULL) {
+                g_warning ("Could not find card for combobox");
+                return;
+        }
+
+        g_debug ("Profile changed to %s for card %s", profile,
+                 gvc_mixer_card_get_name (card));
+
+        gvc_mixer_card_change_profile (card, profile);
+}
+
+static void
+on_test_speakers_clicked (GtkButton *widget,
+                          gpointer  user_data)
+{
+        GvcMixerDialog      *dialog = GVC_MIXER_DIALOG (user_data);
+        GtkTreeModel        *model;
+        GtkTreeIter         iter;
+        gint                active_output = GVC_MIXER_UI_DEVICE_INVALID;
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        
+        if (gtk_tree_model_get_iter_first (model, &iter) == FALSE){
+                g_warning ("The tree is empty => we have no device to test speakers with return");
+                return;        
+        }
+                
+        do {
+                gboolean         is_selected = FALSE ;
+                gint             id;
+                        
+                gtk_tree_model_get (model, &iter,
+                                    ID_COLUMN, &id,
+                                    ACTIVE_COLUMN, &is_selected,
+                                    -1);
+                
+                if (is_selected) {
+                        active_output = id;
+                        break;
+                }
+                
+        }while (gtk_tree_model_iter_next (model, &iter));
+        
+        if (active_output == GVC_MIXER_UI_DEVICE_INVALID) {
+                g_warning ("Cant find the active output from the UI");
+                return;
+        }        
+
+        GvcMixerUIDevice *output;
+        output = gvc_mixer_control_lookup_output_id (dialog->priv->mixer_control, (guint)active_output);
+        gint stream_id = gvc_mixer_ui_device_get_stream_id(output);
+
+        if (stream_id == GVC_MIXER_UI_DEVICE_INVALID)
+                return;
+
+        g_debug ("Test the speakers on the %s", gvc_mixer_ui_device_get_description (output));
+        
+        GvcMixerStream        *stream;
+        GvcMixerCardProfile *profile;
+        GtkWidget           *d, *speaker_test, *container;
+        char                *title;
+
+        stream = gvc_mixer_control_lookup_stream_id (dialog->priv->mixer_control, stream_id);
+        if (stream == NULL) {
+                g_debug ("Stream/sink not found");
+                return;
+        }
+        title = g_strdup_printf (_("Speaker Testing for %s"), gvc_mixer_ui_device_get_description (output));
+        d = gtk_dialog_new_with_buttons (title,
+                                         GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (widget))),
+                                         GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
+                                         GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE,
+                                         NULL);
+        gtk_window_set_has_resize_grip (GTK_WINDOW (d), FALSE);
+
+        g_free (title);
+        speaker_test = gvc_speaker_test_new (dialog->priv->mixer_control,
+                                             stream);
+        gtk_widget_show (speaker_test);
+        container = gtk_dialog_get_content_area (GTK_DIALOG (d));
+        gtk_container_add (GTK_CONTAINER (container), speaker_test);
+
+        gtk_dialog_run (GTK_DIALOG (d));
+        gtk_widget_destroy (d);
+}
+
+static GObject *
+gvc_mixer_dialog_constructor (GType                  type,
+                              guint                  n_construct_properties,
+                              GObjectConstructParam *construct_params)
+{
+        GObject          *object;
+        GvcMixerDialog   *self;
+        GtkWidget        *main_vbox;
+        GtkWidget        *label;
+        GtkWidget        *alignment;
+        GtkWidget        *alignment_settings_box;
+        GtkWidget        *settings_box;
+        GtkWidget        *box;
+        GtkWidget        *sbox;
+        GtkWidget        *ebox;
+        GtkWidget        *test_sound_box;
+        GSList           *streams;
+        GSList           *cards;
+        GSList           *l;
+        GvcMixerStream   *stream;
+        GvcMixerCard     *card;
+        GtkTreeSelection *selection;
+
+        object = G_OBJECT_CLASS (gvc_mixer_dialog_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_DIALOG (object);
+
+        main_vbox = GTK_WIDGET (self);
+        gtk_box_set_spacing (GTK_BOX (main_vbox), 2);
+
+        gtk_container_set_border_width (GTK_CONTAINER (self), 3);
+
+        self->priv->output_stream_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 0, 0, 0, 0);
+        gtk_container_add (GTK_CONTAINER (alignment), self->priv->output_stream_box);
+        gtk_box_pack_start (GTK_BOX (main_vbox),
+                            alignment,
+                            FALSE, FALSE, 0);
+
+        self->priv->notebook = gtk_notebook_new ();
+        gtk_box_pack_start (GTK_BOX (main_vbox),
+                            self->priv->notebook,
+                            TRUE, TRUE, 0);
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->notebook), 5);
+
+        /* Output page */
+        self->priv->output_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);        
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->output_box), 12);
+        label = gtk_label_new (_("Output"));
+        gtk_notebook_append_page (GTK_NOTEBOOK (self->priv->notebook),
+                                  self->priv->output_box,
+                                  label);
+
+        box = gtk_frame_new (_("Play sound through"));
+        gtk_widget_set_size_request (GTK_WIDGET (box), 310, -1);        
+        label = gtk_frame_get_label_widget (GTK_FRAME (box));
+        _gtk_label_make_bold (GTK_LABEL (label));
+        gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
+        gtk_frame_set_shadow_type (GTK_FRAME (box), GTK_SHADOW_NONE);
+        gtk_box_pack_start (GTK_BOX (self->priv->output_box), box, FALSE, TRUE, 0);
+
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_container_add (GTK_CONTAINER (box), alignment);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 10, 5, 0, 15);
+
+        self->priv->output_treeview = create_stream_treeview (self,
+                                                              G_CALLBACK (on_output_selection_changed));
+        gtk_label_set_mnemonic_widget (GTK_LABEL (label), self->priv->output_treeview);
+
+        box = gtk_scrolled_window_new (NULL, NULL);
+        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (box),
+                                        GTK_POLICY_NEVER,
+                                        GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (box),
+                                             GTK_SHADOW_IN);
+        gtk_container_add (GTK_CONTAINER (box), self->priv->output_treeview);
+        gtk_container_add (GTK_CONTAINER (alignment), box);
+        
+        self->priv->selected_output_label = gtk_label_new (_("Settings for the selected device"));
+        gtk_widget_set_halign (self->priv->selected_output_label, GTK_ALIGN_START);
+        gtk_widget_set_valign (self->priv->selected_output_label, GTK_ALIGN_START);       
+        gtk_misc_set_padding (GTK_MISC (self->priv->selected_output_label), 0, 0);
+        _gtk_label_make_bold (GTK_LABEL (self->priv->selected_output_label));
+        settings_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+        alignment_settings_box = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment_settings_box), 7, 0, 0, 0);
+        self->priv->output_settings_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+        gtk_container_add (GTK_CONTAINER (alignment_settings_box), self->priv->output_settings_box);
+
+        gtk_box_pack_start (GTK_BOX (self->priv->output_box),
+                            settings_box,
+                            FALSE,
+                            FALSE,
+                            0);
+        gtk_box_pack_start (GTK_BOX (settings_box),
+                            self->priv->selected_output_label,
+                            FALSE,
+                            FALSE,
+                            0);
+        gtk_box_pack_start (GTK_BOX (settings_box),
+                            alignment_settings_box,
+                            FALSE,
+                            FALSE,
+                            0);
+
+        self->priv->output_balance_bar = gvc_balance_bar_new (BALANCE_TYPE_RL);
+        if (self->priv->size_group != NULL) {
+                gvc_balance_bar_set_size_group (GVC_BALANCE_BAR (self->priv->output_balance_bar),
+                                                self->priv->size_group,
+                                                FALSE);
+        }
+        gtk_box_pack_start (GTK_BOX (self->priv->output_settings_box),
+                            self->priv->output_balance_bar,
+                            FALSE, FALSE, 3);
+        gtk_widget_show (self->priv->output_balance_bar);
+
+        self->priv->output_fade_bar = gvc_balance_bar_new (BALANCE_TYPE_FR);
+        if (self->priv->size_group != NULL) {
+                gvc_balance_bar_set_size_group (GVC_BALANCE_BAR (self->priv->output_fade_bar),
+                                                self->priv->size_group,
+                                                FALSE);
+        }
+        gtk_box_pack_start (GTK_BOX (self->priv->output_settings_box),
+                            self->priv->output_fade_bar,
+                            FALSE, FALSE, 3);
+        gtk_widget_show (self->priv->output_fade_bar);
+
+        self->priv->output_lfe_bar = gvc_balance_bar_new (BALANCE_TYPE_LFE);
+        if (self->priv->size_group != NULL) {
+                gvc_balance_bar_set_size_group (GVC_BALANCE_BAR (self->priv->output_lfe_bar),
+                                                self->priv->size_group,
+                                                FALSE);
+        }
+        gtk_box_pack_start (GTK_BOX (self->priv->output_settings_box),
+                            self->priv->output_lfe_bar,
+                            FALSE, FALSE, 3);
+        gtk_widget_show (self->priv->output_lfe_bar);
+                
+        /* Creating a box and try to deal using the same size group. */
+        test_sound_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_box_pack_end (GTK_BOX (self->priv->output_settings_box),
+                          test_sound_box,
+                          FALSE, 
+                          FALSE,
+                          5);
+
+        sbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_box_pack_start (GTK_BOX (test_sound_box),
+                            sbox,
+                            FALSE, FALSE, 0);
+
+        label = gtk_label_new (_("Test:"));
+        gtk_box_pack_start (GTK_BOX (sbox),
+                            label,
+                            FALSE, FALSE, 0);
+        if (self->priv->size_group != NULL)
+                gtk_size_group_add_widget (self->priv->size_group, sbox);
+
+        self->priv->test_output_button = gtk_button_new_with_label (_("Test Sound"));
+        
+        /* FIXME: I am getting mental with all these hardcoded padding values,
+         * Here 8 works fine, not sure why. */
+        gtk_box_pack_start (GTK_BOX (test_sound_box),
+                            self->priv->test_output_button,
+                            TRUE, TRUE, 8);
+
+        /* Is this needed */
+        if (self->priv->size_group != NULL)
+                gtk_size_group_add_widget (self->priv->size_group, self->priv->test_output_button);
+
+        gtk_widget_show (test_sound_box);
+
+        //gtk_container_add (GTK_CONTAINER (box), self->priv->output_settings_box);
+	g_signal_connect (self->priv->test_output_button,
+                          "released",
+                           G_CALLBACK (on_test_speakers_clicked),
+                           self);
+
+        /* Input page */
+        self->priv->input_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->input_box), 12);
+        label = gtk_label_new (_("Input"));
+        gtk_notebook_append_page (GTK_NOTEBOOK (self->priv->notebook),
+                                  self->priv->input_box,
+                                  label);
+        box = gtk_frame_new (_("Record sound from"));
+        gtk_widget_set_size_request (GTK_WIDGET (box), 310, -1);        
+        label = gtk_frame_get_label_widget (GTK_FRAME (box));
+        _gtk_label_make_bold (GTK_LABEL (label));
+        gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
+        gtk_frame_set_shadow_type (GTK_FRAME (box), GTK_SHADOW_NONE);
+        gtk_box_pack_start (GTK_BOX (self->priv->input_box), box, FALSE, TRUE, 0);
+
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_container_add (GTK_CONTAINER (box), alignment);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 10, 5, 0, 15);
+
+        self->priv->input_treeview = create_stream_treeview (self,
+                                                             G_CALLBACK (on_input_selection_changed));
+        gtk_label_set_mnemonic_widget (GTK_LABEL (label), self->priv->input_treeview);
+
+        box = gtk_scrolled_window_new (NULL, NULL);
+        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (box),
+                                        GTK_POLICY_NEVER,
+                                        GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (box),
+                                             GTK_SHADOW_IN);
+        gtk_container_add (GTK_CONTAINER (box), self->priv->input_treeview);
+        gtk_container_add (GTK_CONTAINER (alignment), box);
+
+        self->priv->selected_input_label = gtk_label_new (_("Settings for the selected device"));
+        gtk_widget_set_halign (self->priv->selected_input_label, GTK_ALIGN_START);
+        _gtk_label_make_bold (GTK_LABEL (self->priv->selected_input_label));
+        
+        self->priv->input_settings_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+        gtk_box_pack_start (GTK_BOX (self->priv->input_box),
+                            self->priv->input_settings_box,
+                            FALSE,
+                            FALSE,
+                            0);
+        gtk_box_pack_start (GTK_BOX (self->priv->input_settings_box),
+                            self->priv->selected_input_label,
+                            FALSE,
+                            FALSE,
+                            0);     
+
+        self->priv->input_bar = create_bar (self, FALSE, TRUE);
+        gvc_channel_bar_set_name (GVC_CHANNEL_BAR (self->priv->input_bar),
+                                  _("_Input volume:"));
+        gvc_channel_bar_set_low_icon_name (GVC_CHANNEL_BAR (self->priv->input_bar),
+                                           "audio-input-microphone-low-symbolic");
+        gvc_channel_bar_set_high_icon_name (GVC_CHANNEL_BAR (self->priv->input_bar),
+                                            "audio-input-microphone-high-symbolic");
+        gtk_widget_set_sensitive (self->priv->input_bar, FALSE);
+
+        if (self->priv->size_group != NULL) {
+                gvc_channel_bar_set_size_group (GVC_CHANNEL_BAR (self->priv->input_bar),
+                                                self->priv->size_group,
+                                                FALSE);                
+        }
+
+        gtk_box_pack_start (GTK_BOX (self->priv->input_settings_box),
+                            self->priv->input_bar,
+                            FALSE, FALSE, 15);
+        gtk_widget_show (self->priv->input_bar);
+        
+
+        /* Creating a box and try to deal using the same size group. */
+        GtkWidget *input_level_box;
+        input_level_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_box_pack_start (GTK_BOX (self->priv->input_settings_box),
+                            input_level_box,
+                            FALSE,
+                            FALSE,
+                            5);
+
+        sbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_box_pack_start (GTK_BOX (input_level_box),
+                            sbox,
+                            FALSE, FALSE, 0);
+        
+        label = gtk_label_new (_("Input level:"));
+        gtk_box_pack_start (GTK_BOX (sbox),
+                            label,
+                            FALSE, FALSE, 0);
+        if (self->priv->size_group != NULL)
+                gtk_size_group_add_widget (self->priv->size_group, sbox);
+
+
+        self->priv->input_level_bar = gvc_level_bar_new ();
+        gvc_level_bar_set_orientation (GVC_LEVEL_BAR (self->priv->input_level_bar),
+                                       GTK_ORIENTATION_HORIZONTAL);
+        gvc_level_bar_set_scale (GVC_LEVEL_BAR (self->priv->input_level_bar),
+                                 GVC_LEVEL_SCALE_LINEAR);
+
+        gtk_box_pack_start (GTK_BOX (input_level_box),
+                            self->priv->input_level_bar,
+                            TRUE, TRUE, 0);        
+        	
+        /* Effects page */
+        self->priv->sound_effects_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->sound_effects_box), 12);
+        label = gtk_label_new (_("Sound Effects"));
+        gtk_notebook_append_page (GTK_NOTEBOOK (self->priv->notebook),
+                                  self->priv->sound_effects_box,
+                                  label);
+
+        self->priv->effects_bar = create_bar (self, FALSE, TRUE);
+        gvc_channel_bar_set_name (GVC_CHANNEL_BAR (self->priv->effects_bar),
+                                  _("_Alert volume:"));
+        gtk_widget_set_sensitive (self->priv->effects_bar, FALSE);
+        gtk_box_pack_start (GTK_BOX (self->priv->sound_effects_box),
+                            self->priv->effects_bar, FALSE, FALSE, 0);
+
+        self->priv->sound_theme_chooser = gvc_sound_theme_chooser_new ();
+        gtk_box_pack_start (GTK_BOX (self->priv->sound_effects_box),
+                            self->priv->sound_theme_chooser,
+                            TRUE, TRUE, 6);
+
+        /* Applications */
+        self->priv->applications_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->applications_box), 12);
+        label = gtk_label_new (_("Applications"));
+        gtk_notebook_append_page (GTK_NOTEBOOK (self->priv->notebook),
+                                  self->priv->applications_box,
+                                  label);
+        self->priv->no_apps_label = gtk_label_new (_("No application is currently playing or recording audio."));
+        gtk_box_pack_start (GTK_BOX (self->priv->applications_box),
+                            self->priv->no_apps_label,
+                            TRUE, TRUE, 0);
+
+        self->priv->output_stream_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 12, 0, 0, 0);
+        gtk_container_add (GTK_CONTAINER (alignment), self->priv->output_stream_box);
+        gtk_box_pack_start (GTK_BOX (main_vbox),
+                            alignment,
+                            FALSE, FALSE, 0);
+        // Output volume
+        self->priv->output_bar = create_bar (self, FALSE, TRUE);
+        gvc_channel_bar_set_name (GVC_CHANNEL_BAR (self->priv->output_bar),
+                                  _("_Output volume:"));
+        gtk_widget_set_sensitive (self->priv->output_bar, FALSE);
+        gtk_widget_set_size_request (self->priv->output_bar, 460, -1);        
+
+        gtk_box_pack_start (GTK_BOX (self->priv->output_stream_box),
+                            self->priv->output_bar, TRUE, FALSE, 12);
+
+        gtk_widget_show_all (main_vbox);
+
+        g_signal_connect (self->priv->mixer_control,
+                          "stream-added",
+                          G_CALLBACK (on_control_stream_added),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "stream-removed",
+                          G_CALLBACK (on_control_stream_removed),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "output-added",
+                          G_CALLBACK (on_control_output_added),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "output-removed",
+                          G_CALLBACK (on_control_output_removed),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "input-added",
+                          G_CALLBACK (on_control_input_added),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "input-removed",
+                          G_CALLBACK (on_control_input_removed),
+                          self);        
+        return object;
+}
+
+static void
+gvc_mixer_dialog_dispose (GObject *object)
+{
+        GvcMixerDialog *dialog = GVC_MIXER_DIALOG (object);
+
+        g_clear_object (&dialog->priv->indicator_settings);
+
+        if (dialog->priv->mixer_control != NULL) {
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_output_added,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_output_removed,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_active_input_update,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_active_output_update,
+                                                      dialog);                                            
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_input_added,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_input_removed,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_stream_added,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_stream_removed,
+                                                      dialog);
+                g_object_unref (dialog->priv->mixer_control);
+                dialog->priv->mixer_control = NULL;
+        }
+
+        if (dialog->priv->bars != NULL) {
+                g_hash_table_destroy (dialog->priv->bars);
+                dialog->priv->bars = NULL;
+        }
+
+        G_OBJECT_CLASS (gvc_mixer_dialog_parent_class)->dispose (object);
+}
+
+static void
+gvc_mixer_dialog_class_init (GvcMixerDialogClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_mixer_dialog_constructor;
+        object_class->dispose = gvc_mixer_dialog_dispose;
+        object_class->finalize = gvc_mixer_dialog_finalize;
+        object_class->set_property = gvc_mixer_dialog_set_property;
+        object_class->get_property = gvc_mixer_dialog_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_MIXER_CONTROL,
+                                         g_param_spec_object ("mixer-control",
+                                                              "mixer control",
+                                                              "mixer control",
+                                                              GVC_TYPE_MIXER_CONTROL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_type_class_add_private (klass, sizeof (GvcMixerDialogPrivate));
+}
+
+
+static void
+gvc_mixer_dialog_init (GvcMixerDialog *dialog)
+{
+        dialog->priv = GVC_MIXER_DIALOG_GET_PRIVATE (dialog);
+        dialog->priv->bars = g_hash_table_new (NULL, NULL);
+        dialog->priv->size_group = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
+}
+
+static void
+gvc_mixer_dialog_finalize (GObject *object)
+{
+        GvcMixerDialog *mixer_dialog;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_DIALOG (object));
+
+        mixer_dialog = GVC_MIXER_DIALOG (object);
+
+        g_return_if_fail (mixer_dialog->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_dialog_parent_class)->finalize (object);
+}
+
+GvcMixerDialog *
+gvc_mixer_dialog_new (GvcMixerControl *control)
+{
+        GObject *dialog;
+        dialog = g_object_new (GVC_TYPE_MIXER_DIALOG,
+                               "mixer-control", control,
+                               NULL);
+        return GVC_MIXER_DIALOG (dialog);
+}
+
+enum {
+        PAGE_OUTPUT,
+        PAGE_INPUT,
+        PAGE_EVENTS,
+        PAGE_APPLICATIONS
+};
+
+gboolean
+gvc_mixer_dialog_set_page (GvcMixerDialog *self,
+                           const char     *page)
+{
+        guint num;
+
+        g_return_val_if_fail (self != NULL, FALSE);
+
+        num = PAGE_OUTPUT;
+
+        if (g_str_equal (page, "effects"))
+                num = PAGE_EVENTS;
+        else if (g_str_equal (page, "input"))
+                num = PAGE_INPUT;
+        else if (g_str_equal (page, "output"))
+                num = PAGE_OUTPUT;
+        else if (g_str_equal (page, "applications"))
+                num = PAGE_APPLICATIONS;
+
+        gtk_notebook_set_current_page (GTK_NOTEBOOK (self->priv->notebook), num);
+
+        return TRUE;
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-dialog.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-dialog.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-dialog.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-dialog.h	2012-09-28 19:08:52.490641703 -0400
@@ -0,0 +1,56 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_DIALOG_H
+#define __GVC_MIXER_DIALOG_H
+
+#include <glib-object.h>
+#include "gvc-mixer-control.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_DIALOG         (gvc_mixer_dialog_get_type ())
+#define GVC_MIXER_DIALOG(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_DIALOG, GvcMixerDialog))
+#define GVC_MIXER_DIALOG_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_DIALOG, GvcMixerDialogClass))
+#define GVC_IS_MIXER_DIALOG(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_DIALOG))
+#define GVC_IS_MIXER_DIALOG_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_DIALOG))
+#define GVC_MIXER_DIALOG_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_DIALOG, GvcMixerDialogClass))
+
+typedef struct GvcMixerDialogPrivate GvcMixerDialogPrivate;
+
+typedef struct
+{
+        GtkVBox                parent;
+        GvcMixerDialogPrivate *priv;
+} GvcMixerDialog;
+
+typedef struct
+{
+        GtkVBoxClass           parent_class;
+} GvcMixerDialogClass;
+
+GType               gvc_mixer_dialog_get_type            (void);
+
+GvcMixerDialog *    gvc_mixer_dialog_new                 (GvcMixerControl *control);
+gboolean            gvc_mixer_dialog_set_page            (GvcMixerDialog *dialog, const gchar* page);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_DIALOG_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-event-role.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-event-role.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-event-role.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-event-role.c	2012-09-28 19:08:52.490641703 -0400
@@ -0,0 +1,231 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+#include <pulse/ext-stream-restore.h>
+
+#include "gvc-mixer-event-role.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_EVENT_ROLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_EVENT_ROLE, GvcMixerEventRolePrivate))
+
+struct GvcMixerEventRolePrivate
+{
+        char          *device;
+};
+
+enum
+{
+        PROP_0,
+        PROP_DEVICE
+};
+
+static void     gvc_mixer_event_role_class_init (GvcMixerEventRoleClass *klass);
+static void     gvc_mixer_event_role_init       (GvcMixerEventRole      *mixer_event_role);
+static void     gvc_mixer_event_role_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcMixerEventRole, gvc_mixer_event_role, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+update_settings (GvcMixerEventRole *role,
+                 gboolean           is_muted,
+                 gpointer          *op)
+{
+        pa_operation              *o;
+        const GvcChannelMap       *map;
+        pa_context                *context;
+        pa_ext_stream_restore_info info;
+
+        map = gvc_mixer_stream_get_channel_map (GVC_MIXER_STREAM(role));
+
+        info.volume = *gvc_channel_map_get_cvolume(map);
+        info.name = "sink-input-by-media-role:event";
+        info.channel_map = *gvc_channel_map_get_pa_channel_map(map);
+        info.device = role->priv->device;
+        info.mute = is_muted;
+
+        context = gvc_mixer_stream_get_pa_context (GVC_MIXER_STREAM (role));
+
+        o = pa_ext_stream_restore_write (context,
+                                         PA_UPDATE_REPLACE,
+                                         &info,
+                                         1,
+                                         TRUE,
+                                         NULL,
+                                         NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_write() failed");
+                return FALSE;
+        }
+
+        if (op != NULL)
+                *op = o;
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_event_role_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        return update_settings (GVC_MIXER_EVENT_ROLE (stream),
+                                gvc_mixer_stream_get_is_muted (stream), op);
+}
+
+static gboolean
+gvc_mixer_event_role_change_is_muted (GvcMixerStream *stream,
+                                      gboolean        is_muted)
+{
+        return update_settings (GVC_MIXER_EVENT_ROLE (stream),
+                                is_muted, NULL);
+}
+
+static gboolean
+gvc_mixer_event_role_set_device (GvcMixerEventRole *role,
+                                 const char        *device)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_EVENT_ROLE (role), FALSE);
+
+        g_free (role->priv->device);
+        role->priv->device = g_strdup (device);
+        g_object_notify (G_OBJECT (role), "device");
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_event_role_set_property (GObject       *object,
+                                   guint          prop_id,
+                                   const GValue  *value,
+                                   GParamSpec    *pspec)
+{
+        GvcMixerEventRole *self = GVC_MIXER_EVENT_ROLE (object);
+
+        switch (prop_id) {
+        case PROP_DEVICE:
+                gvc_mixer_event_role_set_device (self, g_value_get_string (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_event_role_get_property (GObject     *object,
+                                   guint        prop_id,
+                                   GValue      *value,
+                                   GParamSpec  *pspec)
+{
+        GvcMixerEventRole *self = GVC_MIXER_EVENT_ROLE (object);
+
+        switch (prop_id) {
+        case PROP_DEVICE:
+                g_value_set_string (value, self->priv->device);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_event_role_class_init (GvcMixerEventRoleClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_event_role_finalize;
+        object_class->set_property = gvc_mixer_event_role_set_property;
+        object_class->get_property = gvc_mixer_event_role_get_property;
+
+        stream_class->push_volume = gvc_mixer_event_role_push_volume;
+        stream_class->change_is_muted = gvc_mixer_event_role_change_is_muted;
+
+        g_object_class_install_property (object_class,
+                                         PROP_DEVICE,
+                                         g_param_spec_string ("device",
+                                                              "Device",
+                                                              "Device",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_type_class_add_private (klass, sizeof (GvcMixerEventRolePrivate));
+}
+
+static void
+gvc_mixer_event_role_init (GvcMixerEventRole *event_role)
+{
+        event_role->priv = GVC_MIXER_EVENT_ROLE_GET_PRIVATE (event_role);
+
+}
+
+static void
+gvc_mixer_event_role_finalize (GObject *object)
+{
+        GvcMixerEventRole *mixer_event_role;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_EVENT_ROLE (object));
+
+        mixer_event_role = GVC_MIXER_EVENT_ROLE (object);
+
+        g_return_if_fail (mixer_event_role->priv != NULL);
+
+        g_free (mixer_event_role->priv->device);
+
+        G_OBJECT_CLASS (gvc_mixer_event_role_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_event_role_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_event_role_new (pa_context *context,
+                          const char *device,
+                          GvcChannelMap *channel_map)
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_EVENT_ROLE,
+                               "pa-context", context,
+                               "index", 0,
+                               "device", device,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-event-role.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-event-role.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-event-role.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-event-role.h	2012-09-28 19:08:52.491641702 -0400
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_EVENT_ROLE_H
+#define __GVC_MIXER_EVENT_ROLE_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_EVENT_ROLE         (gvc_mixer_event_role_get_type ())
+#define GVC_MIXER_EVENT_ROLE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_EVENT_ROLE, GvcMixerEventRole))
+#define GVC_MIXER_EVENT_ROLE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_EVENT_ROLE, GvcMixerEventRoleClass))
+#define GVC_IS_MIXER_EVENT_ROLE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_EVENT_ROLE))
+#define GVC_IS_MIXER_EVENT_ROLE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_EVENT_ROLE))
+#define GVC_MIXER_EVENT_ROLE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_EVENT_ROLE, GvcMixerEventRoleClass))
+
+typedef struct GvcMixerEventRolePrivate GvcMixerEventRolePrivate;
+
+typedef struct
+{
+        GvcMixerStream            parent;
+        GvcMixerEventRolePrivate *priv;
+} GvcMixerEventRole;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerEventRoleClass;
+
+GType               gvc_mixer_event_role_get_type      (void);
+
+GvcMixerStream *    gvc_mixer_event_role_new           (pa_context    *context,
+                                                        const char    *device,
+                                                        GvcChannelMap *channel_map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_EVENT_ROLE_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-sink.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-sink.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-sink.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-sink.c	2012-09-28 19:08:52.492641700 -0400
@@ -0,0 +1,196 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-sink.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_SINK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_SINK, GvcMixerSinkPrivate))
+
+struct GvcMixerSinkPrivate
+{
+        gpointer dummy;
+};
+
+static void     gvc_mixer_sink_class_init (GvcMixerSinkClass *klass);
+static void     gvc_mixer_sink_init       (GvcMixerSink      *mixer_sink);
+static void     gvc_mixer_sink_finalize   (GObject           *object);
+
+G_DEFINE_TYPE (GvcMixerSink, gvc_mixer_sink, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+gvc_mixer_sink_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        pa_operation        *o;
+        guint                index;
+        const GvcChannelMap *map;
+        pa_context          *context;
+        const pa_cvolume    *cv;
+
+        index = gvc_mixer_stream_get_index (stream);
+
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        /* set the volume */
+        cv = gvc_channel_map_get_cvolume(map);
+
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_volume_by_index (context,
+                                                 index,
+                                                 cv,
+                                                 NULL,
+                                                 NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_volume_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        *op = o;
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_sink_change_is_muted (GvcMixerStream *stream,
+                                gboolean        is_muted)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_mute_by_index (context,
+                                               index,
+                                               is_muted,
+                                               NULL,
+                                               NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_mute_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_sink_change_port (GvcMixerStream *stream,
+                            const char     *port)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_port_by_index (context,
+                                               index,
+                                               port,
+                                               NULL,
+                                               NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_port_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_sink_class_init (GvcMixerSinkClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_sink_finalize;
+
+        stream_class->push_volume = gvc_mixer_sink_push_volume;
+        stream_class->change_port = gvc_mixer_sink_change_port;
+        stream_class->change_is_muted = gvc_mixer_sink_change_is_muted;
+
+        g_type_class_add_private (klass, sizeof (GvcMixerSinkPrivate));
+}
+
+static void
+gvc_mixer_sink_init (GvcMixerSink *sink)
+{
+        sink->priv = GVC_MIXER_SINK_GET_PRIVATE (sink);
+}
+
+static void
+gvc_mixer_sink_finalize (GObject *object)
+{
+        GvcMixerSink *mixer_sink;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_SINK (object));
+
+        mixer_sink = GVC_MIXER_SINK (object);
+
+        g_return_if_fail (mixer_sink->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_sink_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_sink_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_sink_new (pa_context    *context,
+                    guint          index,
+                    GvcChannelMap *channel_map)
+
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_SINK,
+                               "pa-context", context,
+                               "index", index,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-sink.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-sink.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-sink.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-sink.h	2012-09-28 19:08:52.492641700 -0400
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_SINK_H
+#define __GVC_MIXER_SINK_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_SINK         (gvc_mixer_sink_get_type ())
+#define GVC_MIXER_SINK(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_SINK, GvcMixerSink))
+#define GVC_MIXER_SINK_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_SINK, GvcMixerSinkClass))
+#define GVC_IS_MIXER_SINK(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_SINK))
+#define GVC_IS_MIXER_SINK_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_SINK))
+#define GVC_MIXER_SINK_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_SINK, GvcMixerSinkClass))
+
+typedef struct GvcMixerSinkPrivate GvcMixerSinkPrivate;
+
+typedef struct
+{
+        GvcMixerStream       parent;
+        GvcMixerSinkPrivate *priv;
+} GvcMixerSink;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerSinkClass;
+
+GType               gvc_mixer_sink_get_type            (void);
+
+GvcMixerStream *    gvc_mixer_sink_new                 (pa_context    *context,
+                                                        guint          index,
+                                                        GvcChannelMap *map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_SINK_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-sink-input.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-sink-input.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-sink-input.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-sink-input.c	2012-09-28 19:08:52.493641698 -0400
@@ -0,0 +1,166 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-sink-input.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_SINK_INPUT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_SINK_INPUT, GvcMixerSinkInputPrivate))
+
+struct GvcMixerSinkInputPrivate
+{
+        gpointer dummy;
+};
+
+static void     gvc_mixer_sink_input_class_init (GvcMixerSinkInputClass *klass);
+static void     gvc_mixer_sink_input_init       (GvcMixerSinkInput      *mixer_sink_input);
+static void     gvc_mixer_sink_input_finalize   (GObject                *object);
+
+G_DEFINE_TYPE (GvcMixerSinkInput, gvc_mixer_sink_input, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+gvc_mixer_sink_input_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        pa_operation        *o;
+        guint                index;
+        const GvcChannelMap *map;
+        pa_context          *context;
+        const pa_cvolume    *cv;
+
+        index = gvc_mixer_stream_get_index (stream);
+
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        cv = gvc_channel_map_get_cvolume(map);
+
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_input_volume (context,
+                                              index,
+                                              cv,
+                                              NULL,
+                                              NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_input_volume() failed");
+                return FALSE;
+        }
+
+        *op = o;
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_sink_input_change_is_muted (GvcMixerStream *stream,
+                                      gboolean        is_muted)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_input_mute (context,
+                                            index,
+                                            is_muted,
+                                            NULL,
+                                            NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_input_mute_by_index() failed");
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_sink_input_class_init (GvcMixerSinkInputClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_sink_input_finalize;
+
+        stream_class->push_volume = gvc_mixer_sink_input_push_volume;
+        stream_class->change_is_muted = gvc_mixer_sink_input_change_is_muted;
+
+        g_type_class_add_private (klass, sizeof (GvcMixerSinkInputPrivate));
+}
+
+static void
+gvc_mixer_sink_input_init (GvcMixerSinkInput *sink_input)
+{
+        sink_input->priv = GVC_MIXER_SINK_INPUT_GET_PRIVATE (sink_input);
+}
+
+static void
+gvc_mixer_sink_input_finalize (GObject *object)
+{
+        GvcMixerSinkInput *mixer_sink_input;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_SINK_INPUT (object));
+
+        mixer_sink_input = GVC_MIXER_SINK_INPUT (object);
+
+        g_return_if_fail (mixer_sink_input->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_sink_input_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_sink_input_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_sink_input_new (pa_context    *context,
+                          guint          index,
+                          GvcChannelMap *channel_map)
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_SINK_INPUT,
+                               "pa-context", context,
+                               "index", index,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-sink-input.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-sink-input.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-sink-input.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-sink-input.h	2012-09-28 19:08:52.493641698 -0400
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_SINK_INPUT_H
+#define __GVC_MIXER_SINK_INPUT_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_SINK_INPUT         (gvc_mixer_sink_input_get_type ())
+#define GVC_MIXER_SINK_INPUT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_SINK_INPUT, GvcMixerSinkInput))
+#define GVC_MIXER_SINK_INPUT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_SINK_INPUT, GvcMixerSinkInputClass))
+#define GVC_IS_MIXER_SINK_INPUT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_SINK_INPUT))
+#define GVC_IS_MIXER_SINK_INPUT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_SINK_INPUT))
+#define GVC_MIXER_SINK_INPUT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_SINK_INPUT, GvcMixerSinkInputClass))
+
+typedef struct GvcMixerSinkInputPrivate GvcMixerSinkInputPrivate;
+
+typedef struct
+{
+        GvcMixerStream            parent;
+        GvcMixerSinkInputPrivate *priv;
+} GvcMixerSinkInput;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerSinkInputClass;
+
+GType               gvc_mixer_sink_input_get_type      (void);
+
+GvcMixerStream *    gvc_mixer_sink_input_new           (pa_context    *context,
+                                                        guint          index,
+                                                        GvcChannelMap *map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_SINK_INPUT_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-source.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-source.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-source.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-source.c	2012-09-28 19:08:52.494641696 -0400
@@ -0,0 +1,196 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-source.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_SOURCE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_SOURCE, GvcMixerSourcePrivate))
+
+struct GvcMixerSourcePrivate
+{
+        gpointer dummy;
+};
+
+static void     gvc_mixer_source_class_init (GvcMixerSourceClass *klass);
+static void     gvc_mixer_source_init       (GvcMixerSource      *mixer_source);
+static void     gvc_mixer_source_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcMixerSource, gvc_mixer_source, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+gvc_mixer_source_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        pa_operation        *o;
+        guint                index;
+        const GvcChannelMap *map;
+        pa_context          *context;
+        const pa_cvolume    *cv;
+
+        index = gvc_mixer_stream_get_index (stream);
+
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        /* set the volume */
+        cv = gvc_channel_map_get_cvolume (map);
+
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_source_volume_by_index (context,
+                                                   index,
+                                                   cv,
+                                                   NULL,
+                                                   NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_source_volume_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        *op = o;
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_source_change_is_muted (GvcMixerStream *stream,
+                                gboolean        is_muted)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_source_mute_by_index (context,
+                                                 index,
+                                                 is_muted,
+                                                 NULL,
+                                                 NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_source_mute_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_source_change_port (GvcMixerStream *stream,
+                              const char     *port)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_source_port_by_index (context,
+                                                 index,
+                                                 port,
+                                                 NULL,
+                                                 NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_source_port_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_source_class_init (GvcMixerSourceClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_source_finalize;
+
+        stream_class->push_volume = gvc_mixer_source_push_volume;
+        stream_class->change_is_muted = gvc_mixer_source_change_is_muted;
+        stream_class->change_port = gvc_mixer_source_change_port;
+
+        g_type_class_add_private (klass, sizeof (GvcMixerSourcePrivate));
+}
+
+static void
+gvc_mixer_source_init (GvcMixerSource *source)
+{
+        source->priv = GVC_MIXER_SOURCE_GET_PRIVATE (source);
+}
+
+static void
+gvc_mixer_source_finalize (GObject *object)
+{
+        GvcMixerSource *mixer_source;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_SOURCE (object));
+
+        mixer_source = GVC_MIXER_SOURCE (object);
+
+        g_return_if_fail (mixer_source->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_source_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_source_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_source_new (pa_context    *context,
+                      guint          index,
+                      GvcChannelMap *channel_map)
+
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_SOURCE,
+                               "pa-context", context,
+                               "index", index,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-source.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-source.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-source.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-source.h	2012-09-28 19:08:52.494641696 -0400
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_SOURCE_H
+#define __GVC_MIXER_SOURCE_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_SOURCE         (gvc_mixer_source_get_type ())
+#define GVC_MIXER_SOURCE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_SOURCE, GvcMixerSource))
+#define GVC_MIXER_SOURCE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_SOURCE, GvcMixerSourceClass))
+#define GVC_IS_MIXER_SOURCE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_SOURCE))
+#define GVC_IS_MIXER_SOURCE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_SOURCE))
+#define GVC_MIXER_SOURCE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_SOURCE, GvcMixerSourceClass))
+
+typedef struct GvcMixerSourcePrivate GvcMixerSourcePrivate;
+
+typedef struct
+{
+        GvcMixerStream       parent;
+        GvcMixerSourcePrivate *priv;
+} GvcMixerSource;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerSourceClass;
+
+GType               gvc_mixer_source_get_type            (void);
+
+GvcMixerStream *    gvc_mixer_source_new               (pa_context    *context,
+                                                        guint          index,
+                                                        GvcChannelMap *map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_SOURCE_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-source-output.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-source-output.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-source-output.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-source-output.c	2012-09-28 19:08:52.495641696 -0400
@@ -0,0 +1,121 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-source-output.h"
+
+#define GVC_MIXER_SOURCE_OUTPUT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_SOURCE_OUTPUT, GvcMixerSourceOutputPrivate))
+
+struct GvcMixerSourceOutputPrivate
+{
+        gpointer dummy;
+};
+
+static void     gvc_mixer_source_output_class_init (GvcMixerSourceOutputClass *klass);
+static void     gvc_mixer_source_output_init       (GvcMixerSourceOutput      *mixer_source_output);
+static void     gvc_mixer_source_output_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcMixerSourceOutput, gvc_mixer_source_output, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+gvc_mixer_source_output_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        /* FIXME: */
+        *op = NULL;
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_source_output_change_is_muted (GvcMixerStream *stream,
+                                      gboolean        is_muted)
+{
+        /* FIXME: */
+        return TRUE;
+}
+
+static void
+gvc_mixer_source_output_class_init (GvcMixerSourceOutputClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_source_output_finalize;
+
+        stream_class->push_volume = gvc_mixer_source_output_push_volume;
+        stream_class->change_is_muted = gvc_mixer_source_output_change_is_muted;
+
+        g_type_class_add_private (klass, sizeof (GvcMixerSourceOutputPrivate));
+}
+
+static void
+gvc_mixer_source_output_init (GvcMixerSourceOutput *source_output)
+{
+        source_output->priv = GVC_MIXER_SOURCE_OUTPUT_GET_PRIVATE (source_output);
+
+}
+
+static void
+gvc_mixer_source_output_finalize (GObject *object)
+{
+        GvcMixerSourceOutput *mixer_source_output;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_SOURCE_OUTPUT (object));
+
+        mixer_source_output = GVC_MIXER_SOURCE_OUTPUT (object);
+
+        g_return_if_fail (mixer_source_output->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_source_output_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_source_output_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_source_output_new (pa_context    *context,
+                             guint          index,
+                             GvcChannelMap *channel_map)
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_SOURCE_OUTPUT,
+                               "pa-context", context,
+                               "index", index,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-source-output.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-source-output.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-source-output.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-source-output.h	2012-09-28 19:08:52.496641697 -0400
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_SOURCE_OUTPUT_H
+#define __GVC_MIXER_SOURCE_OUTPUT_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_SOURCE_OUTPUT         (gvc_mixer_source_output_get_type ())
+#define GVC_MIXER_SOURCE_OUTPUT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_SOURCE_OUTPUT, GvcMixerSourceOutput))
+#define GVC_MIXER_SOURCE_OUTPUT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_SOURCE_OUTPUT, GvcMixerSourceOutputClass))
+#define GVC_IS_MIXER_SOURCE_OUTPUT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_SOURCE_OUTPUT))
+#define GVC_IS_MIXER_SOURCE_OUTPUT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_SOURCE_OUTPUT))
+#define GVC_MIXER_SOURCE_OUTPUT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_SOURCE_OUTPUT, GvcMixerSourceOutputClass))
+
+typedef struct GvcMixerSourceOutputPrivate GvcMixerSourceOutputPrivate;
+
+typedef struct
+{
+        GvcMixerStream               parent;
+        GvcMixerSourceOutputPrivate *priv;
+} GvcMixerSourceOutput;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerSourceOutputClass;
+
+GType               gvc_mixer_source_output_get_type      (void);
+
+GvcMixerStream *    gvc_mixer_source_output_new           (pa_context    *context,
+                                                           guint          index,
+                                                           GvcChannelMap *map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_SOURCE_OUTPUT_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-stream.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-stream.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-stream.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-stream.c	2012-09-28 19:08:52.497641697 -0400
@@ -0,0 +1,968 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-stream.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_STREAM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_STREAM, GvcMixerStreamPrivate))
+
+static guint32 stream_serial = 1;
+
+struct GvcMixerStreamPrivate
+{
+        pa_context    *pa_context;
+        guint          id;
+        guint          index;
+        gint           card_index;
+        GvcChannelMap *channel_map;
+        char          *name;
+        char          *description;
+        char          *application_id;
+        char          *icon_name;
+        gboolean       is_muted;
+        gboolean       can_decibel;
+        gboolean       is_event_stream;
+        gboolean       is_virtual;
+        pa_volume_t    base_volume;
+        pa_operation  *change_volume_op;
+        char          *port;
+        char          *human_port;
+        GList         *ports;
+};
+
+enum
+{
+        PROP_0,
+        PROP_ID,
+        PROP_PA_CONTEXT,
+        PROP_CHANNEL_MAP,
+        PROP_INDEX,
+        PROP_NAME,
+        PROP_DESCRIPTION,
+        PROP_APPLICATION_ID,
+        PROP_ICON_NAME,
+        PROP_VOLUME,
+        PROP_DECIBEL,
+        PROP_IS_MUTED,
+        PROP_CAN_DECIBEL,
+        PROP_IS_EVENT_STREAM,
+        PROP_IS_VIRTUAL,
+        PROP_CARD_INDEX,
+        PROP_PORT,
+};
+
+static void     gvc_mixer_stream_class_init (GvcMixerStreamClass *klass);
+static void     gvc_mixer_stream_init       (GvcMixerStream      *mixer_stream);
+static void     gvc_mixer_stream_finalize   (GObject            *object);
+
+G_DEFINE_ABSTRACT_TYPE (GvcMixerStream, gvc_mixer_stream, G_TYPE_OBJECT)
+
+static guint32
+get_next_stream_serial (void)
+{
+        guint32 serial;
+
+        serial = stream_serial++;
+
+        if ((gint32)stream_serial < 0) {
+                stream_serial = 1;
+        }
+
+        return serial;
+}
+
+pa_context *
+gvc_mixer_stream_get_pa_context (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+        return stream->priv->pa_context;
+}
+
+guint
+gvc_mixer_stream_get_index (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+        return stream->priv->index;
+}
+
+guint
+gvc_mixer_stream_get_id (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+        return stream->priv->id;
+}
+
+const GvcChannelMap *
+gvc_mixer_stream_get_channel_map (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->channel_map;
+}
+
+/**
+ * gvc_mixer_stream_get_volume:
+ *
+ * @stream:
+ *
+ * Returns: (type guint32) (transfer none):
+ */
+pa_volume_t
+gvc_mixer_stream_get_volume (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+
+        return (pa_volume_t) gvc_channel_map_get_volume(stream->priv->channel_map)[VOLUME];
+}
+
+gdouble
+gvc_mixer_stream_get_decibel (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+
+        return pa_sw_volume_to_dB(
+                        (pa_volume_t) gvc_channel_map_get_volume(stream->priv->channel_map)[VOLUME]);
+}
+
+/**
+ * gvc_mixer_stream_set_volume:
+ *
+ * @stream:
+ * @volume: (type guint32):
+ *
+ * Returns:
+ */
+gboolean
+gvc_mixer_stream_set_volume (GvcMixerStream *stream,
+                              pa_volume_t     volume)
+{
+        pa_cvolume cv;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        cv = *gvc_channel_map_get_cvolume(stream->priv->channel_map);
+        pa_cvolume_scale(&cv, volume);
+
+        if (!pa_cvolume_equal(gvc_channel_map_get_cvolume(stream->priv->channel_map), &cv)) {
+                gvc_channel_map_volume_changed(stream->priv->channel_map, &cv, FALSE);
+                g_object_notify (G_OBJECT (stream), "volume");
+                return TRUE;
+        }
+
+        return FALSE;
+}
+
+gboolean
+gvc_mixer_stream_set_decibel (GvcMixerStream *stream,
+                              gdouble         db)
+{
+        pa_cvolume cv;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        cv = *gvc_channel_map_get_cvolume(stream->priv->channel_map);
+        pa_cvolume_scale(&cv, pa_sw_volume_from_dB(db));
+
+        if (!pa_cvolume_equal(gvc_channel_map_get_cvolume(stream->priv->channel_map), &cv)) {
+                gvc_channel_map_volume_changed(stream->priv->channel_map, &cv, FALSE);
+                g_object_notify (G_OBJECT (stream), "volume");
+        }
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_get_is_muted  (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        return stream->priv->is_muted;
+}
+
+gboolean
+gvc_mixer_stream_get_can_decibel (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        return stream->priv->can_decibel;
+}
+
+gboolean
+gvc_mixer_stream_set_is_muted  (GvcMixerStream *stream,
+                                gboolean        is_muted)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        if (is_muted != stream->priv->is_muted) {
+                stream->priv->is_muted = is_muted;
+                g_object_notify (G_OBJECT (stream), "is-muted");
+        }
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_set_can_decibel  (GvcMixerStream *stream,
+                                   gboolean        can_decibel)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        if (can_decibel != stream->priv->can_decibel) {
+                stream->priv->can_decibel = can_decibel;
+                g_object_notify (G_OBJECT (stream), "can-decibel");
+        }
+
+        return TRUE;
+}
+
+const char *
+gvc_mixer_stream_get_name (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->name;
+}
+
+const char *
+gvc_mixer_stream_get_description (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->description;
+}
+
+gboolean
+gvc_mixer_stream_set_name (GvcMixerStream *stream,
+                           const char     *name)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_free (stream->priv->name);
+        stream->priv->name = g_strdup (name);
+        g_object_notify (G_OBJECT (stream), "name");
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_set_description (GvcMixerStream *stream,
+                                  const char     *description)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_free (stream->priv->description);
+        stream->priv->description = g_strdup (description);
+        g_object_notify (G_OBJECT (stream), "description");
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_is_event_stream (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        return stream->priv->is_event_stream;
+}
+
+gboolean
+gvc_mixer_stream_set_is_event_stream (GvcMixerStream *stream,
+                                      gboolean is_event_stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        stream->priv->is_event_stream = is_event_stream;
+        g_object_notify (G_OBJECT (stream), "is-event-stream");
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_is_virtual (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        return stream->priv->is_virtual;
+}
+
+gboolean
+gvc_mixer_stream_set_is_virtual (GvcMixerStream *stream,
+                                 gboolean is_virtual)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        stream->priv->is_virtual = is_virtual;
+        g_object_notify (G_OBJECT (stream), "is-virtual");
+
+        return TRUE;
+}
+
+const char *
+gvc_mixer_stream_get_application_id (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->application_id;
+}
+
+gboolean
+gvc_mixer_stream_set_application_id (GvcMixerStream *stream,
+                                     const char *application_id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_free (stream->priv->application_id);
+        stream->priv->application_id = g_strdup (application_id);
+        g_object_notify (G_OBJECT (stream), "application-id");
+
+        return TRUE;
+}
+
+static void
+on_channel_map_volume_changed (GvcChannelMap  *channel_map,
+                               gboolean        set,
+                               GvcMixerStream *stream)
+{
+        if (set == TRUE)
+                gvc_mixer_stream_push_volume (stream);
+
+        g_object_notify (G_OBJECT (stream), "volume");
+}
+
+static gboolean
+gvc_mixer_stream_set_channel_map (GvcMixerStream *stream,
+                                  GvcChannelMap  *channel_map)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        if (channel_map != NULL) {
+                g_object_ref (channel_map);
+        }
+
+        if (stream->priv->channel_map != NULL) {
+                g_signal_handlers_disconnect_by_func (stream->priv->channel_map,
+                                                      on_channel_map_volume_changed,
+                                                      stream);
+                g_object_unref (stream->priv->channel_map);
+        }
+
+        stream->priv->channel_map = channel_map;
+
+        if (stream->priv->channel_map != NULL) {
+                g_signal_connect (stream->priv->channel_map,
+                                  "volume-changed",
+                                  G_CALLBACK (on_channel_map_volume_changed),
+                                  stream);
+
+                g_object_notify (G_OBJECT (stream), "channel-map");
+        }
+
+        return TRUE;
+}
+
+const char *
+gvc_mixer_stream_get_icon_name (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->icon_name;
+}
+
+/**
+ * gvc_mixer_stream_get_gicon:
+ * @stream: a #GvcMixerStream
+ *
+ * Returns: (transfer full): a new #GIcon
+ */
+GIcon *
+gvc_mixer_stream_get_gicon (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        if (stream->priv->icon_name == NULL)
+                return NULL;
+        return g_themed_icon_new_with_default_fallbacks (stream->priv->icon_name);
+}
+
+gboolean
+gvc_mixer_stream_set_icon_name (GvcMixerStream *stream,
+                                const char     *icon_name)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_free (stream->priv->icon_name);
+        stream->priv->icon_name = g_strdup (icon_name);
+        g_object_notify (G_OBJECT (stream), "icon-name");
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_stream_get_base_volume:
+ *
+ * @stream:
+ *
+ * Returns: (type guint32) (transfer none):
+ */
+pa_volume_t
+gvc_mixer_stream_get_base_volume (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+
+        return stream->priv->base_volume;
+}
+
+/**
+ * gvc_mixer_stream_set_base_volume:
+ *
+ * @stream:
+ * @base_volume: (type guint32):
+ *
+ * Returns:
+ */
+gboolean
+gvc_mixer_stream_set_base_volume (GvcMixerStream *stream,
+                                  pa_volume_t base_volume)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        stream->priv->base_volume = base_volume;
+
+        return TRUE;
+}
+
+const GvcMixerStreamPort *
+gvc_mixer_stream_get_port (GvcMixerStream *stream)
+{
+        GList *l;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        g_return_val_if_fail (stream->priv->ports != NULL, NULL);
+
+        for (l = stream->priv->ports; l != NULL; l = l->next) {
+                GvcMixerStreamPort *p = l->data;
+                if (g_strcmp0 (stream->priv->port, p->port) == 0) {
+                        return p;
+                }
+        }
+
+        g_assert_not_reached ();
+
+        return NULL;
+}
+
+gboolean
+gvc_mixer_stream_set_port (GvcMixerStream *stream,
+                           const char     *port)
+{
+        GList *l;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        g_return_val_if_fail (stream->priv->ports != NULL, FALSE);
+
+        g_free (stream->priv->port);
+        stream->priv->port = g_strdup (port);
+
+        g_free (stream->priv->human_port);
+        stream->priv->human_port = NULL;
+
+        for (l = stream->priv->ports; l != NULL; l = l->next) {
+                GvcMixerStreamPort *p = l->data;
+                if (g_str_equal (stream->priv->port, p->port)) {
+                        stream->priv->human_port = g_strdup (p->human_port);
+                        break;
+                }
+        }
+
+        g_object_notify (G_OBJECT (stream), "port");
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_change_port (GvcMixerStream *stream,
+                              const char     *port)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        return GVC_MIXER_STREAM_GET_CLASS (stream)->change_port (stream, port);
+}
+
+/**
+ * gvc_mixer_stream_get_ports:
+ *
+ * Return value: (transfer none) (element-type GvcMixerStreamPort):
+ */
+const GList *
+gvc_mixer_stream_get_ports (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->ports;
+}
+
+static int
+sort_ports (GvcMixerStreamPort *a,
+            GvcMixerStreamPort *b)
+{
+        if (a->priority == b->priority)
+                return 0;
+        if (a->priority > b->priority)
+                return 1;
+        return -1;
+}
+
+/**
+ * gvc_mixer_stream_set_ports:
+ * @ports: (transfer full) (element-type GvcMixerStreamPort):
+ */
+gboolean
+gvc_mixer_stream_set_ports (GvcMixerStream *stream,
+                            GList          *ports)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        g_return_val_if_fail (stream->priv->ports == NULL, FALSE);
+
+        stream->priv->ports = g_list_sort (ports, (GCompareFunc) sort_ports);
+
+        return TRUE;
+}
+
+gint
+gvc_mixer_stream_get_card_index (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), PA_INVALID_INDEX);
+        return stream->priv->card_index;
+}
+
+gboolean
+gvc_mixer_stream_set_card_index (GvcMixerStream *stream,
+                                 gint            card_index)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        stream->priv->card_index = card_index;
+        g_object_notify (G_OBJECT (stream), "card-index");
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_stream_set_property (GObject       *object,
+                               guint          prop_id,
+                               const GValue  *value,
+                               GParamSpec    *pspec)
+{
+        GvcMixerStream *self = GVC_MIXER_STREAM (object);
+
+        switch (prop_id) {
+        case PROP_PA_CONTEXT:
+                self->priv->pa_context = g_value_get_pointer (value);
+                break;
+        case PROP_INDEX:
+                self->priv->index = g_value_get_ulong (value);
+                break;
+        case PROP_ID:
+                self->priv->id = g_value_get_ulong (value);
+                break;
+        case PROP_CHANNEL_MAP:
+                gvc_mixer_stream_set_channel_map (self, g_value_get_object (value));
+                break;
+        case PROP_NAME:
+                gvc_mixer_stream_set_name (self, g_value_get_string (value));
+                break;
+        case PROP_DESCRIPTION:
+                gvc_mixer_stream_set_description (self, g_value_get_string (value));
+                break;
+        case PROP_APPLICATION_ID:
+                gvc_mixer_stream_set_application_id (self, g_value_get_string (value));
+                break;
+        case PROP_ICON_NAME:
+                gvc_mixer_stream_set_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_VOLUME:
+                gvc_mixer_stream_set_volume (self, g_value_get_ulong (value));
+                break;
+        case PROP_DECIBEL:
+                gvc_mixer_stream_set_decibel (self, g_value_get_double (value));
+                break;
+        case PROP_IS_MUTED:
+                gvc_mixer_stream_set_is_muted (self, g_value_get_boolean (value));
+                break;
+        case PROP_IS_EVENT_STREAM:
+                gvc_mixer_stream_set_is_event_stream (self, g_value_get_boolean (value));
+                break;
+        case PROP_IS_VIRTUAL:
+                gvc_mixer_stream_set_is_virtual (self, g_value_get_boolean (value));
+                break;
+        case PROP_CAN_DECIBEL:
+                gvc_mixer_stream_set_can_decibel (self, g_value_get_boolean (value));
+                break;
+        case PROP_PORT:
+                gvc_mixer_stream_set_port (self, g_value_get_string (value));
+                break;
+        case PROP_CARD_INDEX:
+                self->priv->card_index = g_value_get_long (value);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_stream_get_property (GObject     *object,
+                               guint        prop_id,
+                               GValue      *value,
+                               GParamSpec  *pspec)
+{
+        GvcMixerStream *self = GVC_MIXER_STREAM (object);
+
+        switch (prop_id) {
+        case PROP_PA_CONTEXT:
+                g_value_set_pointer (value, self->priv->pa_context);
+                break;
+        case PROP_INDEX:
+                g_value_set_ulong (value, self->priv->index);
+                break;
+        case PROP_ID:
+                g_value_set_ulong (value, self->priv->id);
+                break;
+        case PROP_CHANNEL_MAP:
+                g_value_set_object (value, self->priv->channel_map);
+                break;
+        case PROP_NAME:
+                g_value_set_string (value, self->priv->name);
+                break;
+        case PROP_DESCRIPTION:
+                g_value_set_string (value, self->priv->description);
+                break;
+        case PROP_APPLICATION_ID:
+                g_value_set_string (value, self->priv->application_id);
+                break;
+        case PROP_ICON_NAME:
+                g_value_set_string (value, self->priv->icon_name);
+                break;
+        case PROP_VOLUME:
+                g_value_set_ulong (value,
+                                   pa_cvolume_max(gvc_channel_map_get_cvolume(self->priv->channel_map)));
+                break;
+        case PROP_DECIBEL:
+                g_value_set_double (value,
+                                    pa_sw_volume_to_dB(pa_cvolume_max(gvc_channel_map_get_cvolume(self->priv->channel_map))));
+                break;
+        case PROP_IS_MUTED:
+                g_value_set_boolean (value, self->priv->is_muted);
+                break;
+        case PROP_IS_EVENT_STREAM:
+                g_value_set_boolean (value, self->priv->is_event_stream);
+                break;
+        case PROP_IS_VIRTUAL:
+                g_value_set_boolean (value, self->priv->is_virtual);
+                break;
+        case PROP_CAN_DECIBEL:
+                g_value_set_boolean (value, self->priv->can_decibel);
+                break;
+        case PROP_PORT:
+                g_value_set_string (value, self->priv->port);
+                break;
+        case PROP_CARD_INDEX:
+                g_value_set_long (value, self->priv->card_index);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_mixer_stream_constructor (GType                  type,
+                              guint                  n_construct_properties,
+                              GObjectConstructParam *construct_params)
+{
+        GObject       *object;
+        GvcMixerStream *self;
+
+        object = G_OBJECT_CLASS (gvc_mixer_stream_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_STREAM (object);
+
+        self->priv->id = get_next_stream_serial ();
+
+        return object;
+}
+
+static gboolean
+gvc_mixer_stream_real_change_port (GvcMixerStream *stream,
+                                   const char     *port)
+{
+        return FALSE;
+}
+
+static gboolean
+gvc_mixer_stream_real_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        return FALSE;
+}
+
+static gboolean
+gvc_mixer_stream_real_change_is_muted (GvcMixerStream *stream,
+                                       gboolean        is_muted)
+{
+        return FALSE;
+}
+
+gboolean
+gvc_mixer_stream_push_volume (GvcMixerStream *stream)
+{
+        pa_operation *op;
+        gboolean ret;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        if (stream->priv->is_event_stream != FALSE)
+                return TRUE;
+
+        g_debug ("Pushing new volume to stream '%s' (%s)",
+                 stream->priv->description, stream->priv->name);
+
+        ret = GVC_MIXER_STREAM_GET_CLASS (stream)->push_volume (stream, (gpointer *) &op);
+        if (ret) {
+                if (stream->priv->change_volume_op != NULL)
+                        pa_operation_unref (stream->priv->change_volume_op);
+                stream->priv->change_volume_op = op;
+        }
+        return ret;
+}
+
+gboolean
+gvc_mixer_stream_change_is_muted (GvcMixerStream *stream,
+                                  gboolean        is_muted)
+{
+        gboolean ret;
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        ret = GVC_MIXER_STREAM_GET_CLASS (stream)->change_is_muted (stream, is_muted);
+        return ret;
+}
+
+gboolean
+gvc_mixer_stream_is_running (GvcMixerStream *stream)
+{
+        if (stream->priv->change_volume_op == NULL)
+                return FALSE;
+
+        if ((pa_operation_get_state(stream->priv->change_volume_op) == PA_OPERATION_RUNNING))
+                return TRUE;
+
+        pa_operation_unref(stream->priv->change_volume_op);
+        stream->priv->change_volume_op = NULL;
+
+        return FALSE;
+}
+
+static void
+gvc_mixer_stream_class_init (GvcMixerStreamClass *klass)
+{
+        GObjectClass   *gobject_class = G_OBJECT_CLASS (klass);
+
+        gobject_class->constructor = gvc_mixer_stream_constructor;
+        gobject_class->finalize = gvc_mixer_stream_finalize;
+        gobject_class->set_property = gvc_mixer_stream_set_property;
+        gobject_class->get_property = gvc_mixer_stream_get_property;
+
+        klass->push_volume = gvc_mixer_stream_real_push_volume;
+        klass->change_port = gvc_mixer_stream_real_change_port;
+        klass->change_is_muted = gvc_mixer_stream_real_change_is_muted;
+
+        g_object_class_install_property (gobject_class,
+                                         PROP_INDEX,
+                                         g_param_spec_ulong ("index",
+                                                             "Index",
+                                                             "The index for this stream",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_ID,
+                                         g_param_spec_ulong ("id",
+                                                             "id",
+                                                             "The id for this stream",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_CHANNEL_MAP,
+                                         g_param_spec_object ("channel-map",
+                                                              "channel map",
+                                                              "The channel map for this stream",
+                                                              GVC_TYPE_CHANNEL_MAP,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_PA_CONTEXT,
+                                         g_param_spec_pointer ("pa-context",
+                                                               "PulseAudio context",
+                                                               "The PulseAudio context for this stream",
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_VOLUME,
+                                         g_param_spec_ulong ("volume",
+                                                             "Volume",
+                                                             "The volume for this stream",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE));
+        g_object_class_install_property (gobject_class,
+                                         PROP_DECIBEL,
+                                         g_param_spec_double ("decibel",
+                                                              "Decibel",
+                                                              "The decibel level for this stream",
+                                                              -G_MAXDOUBLE, G_MAXDOUBLE, 0,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_object_class_install_property (gobject_class,
+                                         PROP_NAME,
+                                         g_param_spec_string ("name",
+                                                              "Name",
+                                                              "Name to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_DESCRIPTION,
+                                         g_param_spec_string ("description",
+                                                              "Description",
+                                                              "Description to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_APPLICATION_ID,
+                                         g_param_spec_string ("application-id",
+                                                              "Application identifier",
+                                                              "Application identifier for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_ICON_NAME,
+                                         g_param_spec_string ("icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_IS_MUTED,
+                                         g_param_spec_boolean ("is-muted",
+                                                               "is muted",
+                                                               "Whether stream is muted",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_CAN_DECIBEL,
+                                         g_param_spec_boolean ("can-decibel",
+                                                               "can decibel",
+                                                               "Whether stream volume can be converted to decibel units",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_IS_EVENT_STREAM,
+                                         g_param_spec_boolean ("is-event-stream",
+                                                               "is event stream",
+                                                               "Whether stream's role is to play an event",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_IS_VIRTUAL,
+                                         g_param_spec_boolean ("is-virtual",
+                                                               "is virtual stream",
+                                                               "Whether the stream is virtual",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_PORT,
+                                         g_param_spec_string ("port",
+                                                              "Port",
+                                                              "The name of the current port for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (gobject_class,
+                                         PROP_CARD_INDEX,
+                                         g_param_spec_long ("card-index",
+                                                             "Card index",
+                                                             "The index of the card for this stream",
+                                                             PA_INVALID_INDEX, G_MAXLONG, PA_INVALID_INDEX,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_type_class_add_private (klass, sizeof (GvcMixerStreamPrivate));
+}
+
+static void
+gvc_mixer_stream_init (GvcMixerStream *stream)
+{
+        stream->priv = GVC_MIXER_STREAM_GET_PRIVATE (stream);
+}
+
+static void
+free_port (GvcMixerStreamPort *p)
+{
+        g_free (p->port);
+        g_free (p->human_port);
+        g_free (p);
+}
+
+static void
+gvc_mixer_stream_finalize (GObject *object)
+{
+        GvcMixerStream *mixer_stream;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_STREAM (object));
+
+        mixer_stream = GVC_MIXER_STREAM (object);
+
+        g_return_if_fail (mixer_stream->priv != NULL);
+
+        g_object_unref (mixer_stream->priv->channel_map);
+        mixer_stream->priv->channel_map = NULL;
+
+        g_free (mixer_stream->priv->name);
+        mixer_stream->priv->name = NULL;
+
+        g_free (mixer_stream->priv->description);
+        mixer_stream->priv->description = NULL;
+
+        g_free (mixer_stream->priv->application_id);
+        mixer_stream->priv->application_id = NULL;
+
+        g_free (mixer_stream->priv->icon_name);
+        mixer_stream->priv->icon_name = NULL;
+
+        g_free (mixer_stream->priv->port);
+        mixer_stream->priv->port = NULL;
+
+        g_free (mixer_stream->priv->human_port);
+        mixer_stream->priv->human_port = NULL;
+
+        g_list_foreach (mixer_stream->priv->ports, (GFunc) free_port, NULL);
+        g_list_free (mixer_stream->priv->ports);
+        mixer_stream->priv->ports = NULL;
+
+       if (mixer_stream->priv->change_volume_op) {
+               pa_operation_unref(mixer_stream->priv->change_volume_op);
+               mixer_stream->priv->change_volume_op = NULL;
+       }
+
+        G_OBJECT_CLASS (gvc_mixer_stream_parent_class)->finalize (object);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-stream.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-stream.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-stream.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-stream.h	2012-09-28 19:08:52.497641697 -0400
@@ -0,0 +1,128 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_STREAM_H
+#define __GVC_MIXER_STREAM_H
+
+#include <glib-object.h>
+#include "gvc-pulseaudio-fake.h"
+#include "gvc-channel-map.h"
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_STREAM         (gvc_mixer_stream_get_type ())
+#define GVC_MIXER_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_STREAM, GvcMixerStream))
+#define GVC_MIXER_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_STREAM, GvcMixerStreamClass))
+#define GVC_IS_MIXER_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_STREAM))
+#define GVC_IS_MIXER_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_STREAM))
+#define GVC_MIXER_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_STREAM, GvcMixerStreamClass))
+
+typedef struct GvcMixerStreamPrivate GvcMixerStreamPrivate;
+
+typedef struct
+{
+        GObject                parent;
+        GvcMixerStreamPrivate *priv;
+} GvcMixerStream;
+
+typedef struct
+{
+        GObjectClass           parent_class;
+
+        /* vtable */
+        gboolean (*push_volume)     (GvcMixerStream *stream,
+                                     gpointer *operation);
+        gboolean (*change_is_muted) (GvcMixerStream *stream,
+                                     gboolean        is_muted);
+        gboolean (*change_port)     (GvcMixerStream *stream,
+                                     const char     *port);
+} GvcMixerStreamClass;
+
+typedef struct
+{
+        char *port;
+        char *human_port;
+        guint priority;
+        gboolean available;        
+} GvcMixerStreamPort;
+
+GType               gvc_mixer_stream_get_type        (void);
+
+guint               gvc_mixer_stream_get_index       (GvcMixerStream *stream);
+guint               gvc_mixer_stream_get_id          (GvcMixerStream *stream);
+const GvcChannelMap *gvc_mixer_stream_get_channel_map(GvcMixerStream *stream);
+const GvcMixerStreamPort *gvc_mixer_stream_get_port  (GvcMixerStream *stream);
+const GList *       gvc_mixer_stream_get_ports       (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_change_port     (GvcMixerStream *stream,
+                                                      const char     *port);
+
+pa_volume_t         gvc_mixer_stream_get_volume      (GvcMixerStream *stream);
+gdouble             gvc_mixer_stream_get_decibel     (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_push_volume     (GvcMixerStream *stream);
+pa_volume_t         gvc_mixer_stream_get_base_volume (GvcMixerStream *stream);
+
+gboolean            gvc_mixer_stream_get_is_muted    (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_get_can_decibel (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_change_is_muted (GvcMixerStream *stream,
+                                                      gboolean        is_muted);
+gboolean            gvc_mixer_stream_is_running      (GvcMixerStream *stream);
+const char *        gvc_mixer_stream_get_name        (GvcMixerStream *stream);
+const char *        gvc_mixer_stream_get_icon_name   (GvcMixerStream *stream);
+GIcon *             gvc_mixer_stream_get_gicon       (GvcMixerStream *stream);
+const char *        gvc_mixer_stream_get_description (GvcMixerStream *stream);
+const char *        gvc_mixer_stream_get_application_id (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_is_event_stream (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_is_virtual      (GvcMixerStream *stream);
+gint                gvc_mixer_stream_get_card_index  (GvcMixerStream *stream);
+
+/* private */
+gboolean            gvc_mixer_stream_set_volume      (GvcMixerStream *stream,
+                                                      pa_volume_t     volume);
+gboolean            gvc_mixer_stream_set_decibel     (GvcMixerStream *stream,
+                                                      gdouble         db);
+gboolean            gvc_mixer_stream_set_is_muted    (GvcMixerStream *stream,
+                                                      gboolean        is_muted);
+gboolean            gvc_mixer_stream_set_can_decibel (GvcMixerStream *stream,
+                                                      gboolean        can_decibel);
+gboolean            gvc_mixer_stream_set_name        (GvcMixerStream *stream,
+                                                      const char     *name);
+gboolean            gvc_mixer_stream_set_description (GvcMixerStream *stream,
+                                                      const char     *description);
+gboolean            gvc_mixer_stream_set_icon_name   (GvcMixerStream *stream,
+                                                      const char     *name);
+gboolean            gvc_mixer_stream_set_is_event_stream (GvcMixerStream *stream,
+                                                          gboolean is_event_stream);
+gboolean            gvc_mixer_stream_set_is_virtual  (GvcMixerStream *stream,
+                                                      gboolean is_event_stream);
+gboolean            gvc_mixer_stream_set_application_id (GvcMixerStream *stream,
+                                                         const char *application_id);
+gboolean            gvc_mixer_stream_set_base_volume (GvcMixerStream *stream,
+                                                      pa_volume_t     base_volume);
+gboolean            gvc_mixer_stream_set_port        (GvcMixerStream *stream,
+                                                      const char     *port);
+gboolean            gvc_mixer_stream_set_ports       (GvcMixerStream *stream,
+                                                      GList          *ports);
+gboolean            gvc_mixer_stream_set_card_index  (GvcMixerStream *stream,
+                                                      gint            card_index);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_STREAM_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-stream-private.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-stream-private.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-stream-private.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-stream-private.h	2012-09-28 19:08:52.498641696 -0400
@@ -0,0 +1,34 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_STREAM_PRIVATE_H
+#define __GVC_MIXER_STREAM_PRIVATE_H
+
+#include <glib-object.h>
+
+#include "gvc-channel-map.h"
+
+G_BEGIN_DECLS
+
+pa_context *        gvc_mixer_stream_get_pa_context  (GvcMixerStream *stream);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_STREAM_PRIVATE_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-ui-device.c gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-ui-device.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-ui-device.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-ui-device.c	2012-09-28 19:08:52.499641694 -0400
@@ -0,0 +1,664 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
+/*
+ * gvc-mixer-ui-device.c
+ * Copyright (C) Conor Curran 2011 <conor.curran@canonical.com>
+ * 
+ * gvc-mixer-ui-device.c is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * gvc-mixer-ui-device.c is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+#include "gvc-mixer-ui-device.h"
+#include "gvc-mixer-card.h"
+
+#define GVC_MIXER_UI_DEVICE_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GVC_TYPE_MIXER_UI_DEVICE, GvcMixerUIDevicePrivate))
+
+static guint32 output_serial = 1;
+
+struct GvcMixerUIDevicePrivate
+{
+	gchar*	     		first_line_desc;
+	gchar*	     		second_line_desc;
+	gint	     		card_id; 
+	gchar*	     		port_name;
+	gint	     		stream_id;
+	guint	     		id;
+	gboolean     		port_available;
+	GList*       		supported_profiles;
+	UiDeviceDirection 	type;
+	GHashTable* 		profiles;
+	gboolean 		disable_profile_swapping;
+	gchar* 			user_preferred_profile;
+};
+
+enum
+{
+	PROP_0,
+	PROP_DESC_LINE_1,
+	PROP_DESC_LINE_2,
+	PROP_CARD_ID,
+	PROP_PORT_NAME,	
+	PROP_STREAM_ID,
+	PROP_UI_DEVICE_TYPE,
+	PROP_PORT_AVAILABLE,
+};
+
+static void     gvc_mixer_ui_device_class_init (GvcMixerUIDeviceClass *klass);
+static void     gvc_mixer_ui_device_init       (GvcMixerUIDevice      *op);
+static void     gvc_mixer_ui_device_finalize   (GObject             *object);
+
+G_DEFINE_TYPE (GvcMixerUIDevice, gvc_mixer_ui_device, G_TYPE_OBJECT);
+
+static guint32
+get_next_output_serial (void)
+{
+        guint32 serial;
+
+        serial = output_serial++;
+
+        if ((gint32)output_serial < 0) {
+                output_serial = 1;
+        }
+        return serial;
+}
+
+static void
+gvc_mixer_ui_device_get_property  (GObject       *object,
+				   guint         property_id,
+				   GValue 	 *value,
+				   GParamSpec    *pspec)
+{
+	  GvcMixerUIDevice *self = GVC_MIXER_UI_DEVICE (object);
+
+	  switch (property_id)
+		{
+		case PROP_DESC_LINE_1:
+			g_value_set_string (value, self->priv->first_line_desc);
+			break;
+		case PROP_DESC_LINE_2:
+			g_value_set_string (value, self->priv->second_line_desc);
+			break;
+		case PROP_CARD_ID:
+			g_value_set_int (value, self->priv->card_id);
+  			break;
+		case PROP_PORT_NAME:
+			g_value_set_string (value, self->priv->port_name);
+			break;
+		case PROP_STREAM_ID:
+			g_value_set_int (value, self->priv->stream_id);
+  			break;
+		case PROP_UI_DEVICE_TYPE:
+			g_value_set_uint (value, (guint)self->priv->type);
+			break;
+		case PROP_PORT_AVAILABLE:
+			g_value_set_boolean (value, self->priv->port_available);
+			break;
+		default:
+			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+			break;
+		}
+}
+
+static void
+gvc_mixer_ui_device_set_property  (GObject      *object,
+				guint         property_id,
+				const GValue *value,
+				GParamSpec   *pspec)
+{
+	  GvcMixerUIDevice *self = GVC_MIXER_UI_DEVICE (object);
+
+	  switch (property_id)
+		{
+		case PROP_DESC_LINE_1:
+			g_free (self->priv->first_line_desc);
+			self->priv->first_line_desc = g_value_dup_string (value);
+			g_debug ("gvc-mixer-output-set-property - 1st line: %s\n",
+				 self->priv->first_line_desc);
+			break;
+		case PROP_DESC_LINE_2:
+			g_free (self->priv->second_line_desc);
+			self->priv->second_line_desc = g_value_dup_string (value);
+			g_debug ("gvc-mixer-output-set-property - 2nd line: %s\n",
+				 self->priv->second_line_desc);
+			break;	
+		case PROP_CARD_ID:
+			self->priv->card_id = g_value_get_int (value);
+			g_debug ("gvc-mixer-output-set-property - card id: %i\n",
+				 self->priv->card_id);
+			break;	
+		case PROP_PORT_NAME:
+			g_free (self->priv->port_name);
+			self->priv->port_name = g_value_dup_string (value);
+			g_debug ("gvc-mixer-output-set-property - card port name: %s\n",
+				 self->priv->port_name);
+			break;	
+		case PROP_STREAM_ID:
+			self->priv->stream_id = g_value_get_int (value);
+			g_debug ("gvc-mixer-output-set-property - sink id: %i\n",
+				 self->priv->stream_id);
+			break;	
+		case PROP_UI_DEVICE_TYPE:
+			self->priv->type = (UiDeviceDirection)g_value_get_uint (value);
+			break;
+		case PROP_PORT_AVAILABLE:
+			self->priv->port_available = g_value_get_boolean (value);
+			g_debug ("gvc-mixer-output-set-property - port available %i, value passed in %i \n",
+				 self->priv->port_available, g_value_get_boolean (value));
+			break;			
+		default:
+			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+			break;
+	    }
+}
+
+static GObject *
+gvc_mixer_ui_device_constructor (GType                  type,
+			         guint                  n_construct_properties,
+		                 GObjectConstructParam *construct_params)
+{
+        GObject         *object;
+        GvcMixerUIDevice  *self;
+
+        object = G_OBJECT_CLASS (gvc_mixer_ui_device_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_UI_DEVICE (object);
+        self->priv->id = get_next_output_serial ();
+        self->priv->profiles = g_hash_table_new_full (g_str_hash,
+         					      g_str_equal,
+         					      g_free,
+         					      NULL);
+	self->priv->stream_id = GVC_MIXER_UI_DEVICE_INVALID;
+	self->priv->card_id = GVC_MIXER_UI_DEVICE_INVALID;
+	self->priv->port_name = NULL;
+	self->priv->disable_profile_swapping = FALSE;
+	self->priv->user_preferred_profile = NULL;
+        return object;
+}
+
+static void
+gvc_mixer_ui_device_init (GvcMixerUIDevice *object)
+{
+	object->priv  = GVC_MIXER_UI_DEVICE_GET_PRIVATE (object);	
+}
+
+static void 
+gvc_mixer_ui_device_dispose (GObject *object)
+{
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_MIXER_UI_DEVICE (object));
+
+	GvcMixerUIDevice *device;
+	device = GVC_MIXER_UI_DEVICE (object);
+	
+	if (device->priv->port_name != NULL){
+		g_free (device->priv->port_name);
+		device->priv->port_name = NULL;
+	}
+	if (device->priv->first_line_desc != NULL){		
+		g_free (device->priv->first_line_desc);
+		device->priv->first_line_desc = NULL;
+	}
+	if (device->priv->second_line_desc != NULL){
+		g_free (device->priv->second_line_desc);
+		device->priv->second_line_desc = NULL;
+	}
+	if (device->priv->profiles != NULL){
+		g_hash_table_destroy (device->priv->profiles);
+		device->priv->profiles = NULL;
+	}
+	if (device->priv->user_preferred_profile != NULL){
+		g_free (device->priv->user_preferred_profile);
+		device->priv->user_preferred_profile = NULL;
+	}
+    G_OBJECT_CLASS (gvc_mixer_ui_device_parent_class)->dispose (object);	
+}
+
+static void
+gvc_mixer_ui_device_finalize (GObject *object)
+{
+	G_OBJECT_CLASS (gvc_mixer_ui_device_parent_class)->finalize (object);
+}
+
+static void
+gvc_mixer_ui_device_class_init (GvcMixerUIDeviceClass *klass)
+{
+	GObjectClass* object_class = G_OBJECT_CLASS (klass);
+
+	object_class->constructor = gvc_mixer_ui_device_constructor;
+	object_class->dispose = gvc_mixer_ui_device_dispose;        
+	object_class->finalize = gvc_mixer_ui_device_finalize;
+	object_class->set_property = gvc_mixer_ui_device_set_property;
+	object_class->get_property = gvc_mixer_ui_device_get_property;
+
+	GParamSpec *pspec;
+
+	pspec = g_param_spec_string ("description",
+				"Description construct prop",
+				"Set first line description",
+				"no-name-set",
+				G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					 PROP_DESC_LINE_1,
+					 pspec);	
+				 
+	pspec = g_param_spec_string ("origin",
+				 "origin construct prop",
+				 "Set second line description name",
+				 "no-name-set",
+				  G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					PROP_DESC_LINE_2,
+					pspec);	
+
+	pspec = g_param_spec_int ("card-id",
+				  "Card id from pulse",
+				  "Set/Get card id",
+				  -1 ,
+				  1000 ,
+				  GVC_MIXER_UI_DEVICE_INVALID,
+				  G_PARAM_READWRITE);
+
+	g_object_class_install_property (object_class,
+					 PROP_CARD_ID,
+					 pspec);
+				 				 
+	pspec = g_param_spec_string ("port-name",
+				 "port-name construct prop",
+				 "Set port-name",
+				 NULL,
+				 G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					 PROP_PORT_NAME,
+					 pspec);	
+
+	pspec = g_param_spec_int ("stream-id",
+				  "stream id assigned by gvc-stream",
+				  "Set/Get stream id",
+				  -1,  
+				   10000, 
+				   GVC_MIXER_UI_DEVICE_INVALID,
+				   G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					 PROP_STREAM_ID,
+					 pspec);
+
+	pspec = g_param_spec_uint ("type",
+				   "ui-device type",
+				   "determine whether its an input and output",
+     				0,
+				    1,
+				    0,
+				    G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					 PROP_UI_DEVICE_TYPE,
+					 pspec);
+
+	pspec = g_param_spec_boolean ( "port-available",
+					"available",
+					"determine whether this port is available",
+					FALSE,
+					G_PARAM_READWRITE);				       
+	g_object_class_install_property (object_class,
+					PROP_PORT_AVAILABLE,
+					pspec);        
+				 
+	g_type_class_add_private (klass, sizeof (GvcMixerUIDevicePrivate));					 				
+}
+
+/*
+ gvc_mixer_ui_device_set_profiles (GvcMixerUIDevice *device, const GList *in_profiles)
+
+ This method attempts to reduce the list of profiles visible to the user by figuring out 
+ from the context of that device (whether it's an input or an output) what profiles actually provide an alternative.
+ 
+ It does this by the following.
+  - It ignores off profiles.
+  - Sorts the incoming profiles by attempting to split each profile on the char '+'.
+     -- This will pull out the relevant aspect of the profile for the type of device this is.
+        e.g stereo analog out, bluetooth or HDMI for an output, stereo analog in or bluetooth for the input coming from  
+        a typical setup of a onboard HDA intel card and bluetooth headset.
+     -- Will store this shortened string against the profile full length name.
+ 
+  - Next it tries to determine from our prepared hash above if we want to allow the user to change
+    the profile on the device i.e.  if the profile combo should be visible to the user on the UI.
+    -- Is there any actual choice or just much of the same thing from the 
+       context of the direction on this device.
+  -If there is a choice
+    -- It will gather the groups of identical profiles and choose the one that has the highest priority to insert
+       into the final list to be presented to the user.
+    - if the shortened profiles are identical so that the profile combo is to be hidden from the user
+     -- It will choose the profile with the highest priority. (the pattern assumes a device will always have a profile in it's profile list)
+Note: 
+ I think this algorithm is inherently flawed.
+ https://bugs.launchpad.net/ubuntu/+source/gnome-control-center/+bug/972554
+ An issue arises in this bug whereby the user needs to get at a specific profile which allows him a certain input and output
+ configuration. But this algorithem because of priority values etc will reject that one profile that he needs to get at. 
+TODO
+ Optimise so as on the first pass you can 'choose' which profiles to hold on to and
+ which are useles because they are essentially duplicates.
+ => a depthfirst like approach is needed ...
+*/
+
+
+/**
+ * get_profile_canonical_name - removes the part of the string that starts with
+ * skip_prefix, i e corresponding to the other direction. Normally either
+ * "input:" or "output:"
+ * @returns string must be freed by user 
+ */
+static gchar *
+get_profile_canonical_name(const gchar *profile_name, const gchar *skip_prefix)
+{
+    gchar *result = g_strdup(profile_name);
+    gchar *c = result;
+   
+    while (*c) {
+        /* Find '\0' or past next '+' */
+        gchar *d = c;
+        while (*d) {
+            if (*d == '+') {
+               d++;
+               break;
+            }
+            d++;
+        }
+
+        if (g_str_has_prefix(c, skip_prefix)) {
+            /* It's the other direction, so remove it from result */
+            gchar *newresult;
+            int i = c - result;
+            result[i] = '\0';
+            newresult = g_strjoin("", result, d, NULL);
+            g_free(result);
+            result = newresult;
+            c = result + i; 
+        }
+        else 
+            c = d;
+    }
+    
+    /* Cut a final '+' off */
+    if (g_str_has_suffix(result, "+"))
+        result[strlen(result)-1] = '\0';
+
+    return result;
+}
+
+const gchar*
+gvc_mixer_ui_device_get_matching_profile (GvcMixerUIDevice *device, const gchar *profile)
+{
+	gchar *skip_prefix = device->priv->type == UiDeviceInput ? "output:" : "input:";
+	gchar *target_cname = get_profile_canonical_name(profile, skip_prefix);
+	GList *t, *values = g_hash_table_get_values(device->priv->profiles);
+	gchar *result = NULL;
+
+	for (t = values; t != NULL; t = t->next) {
+		GvcMixerCardProfile* p = t->data;
+		gchar *canonical_name = get_profile_canonical_name(p->profile, skip_prefix);
+        g_debug("analysing %s", p->profile);
+		if (!strcmp(canonical_name, target_cname)) {
+			result = p->profile;
+		}
+		g_free(canonical_name);
+    }
+
+	g_free(target_cname);
+	g_debug("Matching profile for '%s' is '%s'", profile, result ? result : "(null)");
+	return result;
+}
+
+
+/** gvc_mixer_ui_device_set_profiles
+   @param in_profiles a list of GvcMixerCardProfile
+   assigns value to
+    * device->priv->profiles (profiles to be added to combobox)
+    * device->priv->supported_profiles (all profiles of this port)
+    * device->priv->disable_profile_swapping (whether to show the combobox)
+*/
+void
+gvc_mixer_ui_device_set_profiles (GvcMixerUIDevice *device, const GList *in_profiles)
+{
+	g_debug ("=== SET PROFILES === '%s'", gvc_mixer_ui_device_get_description(device));
+		
+	GList* t;
+	GHashTable *profile_descriptions;
+	GHashTable *added_profiles; 
+	int only_canonical;
+	gchar *skip_prefix = device->priv->type == UiDeviceInput ? "output:" : "input:";
+	
+	if (in_profiles == NULL)
+		return;
+
+	device->priv->supported_profiles = g_list_copy ((GList*) in_profiles);
+
+	added_profiles = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+    
+	/* Run two iterations: First, add profiles which are canonical themselves,
+	   Second, add profiles for which the canonical name is not added already 
+	*/
+	for (only_canonical = 1; only_canonical >= 0; only_canonical--) {
+    	for (t = (GList *) in_profiles; t != NULL; t = t->next) {
+			GvcMixerCardProfile* p = t->data;
+			gchar *canonical_name = get_profile_canonical_name(p->profile, skip_prefix);
+			g_debug("The canonical name for '%s' is '%s'", p->profile, canonical_name);
+
+			/* Have we already added the canonical version of this profile? */
+			if (g_hash_table_contains(added_profiles, canonical_name)) {
+				g_free(canonical_name);
+				continue;
+			}
+
+			if (only_canonical && strcmp(p->profile, canonical_name)) {
+				g_free(canonical_name);
+				continue;
+            }
+
+			g_free(canonical_name);
+
+			g_debug("Adding profile to combobox: '%s' - '%s'", p->profile, p->human_profile);
+            g_hash_table_insert(added_profiles, g_strdup(p->profile), p);
+            g_hash_table_insert(device->priv->profiles, g_strdup(p->human_profile), p);
+        }
+    }
+
+    /* TODO: Consider adding the "Off" profile here */
+
+	device->priv->disable_profile_swapping = g_hash_table_size(added_profiles) <= 1;
+    
+    g_hash_table_destroy(added_profiles);
+}
+
+/** gvc_mixer_ui_device_get_best_profile
+  * @param selected the selected profile or its canonical name - can be NULL
+  * if any profile is okay
+  * @param current the currently selected profile
+  * @returns a profile name, does not need to be freed, valid as long as the 
+  * ui device profiles are
+  */
+const gchar* 			
+gvc_mixer_ui_device_get_best_profile (GvcMixerUIDevice *device, const gchar *selected, 
+const gchar *current)
+{
+	GList *t;
+	GList *candidates = NULL;
+	const gchar *result = NULL;
+	gchar *skip_prefix = device->priv->type == UiDeviceInput ? "output:" : "input:";
+    gchar *canonical_name_selected = NULL;
+
+	/* First make a list of profiles acceptable to switch to */
+	if (selected) 
+		canonical_name_selected = get_profile_canonical_name(selected, skip_prefix);
+
+	for (t = device->priv->supported_profiles; t != NULL; t = t->next) {
+		GvcMixerCardProfile* p = t->data;
+		gchar *canonical_name = get_profile_canonical_name(p->profile, skip_prefix);
+		if (!canonical_name_selected || !strcmp(canonical_name, canonical_name_selected)) {
+			candidates = g_list_append(candidates, p);
+			g_debug("Candidate for profile switching: '%s'", p->profile);
+		}
+	}
+
+	if (!candidates) {
+		g_warning("No suitable profile candidates for '%s'", selected ? selected : "(null)");
+		g_free(canonical_name_selected);
+		return current; 
+	}
+
+	/* 1) Maybe we can skip profile switching altogether? */
+	for (t = candidates; (result == NULL) && (t != NULL); t = t->next) {
+		GvcMixerCardProfile* p = t->data;		
+		if (!strcmp(current, p->profile))
+			result = p->profile;
+	}
+
+	/* 2) Try to keep the other side unchanged if possible */
+	if (result == NULL) {
+		guint prio = 0;
+		gchar *skip_prefix_reverse = device->priv->type == UiDeviceInput ? "input:" : "output:";
+		gchar *current_reverse = get_profile_canonical_name(current, skip_prefix_reverse);
+		for (t = candidates; t != NULL; t = t->next) {
+			GvcMixerCardProfile* p = t->data;
+			gchar *p_reverse = get_profile_canonical_name(p->profile, skip_prefix_reverse);
+			g_debug("Comparing '%s' (from '%s') with '%s', prio %d", p_reverse, p->profile, current_reverse, p->priority); 
+			if (!strcmp(p_reverse, current_reverse) && (!result || p->priority > prio)) {
+				result = p->profile;
+				prio = p->priority;
+			}
+			g_free(p_reverse);
+		}
+		g_free(current_reverse);
+	}
+
+	/* 3) All right, let's just pick the profile with highest priority. 
+		TODO: We could consider asking a GUI question if this stops streams 
+		in the other direction */
+	if (result == NULL) {
+		guint prio = 0;
+		for (t = candidates; t != NULL; t = t->next) {
+			GvcMixerCardProfile* p = t->data;
+			if ((p->priority > prio) || !result) {
+				result = p->profile;
+				prio = p->priority;
+			}
+		}
+	}
+
+	g_list_free(candidates);
+	g_free(canonical_name_selected);
+	return result;
+}
+
+
+gboolean
+gvc_mixer_ui_device_should_profiles_be_hidden (GvcMixerUIDevice *device)
+{
+	return device->priv->disable_profile_swapping;
+}
+
+GHashTable*
+gvc_mixer_ui_device_get_profiles (GvcMixerUIDevice *device)
+{
+	return device->priv->profiles; 
+}
+
+GList*
+gvc_mixer_ui_device_get_supported_profiles (GvcMixerUIDevice *device)
+{
+	return device->priv->supported_profiles;
+}
+
+guint
+gvc_mixer_ui_device_get_id (GvcMixerUIDevice *op)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_UI_DEVICE (op), 0);
+        return op->priv->id;
+}
+
+gint
+gvc_mixer_ui_device_get_stream_id (GvcMixerUIDevice *op)
+{
+	gint sink_id;
+	g_object_get (G_OBJECT (op),
+		      "stream-id", &sink_id, NULL);
+        return sink_id;			
+}
+
+void					
+gvc_mixer_ui_device_invalidate_stream (GvcMixerUIDevice *self)
+{
+	self->priv->stream_id = GVC_MIXER_UI_DEVICE_INVALID;
+}
+
+
+const gchar*
+gvc_mixer_ui_device_get_description (GvcMixerUIDevice *op)
+{
+	return op->priv->first_line_desc;
+}
+
+const gchar*
+gvc_mixer_ui_device_get_origin (GvcMixerUIDevice *op)
+{
+	return op->priv->second_line_desc;
+}
+
+const gchar*
+gvc_mixer_ui_device_get_user_preferred_profile (GvcMixerUIDevice *dev)
+{
+	return dev->priv->user_preferred_profile;
+}
+
+const gchar*
+gvc_mixer_ui_device_get_top_priority_profile (GvcMixerUIDevice *dev)
+{
+	GList *last;
+	last = g_list_last (dev->priv->supported_profiles);
+	GvcMixerCardProfile *profile;
+	profile = last->data;                        
+	return profile->profile;
+}
+
+void 
+gvc_mixer_ui_device_set_user_preferred_profile (GvcMixerUIDevice *device, const gchar* profile)
+{
+	if (device->priv->user_preferred_profile != NULL){
+		g_free (device->priv->user_preferred_profile);
+		device->priv->user_preferred_profile = NULL;
+	}
+	device->priv->user_preferred_profile = g_strdup (profile);
+}
+
+const gchar*
+gvc_mixer_ui_device_get_port (GvcMixerUIDevice *op)
+{
+	return op->priv->port_name;
+}
+
+gboolean
+gvc_mixer_ui_device_is_software (GvcMixerUIDevice *dev)
+{
+	return dev->priv->port_name == NULL && dev->priv->card_id == GVC_MIXER_UI_DEVICE_INVALID;
+}
+
+gboolean
+gvc_mixer_ui_device_is_bluetooth (GvcMixerUIDevice *dev)
+{
+	return dev->priv->port_name == NULL && dev->priv->card_id != GVC_MIXER_UI_DEVICE_INVALID;	
+}
+
+gboolean
+gvc_mixer_ui_device_is_output (GvcMixerUIDevice *dev)
+{
+	return dev->priv->type == UiDeviceOutput;	
+}
+
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-ui-device.h gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-ui-device.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-mixer-ui-device.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-mixer-ui-device.h	2012-09-28 19:08:52.499641694 -0400
@@ -0,0 +1,76 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
+/*
+ * Copyright (C) Conor Curran 2011 <conor.curran@canonical.com>
+ * 
+ * This is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * gvc-mixer-output.c is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _GVC_MIXER_UI_DEVICE_H_
+#define _GVC_MIXER_UI_DEVICE_H_
+
+#include <glib-object.h>
+
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_UI_DEVICE             (gvc_mixer_ui_device_get_type ())
+#define GVC_MIXER_UI_DEVICE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GVC_TYPE_MIXER_UI_DEVICE, GvcMixerUIDevice))
+#define GVC_MIXER_UI_DEVICE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GVC_TYPE_MIXER_UI_DEVICE, GvcMixerUIDeviceClass))
+#define GVC_IS_MIXER_UI_DEVICE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GVC_TYPE_MIXER_UI_DEVICE))
+#define GVC_IS_MIXER_UI_DEVICE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GVC_TYPE_MIXER_UI_DEVICE))
+#define GVC_MIXER_UI_DEVICE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GVC_TYPE_MIXER_UI_DEVICE, GvcMixerUIDeviceClass))
+#define GVC_MIXER_UI_DEVICE_INVALID          -1
+
+typedef struct GvcMixerUIDevicePrivate GvcMixerUIDevicePrivate;
+
+typedef struct
+{
+	GObjectClass parent_class;
+}GvcMixerUIDeviceClass;
+
+typedef struct
+{
+	GObject parent_instance;
+	GvcMixerUIDevicePrivate *priv;	
+}GvcMixerUIDevice;
+
+typedef enum
+{
+	UiDeviceInput,
+	UiDeviceOutput,	
+}UiDeviceDirection;
+
+GType gvc_mixer_ui_device_get_type (void) G_GNUC_CONST;
+
+guint       			gvc_mixer_ui_device_get_id                   		(GvcMixerUIDevice *dev);
+gint        			gvc_mixer_ui_device_get_stream_id            		(GvcMixerUIDevice *dev);
+const gchar*			gvc_mixer_ui_device_get_description          		(GvcMixerUIDevice *dev);
+const gchar*			gvc_mixer_ui_device_get_origin				 		(GvcMixerUIDevice *dev);
+const gchar*			gvc_mixer_ui_device_get_port				 		(GvcMixerUIDevice *dev);
+const gchar* 			gvc_mixer_ui_device_get_best_profile				(GvcMixerUIDevice *dev, const gchar *selected, const gchar *current);
+const gchar* 			gvc_mixer_ui_device_get_matching_profile			(GvcMixerUIDevice *dev, const gchar *profile);
+const gchar* 			gvc_mixer_ui_device_get_user_preferred_profile		(GvcMixerUIDevice *dev);
+const gchar* 			gvc_mixer_ui_device_get_top_priority_profile		(GvcMixerUIDevice *dev);
+GHashTable*				gvc_mixer_ui_device_get_profiles 			 		(GvcMixerUIDevice *dev);
+GList*					gvc_mixer_ui_device_get_supported_profiles			(GvcMixerUIDevice *device);
+gboolean	    		gvc_mixer_ui_device_should_profiles_be_hidden   	(GvcMixerUIDevice *device);
+void					gvc_mixer_ui_device_set_profiles			 		(GvcMixerUIDevice *device, const GList *profiles);
+void 					gvc_mixer_ui_device_set_user_preferred_profile 		(GvcMixerUIDevice *device, const gchar *profile);
+void					gvc_mixer_ui_device_invalidate_stream		 		(GvcMixerUIDevice *dev);
+gboolean				gvc_mixer_ui_device_is_software_stream		 		(GvcMixerUIDevice *dev);
+
+
+G_END_DECLS
+
+#endif /* _GVC_MIXER_UI_DEVICE_H_ */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-pulseaudio-fake.h gnome-control-center-3.6.0/panels/sound-nua/gvc-pulseaudio-fake.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-pulseaudio-fake.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-pulseaudio-fake.h	2012-09-28 19:08:52.500641691 -0400
@@ -0,0 +1,34 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_PULSEAUDIO_FAKE_H
+#define __GVC_PULSEAUDIO_FAKE_H
+
+#ifdef WITH_INTROSPECTION
+
+#ifndef PA_API_VERSION
+#define pa_channel_position_t int
+#define pa_volume_t guint32
+#define pa_context gpointer
+#endif /* PA_API_VERSION */
+
+#endif /* WITH_INTROSPECTION */
+
+#endif /* __GVC_PULSEAUDIO_FAKE_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-sound-theme-chooser.c gnome-control-center-3.6.0/panels/sound-nua/gvc-sound-theme-chooser.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-sound-theme-chooser.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-sound-theme-chooser.c	2012-09-28 19:08:52.501641689 -0400
@@ -0,0 +1,833 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Bastien Nocera <hadess@hadess.net>
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <utime.h>
+#include <errno.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra-gtk.h>
+#include <libxml/tree.h>
+
+#include <gsettings-desktop-schemas/gdesktop-enums.h>
+
+#include "gvc-sound-theme-chooser.h"
+#include "sound-theme-file-utils.h"
+
+#define GVC_SOUND_THEME_CHOOSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_SOUND_THEME_CHOOSER, GvcSoundThemeChooserPrivate))
+
+struct GvcSoundThemeChooserPrivate
+{
+        GtkWidget *treeview;
+        GtkWidget *selection_box;
+        GSettings *settings;
+        GSettings *sound_settings;
+        char *current_theme;
+        char *current_parent;
+};
+
+static void     gvc_sound_theme_chooser_class_init (GvcSoundThemeChooserClass *klass);
+static void     gvc_sound_theme_chooser_init       (GvcSoundThemeChooser      *sound_theme_chooser);
+static void     gvc_sound_theme_chooser_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcSoundThemeChooser, gvc_sound_theme_chooser, GTK_TYPE_VBOX)
+
+#define KEY_SOUNDS_SCHEMA          "org.gnome.desktop.sound"
+#define EVENT_SOUNDS_KEY           "event-sounds"
+#define INPUT_SOUNDS_KEY           "input-feedback-sounds"
+#define SOUND_THEME_KEY            "theme-name"
+
+#define WM_SCHEMA                  "org.gnome.desktop.wm.preferences"
+#define AUDIO_BELL_KEY             "audible-bell"
+
+#define DEFAULT_ALERT_ID        "__default"
+#define CUSTOM_THEME_NAME       "__custom"
+#define NO_SOUNDS_THEME_NAME    "__no_sounds"
+#define DEFAULT_THEME           "ubuntu"
+
+enum {
+        THEME_DISPLAY_COL,
+        THEME_IDENTIFIER_COL,
+        THEME_PARENT_ID_COL,
+        THEME_NUM_COLS
+};
+
+enum {
+        ALERT_DISPLAY_COL,
+        ALERT_IDENTIFIER_COL,
+        ALERT_SOUND_TYPE_COL,
+        ALERT_NUM_COLS
+};
+
+enum {
+        SOUND_TYPE_UNSET,
+        SOUND_TYPE_OFF,
+        SOUND_TYPE_DEFAULT_FROM_THEME,
+        SOUND_TYPE_BUILTIN,
+        SOUND_TYPE_CUSTOM
+};
+
+#define GVC_SOUND_SOUND    (xmlChar *) "sound"
+#define GVC_SOUND_NAME     (xmlChar *) "name"
+#define GVC_SOUND_FILENAME (xmlChar *) "filename"
+
+/* Adapted from yelp-toc-pager.c */
+static xmlChar *
+xml_get_and_trim_names (xmlNodePtr node)
+{
+        xmlNodePtr cur;
+        xmlChar *keep_lang = NULL;
+        xmlChar *value;
+        int j, keep_pri = INT_MAX;
+
+        const gchar * const * langs = g_get_language_names ();
+
+        value = NULL;
+
+        for (cur = node->children; cur; cur = cur->next) {
+                if (! xmlStrcmp (cur->name, GVC_SOUND_NAME)) {
+                        xmlChar *cur_lang = NULL;
+                        int cur_pri = INT_MAX;
+
+                        cur_lang = xmlNodeGetLang (cur);
+
+                        if (cur_lang) {
+                                for (j = 0; langs[j]; j++) {
+                                        if (g_str_equal (cur_lang, langs[j])) {
+                                                cur_pri = j;
+                                                break;
+                                        }
+                                }
+                        } else {
+                                cur_pri = INT_MAX - 1;
+                        }
+
+                        if (cur_pri <= keep_pri) {
+                                if (keep_lang)
+                                        xmlFree (keep_lang);
+                                if (value)
+                                        xmlFree (value);
+
+                                value = xmlNodeGetContent (cur);
+
+                                keep_lang = cur_lang;
+                                keep_pri = cur_pri;
+                        } else {
+                                if (cur_lang)
+                                        xmlFree (cur_lang);
+                        }
+                }
+        }
+
+        /* Delete all GVC_SOUND_NAME nodes */
+        cur = node->children;
+        while (cur) {
+                xmlNodePtr this = cur;
+                cur = cur->next;
+                if (! xmlStrcmp (this->name, GVC_SOUND_NAME)) {
+                        xmlUnlinkNode (this);
+                        xmlFreeNode (this);
+                }
+        }
+
+        return value;
+}
+
+static void
+populate_model_from_node (GvcSoundThemeChooser *chooser,
+                          GtkTreeModel         *model,
+                          xmlNodePtr            node)
+{
+        xmlNodePtr child;
+        xmlChar   *filename;
+        xmlChar   *name;
+
+        filename = NULL;
+        name = xml_get_and_trim_names (node);
+        for (child = node->children; child; child = child->next) {
+                if (xmlNodeIsText (child)) {
+                        continue;
+                }
+
+                if (xmlStrcmp (child->name, GVC_SOUND_FILENAME) == 0) {
+                        filename = xmlNodeGetContent (child);
+                } else if (xmlStrcmp (child->name, GVC_SOUND_NAME) == 0) {
+                        /* EH? should have been trimmed */
+                }
+        }
+
+        if (filename != NULL && name != NULL) {
+                gtk_list_store_insert_with_values (GTK_LIST_STORE (model),
+                                                   NULL,
+                                                   G_MAXINT,
+                                                   ALERT_IDENTIFIER_COL, filename,
+                                                   ALERT_DISPLAY_COL, name,
+                                                   ALERT_SOUND_TYPE_COL, _("Built-in"),
+                                                   -1);
+        }
+
+        xmlFree (filename);
+        xmlFree (name);
+}
+
+static void
+populate_model_from_file (GvcSoundThemeChooser *chooser,
+                          GtkTreeModel         *model,
+                          const char           *filename)
+{
+        xmlDocPtr  doc;
+        xmlNodePtr root;
+        xmlNodePtr child;
+        gboolean   exists;
+
+        exists = g_file_test (filename, G_FILE_TEST_EXISTS);
+        if (! exists) {
+                return;
+        }
+
+        doc = xmlParseFile (filename);
+        if (doc == NULL) {
+                return;
+        }
+
+        root = xmlDocGetRootElement (doc);
+
+        for (child = root->children; child; child = child->next) {
+                if (xmlNodeIsText (child)) {
+                        continue;
+                }
+                if (xmlStrcmp (child->name, GVC_SOUND_SOUND) != 0) {
+                        continue;
+                }
+
+                populate_model_from_node (chooser, model, child);
+        }
+
+        xmlFreeDoc (doc);
+}
+
+static void
+populate_model_from_dir (GvcSoundThemeChooser *chooser,
+                         GtkTreeModel         *model,
+                         const char           *dirname)
+{
+        GDir       *d;
+        const char *name;
+
+        d = g_dir_open (dirname, 0, NULL);
+        if (d == NULL) {
+                return;
+        }
+
+        while ((name = g_dir_read_name (d)) != NULL) {
+                char *path;
+
+                if (! g_str_has_suffix (name, ".xml")) {
+                        continue;
+                }
+
+                path = g_build_filename (dirname, name, NULL);
+                populate_model_from_file (chooser, model, path);
+                g_free (path);
+        }
+}
+
+static gboolean
+save_alert_sounds (GvcSoundThemeChooser  *chooser,
+                   const char            *id)
+{
+        const char *sounds[3] = { "bell-terminal", "bell-window-system", NULL };
+        char *path;
+
+        if (strcmp (id, DEFAULT_ALERT_ID) == 0) {
+                delete_old_files (sounds);
+                delete_disabled_files (sounds);
+        } else {
+                delete_old_files (sounds);
+                delete_disabled_files (sounds);
+                add_custom_file (sounds, id);
+        }
+
+        /* And poke the directory so the theme gets updated */
+        path = custom_theme_dir_path (NULL);
+        if (utime (path, NULL) != 0) {
+                g_warning ("Failed to update mtime for directory '%s': %s",
+                           path, g_strerror (errno));
+        }
+        g_free (path);
+
+        return FALSE;
+}
+
+
+static void
+update_alert_model (GvcSoundThemeChooser  *chooser,
+                    const char            *id)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (chooser->priv->treeview));
+        gtk_tree_model_get_iter_first (model, &iter);
+        do {
+                char    *this_id;
+
+                gtk_tree_model_get (model, &iter,
+                                    ALERT_IDENTIFIER_COL, &this_id,
+                                    -1);
+
+                if (strcmp (this_id, id) == 0) {
+                        GtkTreeSelection *selection;
+
+                        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (chooser->priv->treeview));
+                        gtk_tree_selection_select_iter (selection, &iter);
+                }
+
+                g_free (this_id);
+        } while (gtk_tree_model_iter_next (model, &iter));
+}
+
+static void
+save_theme_name (GvcSoundThemeChooser *chooser,
+                 const char           *theme_name)
+{
+        /* If the name is empty, use "freedesktop" */
+        if (theme_name == NULL || *theme_name == '\0') {
+                theme_name = DEFAULT_THEME;
+        }
+
+        /* special case for no sounds */
+        if (strcmp (theme_name, NO_SOUNDS_THEME_NAME) == 0) {
+                g_settings_set_boolean (chooser->priv->sound_settings, EVENT_SOUNDS_KEY, FALSE);
+                return;
+        } else {
+                g_settings_set_boolean (chooser->priv->sound_settings, EVENT_SOUNDS_KEY, TRUE);
+        }
+
+        g_settings_set_string (chooser->priv->sound_settings, SOUND_THEME_KEY, theme_name);
+}
+
+static gboolean
+load_theme_file (const char *path,
+                 char      **parent)
+{
+        GKeyFile *file;
+        gboolean hidden;
+
+        file = g_key_file_new ();
+        if (g_key_file_load_from_file (file, path, G_KEY_FILE_KEEP_TRANSLATIONS, NULL) == FALSE) {
+                g_key_file_free (file);
+                return FALSE;
+        }
+        /* Don't add hidden themes to the list */
+        hidden = g_key_file_get_boolean (file, "Sound Theme", "Hidden", NULL);
+        if (!hidden) {
+                /* Save the parent theme, if there's one */
+                if (parent != NULL) {
+                        *parent = g_key_file_get_string (file,
+                                                         "Sound Theme",
+                                                         "Inherits",
+                                                         NULL);
+                }
+        }
+
+        g_key_file_free (file);
+
+        return TRUE;
+}
+
+static gboolean
+load_theme_name (const char *name,
+                 char      **parent)
+{
+        const char * const   *data_dirs;
+        const char           *data_dir;
+        char                 *path;
+        guint                 i;
+        gboolean              res;
+
+        data_dir = g_get_user_data_dir ();
+        path = g_build_filename (data_dir, "sounds", name, "index.theme", NULL);
+        res = load_theme_file (path, parent);
+        g_free (path);
+        if (res)
+                return TRUE;
+
+        data_dirs = g_get_system_data_dirs ();
+        for (i = 0; data_dirs[i] != NULL; i++) {
+                path = g_build_filename (data_dirs[i], "sounds", name, "index.theme", NULL);
+                res = load_theme_file (path, parent);
+                g_free (path);
+                if (res)
+                        return TRUE;
+        }
+
+        return FALSE;
+}
+
+static void
+update_alert (GvcSoundThemeChooser *chooser,
+              const char           *alert_id)
+{
+        gboolean      is_custom;
+        gboolean      is_default;
+        gboolean      add_custom;
+        gboolean      remove_custom;
+
+        is_custom = strcmp (chooser->priv->current_theme, CUSTOM_THEME_NAME) == 0;
+        is_default = strcmp (alert_id, DEFAULT_ALERT_ID) == 0;
+
+        /* So a few possibilities:
+         * 1. Named theme, default alert selected: noop
+         * 2. Named theme, alternate alert selected: create new custom with sound
+         * 3. Custom theme, default alert selected: remove sound and possibly custom
+         * 4. Custom theme, alternate alert selected: update custom sound
+         */
+        add_custom = FALSE;
+        remove_custom = FALSE;
+        if (! is_custom && is_default) {
+                /* remove custom just in case */
+                remove_custom = TRUE;
+        } else if (! is_custom && ! is_default) {
+                if (chooser->priv->current_parent)
+                        create_custom_theme (chooser->priv->current_parent);
+                else
+                        create_custom_theme (DEFAULT_THEME);
+                save_alert_sounds (chooser, alert_id);
+                add_custom = TRUE;
+        } else if (is_custom && is_default) {
+                save_alert_sounds (chooser, alert_id);
+                /* after removing files check if it is empty */
+                if (custom_theme_dir_is_empty ()) {
+                        remove_custom = TRUE;
+                }
+        } else if (is_custom && ! is_default) {
+                save_alert_sounds (chooser, alert_id);
+        }
+
+        if (add_custom) {
+                save_theme_name (chooser, CUSTOM_THEME_NAME);
+        } else if (remove_custom) {
+                delete_custom_theme_dir ();
+                if (is_custom) {
+                        save_theme_name (chooser, chooser->priv->current_parent);
+                }
+        }
+
+        update_alert_model (chooser, alert_id);
+}
+
+static void
+play_preview_for_id (GvcSoundThemeChooser *chooser,
+                     const char           *id)
+{
+        g_return_if_fail (id != NULL);
+
+        /* special case: for the default item on custom themes
+         * play the alert for the parent theme */
+        if (strcmp (id, DEFAULT_ALERT_ID) == 0) {
+                if (chooser->priv->current_parent != NULL) {
+                        ca_gtk_play_for_widget (GTK_WIDGET (chooser), 0,
+                                                CA_PROP_APPLICATION_NAME, _("Sound Preferences"),
+                                                CA_PROP_EVENT_ID, "bell-window-system",
+                                                CA_PROP_CANBERRA_XDG_THEME_NAME, chooser->priv->current_parent,
+                                                CA_PROP_EVENT_DESCRIPTION, _("Testing event sound"),
+                                                CA_PROP_CANBERRA_CACHE_CONTROL, "never",
+                                                CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+#ifdef CA_PROP_CANBERRA_ENABLE
+                                                CA_PROP_CANBERRA_ENABLE, "1",
+#endif
+                                                NULL);
+                } else {
+                        ca_gtk_play_for_widget (GTK_WIDGET (chooser), 0,
+                                                CA_PROP_APPLICATION_NAME, _("Sound Preferences"),
+                                                CA_PROP_EVENT_ID, "bell-window-system",
+                                                CA_PROP_EVENT_DESCRIPTION, _("Testing event sound"),
+                                                CA_PROP_CANBERRA_CACHE_CONTROL, "never",
+                                                CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+#ifdef CA_PROP_CANBERRA_ENABLE
+                                                CA_PROP_CANBERRA_ENABLE, "1",
+#endif
+                                                NULL);
+                }
+        } else {
+                ca_gtk_play_for_widget (GTK_WIDGET (chooser), 0,
+                                        CA_PROP_APPLICATION_NAME, _("Sound Preferences"),
+                                        CA_PROP_MEDIA_FILENAME, id,
+                                        CA_PROP_EVENT_DESCRIPTION, _("Testing event sound"),
+                                        CA_PROP_CANBERRA_CACHE_CONTROL, "never",
+                                        CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+#ifdef CA_PROP_CANBERRA_ENABLE
+                                        CA_PROP_CANBERRA_ENABLE, "1",
+#endif
+                                        NULL);
+
+        }
+}
+
+static void
+on_treeview_selection_changed (GtkTreeSelection     *selection,
+                               GvcSoundThemeChooser *chooser)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        char         *id;
+
+        if (chooser->priv->treeview == NULL) {
+                return;
+        }
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (chooser->priv->treeview));
+
+        if (gtk_tree_selection_get_selected (selection, &model, &iter) == FALSE) {
+                return;
+        }
+
+        id = NULL;
+        gtk_tree_model_get (model, &iter,
+                            ALERT_IDENTIFIER_COL, &id,
+                            -1);
+        if (id == NULL) {
+                return;
+        }
+
+        play_preview_for_id (chooser, id);
+        update_alert (chooser, id);
+        g_free (id);
+}
+
+static gboolean
+on_treeview_button_pressed (GtkTreeView          *treeview,
+                            GdkEventButton       *event,
+                            GvcSoundThemeChooser *chooser)
+{
+        GtkTreeSelection *selection;
+        GtkTreePath      *path;
+
+        selection = gtk_tree_view_get_selection (treeview);
+        if (gtk_tree_view_get_path_at_pos (GTK_TREE_VIEW (treeview),
+                                           event->x, event->y, &path, NULL, NULL, NULL) == FALSE) {
+                return FALSE;
+        }
+
+        if (gtk_tree_selection_path_is_selected (selection, path) == FALSE) {
+                gtk_tree_path_free (path);
+                return FALSE;
+        }
+        gtk_tree_path_free (path);
+
+        on_treeview_selection_changed (selection, chooser);
+
+        return FALSE;
+}
+
+static GtkWidget *
+create_alert_treeview (GvcSoundThemeChooser *chooser)
+{
+        GtkListStore         *store;
+        GtkWidget            *treeview;
+        GtkCellRenderer      *renderer;
+        GtkTreeViewColumn    *column;
+        GtkTreeSelection     *selection;
+
+        treeview = gtk_tree_view_new ();
+        gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview), FALSE);
+        g_signal_connect (treeview,
+                          "button-press-event",
+                          G_CALLBACK (on_treeview_button_pressed),
+                          chooser);
+
+        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (treeview));
+        gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+        g_signal_connect (selection,
+                          "changed",
+                          G_CALLBACK (on_treeview_selection_changed),
+                          chooser);
+
+        /* Setup the tree model, 3 columns:
+         * - display name
+         * - sound id
+         * - sound type
+         */
+        store = gtk_list_store_new (ALERT_NUM_COLS,
+                                    G_TYPE_STRING,
+                                    G_TYPE_STRING,
+                                    G_TYPE_STRING);
+
+        gtk_list_store_insert_with_values (store,
+                                           NULL,
+                                           G_MAXINT,
+                                           ALERT_IDENTIFIER_COL, DEFAULT_ALERT_ID,
+                                           ALERT_DISPLAY_COL, _("Default"),
+                                           ALERT_SOUND_TYPE_COL, _("From theme"),
+                                           -1);
+
+        populate_model_from_dir (chooser, GTK_TREE_MODEL (store), SOUND_SET_DIR);
+
+        gtk_tree_view_set_model (GTK_TREE_VIEW (treeview),
+                                 GTK_TREE_MODEL (store));
+
+        renderer = gtk_cell_renderer_text_new ();
+        column = gtk_tree_view_column_new_with_attributes (_("Name"),
+                                                           renderer,
+                                                           "text", ALERT_DISPLAY_COL,
+                                                           NULL);
+        gtk_tree_view_append_column (GTK_TREE_VIEW (treeview), column);
+
+        return treeview;
+}
+
+static int
+get_file_type (const char *sound_name,
+               char      **linked_name)
+{
+        char *name, *filename;
+
+        *linked_name = NULL;
+
+        name = g_strdup_printf ("%s.disabled", sound_name);
+        filename = custom_theme_dir_path (name);
+        g_free (name);
+
+        if (g_file_test (filename, G_FILE_TEST_IS_REGULAR) != FALSE) {
+                g_free (filename);
+                return SOUND_TYPE_OFF;
+        }
+        g_free (filename);
+
+        /* We only check for .ogg files because those are the
+         * only ones we create */
+        name = g_strdup_printf ("%s.ogg", sound_name);
+        filename = custom_theme_dir_path (name);
+        g_free (name);
+
+        if (g_file_test (filename, G_FILE_TEST_IS_SYMLINK) != FALSE) {
+                *linked_name = g_file_read_link (filename, NULL);
+                g_free (filename);
+                return SOUND_TYPE_CUSTOM;
+        }
+        g_free (filename);
+
+        return SOUND_TYPE_BUILTIN;
+}
+
+static void
+update_alerts_from_theme_name (GvcSoundThemeChooser *chooser,
+                               const char           *name)
+{
+        if (strcmp (name, CUSTOM_THEME_NAME) != 0) {
+                /* reset alert to default */
+                update_alert (chooser, DEFAULT_ALERT_ID);
+        } else {
+                int   sound_type;
+                char *linkname;
+
+                linkname = NULL;
+                sound_type = get_file_type ("bell-terminal", &linkname);
+                g_debug ("Found link: %s", linkname);
+                if (sound_type == SOUND_TYPE_CUSTOM) {
+                        update_alert (chooser, linkname);
+                }
+        }
+}
+
+static void
+update_theme (GvcSoundThemeChooser *chooser)
+{
+        gboolean     events_enabled;
+        char        *last_theme;
+
+        events_enabled = g_settings_get_boolean (chooser->priv->sound_settings, EVENT_SOUNDS_KEY);
+
+        last_theme = chooser->priv->current_theme;
+        if (events_enabled) {
+                chooser->priv->current_theme = g_settings_get_string (chooser->priv->sound_settings, SOUND_THEME_KEY);
+        } else {
+                chooser->priv->current_theme = g_strdup (NO_SOUNDS_THEME_NAME);
+        }
+
+        if (g_strcmp0 (last_theme, chooser->priv->current_theme) != 0) {
+                g_free (chooser->priv->current_parent);
+                if (load_theme_name (chooser->priv->current_theme,
+                                     &chooser->priv->current_parent) == FALSE) {
+                        g_free (chooser->priv->current_theme);
+                        chooser->priv->current_theme = g_strdup (DEFAULT_THEME);
+                        load_theme_name (DEFAULT_THEME,
+                                         &chooser->priv->current_parent);
+                }
+        }
+        g_free (last_theme);
+
+        gtk_widget_set_sensitive (chooser->priv->selection_box, events_enabled);
+
+        update_alerts_from_theme_name (chooser, chooser->priv->current_theme);
+}
+
+static GObject *
+gvc_sound_theme_chooser_constructor (GType                  type,
+                                     guint                  n_construct_properties,
+                                     GObjectConstructParam *construct_params)
+{
+        GObject              *object;
+        GvcSoundThemeChooser *self;
+
+        object = G_OBJECT_CLASS (gvc_sound_theme_chooser_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_SOUND_THEME_CHOOSER (object);
+
+        update_theme (self);
+
+        return object;
+}
+
+static void
+gvc_sound_theme_chooser_class_init (GvcSoundThemeChooserClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_sound_theme_chooser_constructor;
+        object_class->finalize = gvc_sound_theme_chooser_finalize;
+
+        g_type_class_add_private (klass, sizeof (GvcSoundThemeChooserPrivate));
+}
+
+static void
+on_sound_settings_changed (GSettings            *settings,
+                           const char           *key,
+                           GvcSoundThemeChooser *chooser)
+{
+        if (strcmp (key, EVENT_SOUNDS_KEY) == 0) {
+                update_theme (chooser);
+        } else if (strcmp (key, SOUND_THEME_KEY) == 0) {
+                update_theme (chooser);
+        } else if (strcmp (key, INPUT_SOUNDS_KEY) == 0) {
+                update_theme (chooser);
+        }
+}
+
+static void
+on_audible_bell_changed (GSettings            *settings,
+                         const char           *key,
+                         GvcSoundThemeChooser *chooser)
+{
+        update_theme (chooser);
+}
+
+static void
+setup_list_size_constraint (GtkWidget *widget,
+                            GtkWidget *to_size)
+{
+        GtkRequisition req;
+        int            max_height;
+
+        /* constrain height to be the tree height up to a max */
+        max_height = (gdk_screen_get_height (gtk_widget_get_screen (widget))) / 4;
+
+        gtk_widget_get_preferred_size (to_size, NULL, &req);
+
+        gtk_scrolled_window_set_min_content_height (GTK_SCROLLED_WINDOW (widget),
+                                                    MIN (req.height, max_height));
+}
+
+static void
+gvc_sound_theme_chooser_init (GvcSoundThemeChooser *chooser)
+{
+        GtkWidget   *box;
+        GtkWidget   *label;
+        GtkWidget   *scrolled_window;
+        GtkWidget   *alignment;
+        char        *str;
+
+        chooser->priv = GVC_SOUND_THEME_CHOOSER_GET_PRIVATE (chooser);
+
+        chooser->priv->settings = g_settings_new (WM_SCHEMA);
+        chooser->priv->sound_settings = g_settings_new (KEY_SOUNDS_SCHEMA);
+
+        str = g_strdup_printf ("<b>%s</b>", _("C_hoose an alert sound:"));
+        chooser->priv->selection_box = box = gtk_frame_new (str);
+        g_free (str);
+        label = gtk_frame_get_label_widget (GTK_FRAME (box));
+        gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
+        gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
+        gtk_frame_set_shadow_type (GTK_FRAME (box), GTK_SHADOW_NONE);
+
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 6, 0, 0, 0);
+        gtk_container_add (GTK_CONTAINER (alignment), box);
+        gtk_box_pack_start (GTK_BOX (chooser), alignment, TRUE, TRUE, 6);
+
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 6, 0, 0, 0);
+        gtk_container_add (GTK_CONTAINER (box), alignment);
+
+        chooser->priv->treeview = create_alert_treeview (chooser);
+        gtk_label_set_mnemonic_widget (GTK_LABEL (label), chooser->priv->treeview);
+
+        scrolled_window = gtk_scrolled_window_new (NULL, NULL);
+        setup_list_size_constraint (scrolled_window, chooser->priv->treeview);
+
+        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
+                                        GTK_POLICY_NEVER,
+                                        GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolled_window),
+                                             GTK_SHADOW_IN);
+        gtk_container_add (GTK_CONTAINER (scrolled_window), chooser->priv->treeview);
+        gtk_container_add (GTK_CONTAINER (alignment), scrolled_window);
+
+        g_signal_connect (G_OBJECT (chooser->priv->sound_settings), "changed",
+                          G_CALLBACK (on_sound_settings_changed), chooser);
+        g_signal_connect (chooser->priv->settings, "changed::" AUDIO_BELL_KEY,
+                          G_CALLBACK (on_audible_bell_changed), chooser);
+}
+
+static void
+gvc_sound_theme_chooser_finalize (GObject *object)
+{
+        GvcSoundThemeChooser *sound_theme_chooser;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_SOUND_THEME_CHOOSER (object));
+
+        sound_theme_chooser = GVC_SOUND_THEME_CHOOSER (object);
+
+        if (sound_theme_chooser->priv != NULL) {
+                g_object_unref (sound_theme_chooser->priv->settings);
+                g_object_unref (sound_theme_chooser->priv->sound_settings);
+        }
+
+        G_OBJECT_CLASS (gvc_sound_theme_chooser_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_sound_theme_chooser_new (void)
+{
+        GObject *chooser;
+        chooser = g_object_new (GVC_TYPE_SOUND_THEME_CHOOSER,
+                                "spacing", 6,
+                                NULL);
+        return GTK_WIDGET (chooser);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-sound-theme-chooser.h gnome-control-center-3.6.0/panels/sound-nua/gvc-sound-theme-chooser.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-sound-theme-chooser.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-sound-theme-chooser.h	2012-09-28 19:08:52.501641689 -0400
@@ -0,0 +1,54 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_SOUND_THEME_CHOOSER_H
+#define __GVC_SOUND_THEME_CHOOSER_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_SOUND_THEME_CHOOSER         (gvc_sound_theme_chooser_get_type ())
+#define GVC_SOUND_THEME_CHOOSER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_SOUND_THEME_CHOOSER, GvcSoundThemeChooser))
+#define GVC_SOUND_THEME_CHOOSER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_SOUND_THEME_CHOOSER, GvcSoundThemeChooserClass))
+#define GVC_IS_SOUND_THEME_CHOOSER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_SOUND_THEME_CHOOSER))
+#define GVC_IS_SOUND_THEME_CHOOSER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_SOUND_THEME_CHOOSER))
+#define GVC_SOUND_THEME_CHOOSER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_SOUND_THEME_CHOOSER, GvcSoundThemeChooserClass))
+
+typedef struct GvcSoundThemeChooserPrivate GvcSoundThemeChooserPrivate;
+
+typedef struct
+{
+        GtkVBox                      parent;
+        GvcSoundThemeChooserPrivate *priv;
+} GvcSoundThemeChooser;
+
+typedef struct
+{
+        GtkVBoxClass          parent_class;
+} GvcSoundThemeChooserClass;
+
+GType               gvc_sound_theme_chooser_get_type            (void);
+
+GtkWidget *         gvc_sound_theme_chooser_new                 (void);
+
+G_END_DECLS
+
+#endif /* __GVC_SOUND_THEME_CHOOSER_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-speaker-test.c gnome-control-center-3.6.0/panels/sound-nua/gvc-speaker-test.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-speaker-test.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-speaker-test.c	2012-09-28 19:08:52.502641689 -0400
@@ -0,0 +1,531 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Bastien Nocera
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra.h>
+#include <canberra-gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-speaker-test.h"
+#include "gvc-mixer-stream.h"
+/* #include "gvc-mixer-card.h" */
+
+#define GVC_SPEAKER_TEST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_SPEAKER_TEST, GvcSpeakerTestPrivate))
+
+struct GvcSpeakerTestPrivate
+{
+        GtkWidget       *channel_controls[PA_CHANNEL_POSITION_MAX];
+        ca_context      *canberra;
+        GvcMixerStream  *stream;
+        GvcMixerControl *control;
+};
+
+enum {
+        COL_NAME,
+        COL_HUMAN_NAME,
+        NUM_COLS
+};
+
+enum {
+        PROP_0,
+        PROP_STREAM,
+        PROP_CONTROL
+};
+
+static void     gvc_speaker_test_class_init (GvcSpeakerTestClass *klass);
+static void     gvc_speaker_test_init       (GvcSpeakerTest      *speaker_test);
+static void     gvc_speaker_test_finalize   (GObject            *object);
+static void     update_channel_map          (GvcSpeakerTest *speaker_test);
+
+G_DEFINE_TYPE (GvcSpeakerTest, gvc_speaker_test, GTK_TYPE_TABLE)
+
+static const int position_table[] = {
+        /* Position, X, Y */
+        PA_CHANNEL_POSITION_FRONT_LEFT, 0, 0,
+        PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER, 1, 0,
+        PA_CHANNEL_POSITION_FRONT_CENTER, 2, 0,
+        PA_CHANNEL_POSITION_MONO, 2, 0,
+        PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER, 3, 0,
+        PA_CHANNEL_POSITION_FRONT_RIGHT, 4, 0,
+        PA_CHANNEL_POSITION_SIDE_LEFT, 0, 1,
+        PA_CHANNEL_POSITION_SIDE_RIGHT, 4, 1,
+        PA_CHANNEL_POSITION_REAR_LEFT, 0, 2,
+        PA_CHANNEL_POSITION_REAR_CENTER, 2, 2,
+        PA_CHANNEL_POSITION_REAR_RIGHT, 4, 2,
+        PA_CHANNEL_POSITION_LFE, 3, 2
+};
+
+static void
+gvc_speaker_test_set_property (GObject       *object,
+                               guint          prop_id,
+                               const GValue  *value,
+                               GParamSpec    *pspec)
+{
+        GvcSpeakerTest *self = GVC_SPEAKER_TEST (object);
+
+        switch (prop_id) {
+        case PROP_STREAM:
+                self->priv->stream = g_value_dup_object (value);
+                if (self->priv->control != NULL)
+                        update_channel_map (self);
+                break;
+        case PROP_CONTROL:
+                self->priv->control = g_value_dup_object (value);
+                if (self->priv->stream != NULL)
+                        update_channel_map (self);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_speaker_test_get_property (GObject     *object,
+                               guint        prop_id,
+                               GValue      *value,
+                               GParamSpec  *pspec)
+{
+        GvcSpeakerTest *self = GVC_SPEAKER_TEST (object);
+
+        switch (prop_id) {
+        case PROP_STREAM:
+                g_value_set_object (value, self->priv->stream);
+                break;
+        case PROP_CONTROL:
+                g_value_set_object (value, self->priv->control);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_speaker_test_class_init (GvcSpeakerTestClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = gvc_speaker_test_finalize;
+        object_class->set_property = gvc_speaker_test_set_property;
+        object_class->get_property = gvc_speaker_test_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_STREAM,
+                                         g_param_spec_object ("stream",
+                                                              "stream",
+                                                              "The stream",
+                                                              GVC_TYPE_MIXER_STREAM,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_CONTROL,
+                                         g_param_spec_object ("control",
+                                                              "control",
+                                                              "The mixer controller",
+                                                              GVC_TYPE_MIXER_CONTROL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_type_class_add_private (klass, sizeof (GvcSpeakerTestPrivate));
+}
+
+static const char *
+sound_name (pa_channel_position_t position)
+{
+        switch (position) {
+        case PA_CHANNEL_POSITION_FRONT_LEFT:
+                return "audio-channel-front-left";
+        case PA_CHANNEL_POSITION_FRONT_RIGHT:
+                return "audio-channel-front-right";
+        case PA_CHANNEL_POSITION_FRONT_CENTER:
+                return "audio-channel-front-center";
+        case PA_CHANNEL_POSITION_REAR_LEFT:
+                return "audio-channel-rear-left";
+        case PA_CHANNEL_POSITION_REAR_RIGHT:
+                return "audio-channel-rear-right";
+        case PA_CHANNEL_POSITION_REAR_CENTER:
+                return "audio-channel-rear-center";
+        case PA_CHANNEL_POSITION_LFE:
+                return "audio-channel-lfe";
+        case PA_CHANNEL_POSITION_SIDE_LEFT:
+                return "audio-channel-side-left";
+        case PA_CHANNEL_POSITION_SIDE_RIGHT:
+                return "audio-channel-side-right";
+        default:
+                return NULL;
+        }
+}
+
+static const char *
+icon_name (pa_channel_position_t position, gboolean playing)
+{
+        switch (position) {
+        case PA_CHANNEL_POSITION_FRONT_LEFT:
+                return playing ? "audio-speaker-left-testing" : "audio-speaker-left";
+        case PA_CHANNEL_POSITION_FRONT_RIGHT:
+                return playing ? "audio-speaker-right-testing" : "audio-speaker-right";
+        case PA_CHANNEL_POSITION_FRONT_CENTER:
+                return playing ? "audio-speaker-center-testing" : "audio-speaker-center";
+        case PA_CHANNEL_POSITION_REAR_LEFT:
+                return playing ? "audio-speaker-left-back-testing" : "audio-speaker-left-back";
+        case PA_CHANNEL_POSITION_REAR_RIGHT:
+                return playing ? "audio-speaker-right-back-testing" : "audio-speaker-right-back";
+        case PA_CHANNEL_POSITION_REAR_CENTER:
+                return playing ? "audio-speaker-center-back-testing" : "audio-speaker-center-back";
+        case PA_CHANNEL_POSITION_LFE:
+                return playing ? "audio-subwoofer-testing" : "audio-subwoofer";
+        case PA_CHANNEL_POSITION_SIDE_LEFT:
+                return playing ? "audio-speaker-left-side-testing" : "audio-speaker-left-side";
+        case PA_CHANNEL_POSITION_SIDE_RIGHT:
+                return playing ? "audio-speaker-right-side-testing" : "audio-speaker-right-side";
+        default:
+                return NULL;
+        }
+}
+
+static void
+update_button (GtkWidget *control)
+{
+        GtkWidget *button;
+        GtkWidget *image;
+        pa_channel_position_t position;
+        gboolean playing;
+
+        button = g_object_get_data (G_OBJECT (control), "button");
+        image = g_object_get_data (G_OBJECT (control), "image");
+        position = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (control), "position"));
+        playing = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (control), "playing"));
+        gtk_button_set_label (GTK_BUTTON (button), playing ? _("Stop") : _("Test"));
+        gtk_image_set_from_icon_name (GTK_IMAGE (image), icon_name (position, playing), GTK_ICON_SIZE_DIALOG);
+}
+
+static const char *
+pretty_position (pa_channel_position_t position)
+{
+        if (position == PA_CHANNEL_POSITION_LFE)
+                return N_("Subwoofer");
+
+        return pa_channel_position_to_pretty_string (position);
+}
+
+static gboolean
+idle_cb (GtkWidget *control)
+{
+        if (control == NULL)
+                return FALSE;
+
+        /* This is called in the background thread, hence
+         * forward to main thread via idle callback */
+        g_object_set_data (G_OBJECT (control), "playing", GINT_TO_POINTER(FALSE));
+        update_button (control);
+
+        return FALSE;
+}
+
+static void
+finish_cb (ca_context *c, uint32_t id, int error_code, void *userdata)
+{
+        GtkWidget *control = (GtkWidget *) userdata;
+
+        if (error_code == CA_ERROR_DESTROYED || control == NULL)
+                return;
+        g_idle_add ((GSourceFunc) idle_cb, control);
+}
+
+static void
+on_test_button_clicked (GtkButton *button,
+                        GtkWidget *control)
+{
+        gboolean playing;
+        ca_context *canberra;
+
+        canberra = g_object_get_data (G_OBJECT (control), "canberra");
+
+        ca_context_cancel (canberra, 1);
+
+        playing = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (control), "playing"));
+
+        if (playing) {
+                g_object_set_data (G_OBJECT (control), "playing", GINT_TO_POINTER(FALSE));
+        } else {
+                pa_channel_position_t position;
+                const char *name;
+                ca_proplist *proplist;
+
+                position = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (control), "position"));
+
+                ca_proplist_create (&proplist);
+                ca_proplist_sets (proplist, CA_PROP_MEDIA_ROLE, "test");
+                ca_proplist_sets (proplist, CA_PROP_MEDIA_NAME, pretty_position (position));
+                ca_proplist_sets (proplist, CA_PROP_CANBERRA_FORCE_CHANNEL,
+                                  pa_channel_position_to_string (position));
+                ca_proplist_sets (proplist, CA_PROP_CANBERRA_ENABLE, "1");
+
+                name = sound_name (position);
+                if (name != NULL) {
+                        ca_proplist_sets (proplist, CA_PROP_EVENT_ID, name);
+                        playing = ca_context_play_full (canberra, 1, proplist, finish_cb, control) >= 0;
+                }
+
+                if (!playing) {
+                        ca_proplist_sets (proplist, CA_PROP_EVENT_ID, "audio-test-signal");
+                        playing = ca_context_play_full (canberra, 1, proplist, finish_cb, control) >= 0;
+                }
+
+                if (!playing) {
+                        ca_proplist_sets(proplist, CA_PROP_EVENT_ID, "bell-window-system");
+                        playing = ca_context_play_full (canberra, 1, proplist, finish_cb, control) >= 0;
+                }
+                g_object_set_data (G_OBJECT (control), "playing", GINT_TO_POINTER(playing));
+        }
+
+        update_button (control);
+}
+
+static GtkWidget *
+channel_control_new (ca_context *canberra, pa_channel_position_t position)
+{
+        GtkWidget *control;
+        GtkWidget *box;
+        GtkWidget *label;
+        GtkWidget *image;
+        GtkWidget *test_button;
+        const char *name;
+
+        control = gtk_vbox_new (FALSE, 6);
+        g_object_set_data (G_OBJECT (control), "playing", GINT_TO_POINTER(FALSE));
+        g_object_set_data (G_OBJECT (control), "position", GINT_TO_POINTER(position));
+        g_object_set_data (G_OBJECT (control), "canberra", canberra);
+
+        name = icon_name (position, FALSE);
+        if (name == NULL)
+                name = "audio-volume-medium";
+        image = gtk_image_new_from_icon_name (name, GTK_ICON_SIZE_DIALOG);
+        g_object_set_data (G_OBJECT (control), "image", image);
+        gtk_box_pack_start (GTK_BOX (control), image, FALSE, FALSE, 0);
+
+        label = gtk_label_new (pretty_position (position));
+        gtk_box_pack_start (GTK_BOX (control), label, FALSE, FALSE, 0);
+
+        test_button = gtk_button_new_with_label (_("Test"));
+        
+        g_signal_connect (G_OBJECT (test_button), "clicked",
+                          G_CALLBACK (on_test_button_clicked), control);
+        g_object_set_data (G_OBJECT (control), "button", test_button);
+
+        atk_object_add_relationship (gtk_widget_get_accessible (test_button),
+                                     ATK_RELATION_LABELLED_BY,
+                                     gtk_widget_get_accessible (label));
+
+        box = gtk_hbox_new (FALSE, 0);
+        gtk_box_pack_start (GTK_BOX (box), test_button, TRUE, FALSE, 0);
+        gtk_box_pack_start (GTK_BOX (control), box, FALSE, FALSE, 0);
+
+        gtk_widget_show_all (control);
+
+        return control;
+}
+
+static void
+create_channel_controls (GvcSpeakerTest *speaker_test)
+{
+        guint i;
+
+        for (i = 0; i < G_N_ELEMENTS (position_table); i += 3) {
+                speaker_test->priv->channel_controls[position_table[i]] = channel_control_new (speaker_test->priv->canberra, (pa_channel_position_t) position_table[i]);
+                gtk_table_attach (GTK_TABLE (speaker_test),
+                                  speaker_test->priv->channel_controls[position_table[i]],
+                                  position_table[i+1],
+                                  position_table[i+1]+1,
+                                  position_table[i+2],
+                                  position_table[i+2]+1,
+                                  GTK_EXPAND, GTK_EXPAND, 0, 0);
+        }
+}
+
+#if 0
+static const GvcChannelMap *
+get_channel_map_for_card (GvcMixerControl *control,
+                          GvcMixerCard    *card,
+                          char           **output_name)
+{
+        int card_index;
+        GSList *sinks, *l;
+        GvcMixerStream *stream;
+        const GvcChannelMap *map;
+
+        /* This gets the channel map for the only
+         * output for the card */
+
+        card_index = gvc_mixer_card_get_index (card);
+        if (card_index == PA_INVALID_INDEX)
+                return NULL;
+        sinks = gvc_mixer_control_get_sinks (control);
+        stream = NULL;
+        for (l = sinks; l != NULL; l = l->next) {
+                GvcMixerStream *s = l->data;
+                if (gvc_mixer_stream_get_card_index (s) == card_index) {
+                        stream = g_object_ref (s);
+                        break;
+                }
+        }
+        g_slist_free (sinks);
+
+        if (stream == NULL)
+		return NULL;
+
+        g_debug ("Found stream '%s' for card '%s'",
+                 gvc_mixer_stream_get_name (stream),
+                 gvc_mixer_card_get_name (card));
+
+        *output_name = g_strdup (gvc_mixer_stream_get_name (stream));
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        g_debug ("Got channel map '%s' for port '%s'",
+                 gvc_channel_map_get_mapping (map), *output_name);
+
+        return map;
+}
+#endif
+
+static void
+update_channel_map (GvcSpeakerTest *speaker_test)
+{
+        guint i;
+        const GvcChannelMap *map;
+        char *output_name;
+
+        g_return_if_fail (speaker_test->priv->control != NULL);
+        g_return_if_fail (speaker_test->priv->stream != NULL);
+
+        g_debug ("XXX update_channel_map called XXX");
+
+        map = gvc_mixer_stream_get_channel_map (speaker_test->priv->stream);
+/*
+        map = get_channel_map_for_stream (speaker_test->priv->control,
+                                        speaker_test->priv->stream,
+                                        &output_name);
+*/
+        g_return_if_fail (map != NULL);
+
+        ca_context_change_device (speaker_test->priv->canberra, 
+                                  gvc_mixer_stream_get_name (speaker_test->priv->stream));
+        g_free (output_name);
+
+        for (i = 0; i < G_N_ELEMENTS (position_table); i += 3) {
+                gtk_widget_set_visible (speaker_test->priv->channel_controls[position_table[i]],
+                                        gvc_channel_map_has_position(map, position_table[i]));
+        }
+}
+
+static void
+gvc_speaker_test_set_theme (ca_context *ca)
+{
+        GtkSettings *settings;
+        char *theme_name;
+
+        settings = gtk_settings_get_for_screen (gdk_screen_get_default ());
+
+        g_object_get (G_OBJECT (settings),
+                      "gtk-sound-theme-name", &theme_name,
+                      NULL);
+
+        if (theme_name)
+                ca_context_change_props (ca, CA_PROP_CANBERRA_XDG_THEME_NAME, theme_name, NULL);
+
+        g_free (theme_name);
+}
+
+static void
+gvc_speaker_test_init (GvcSpeakerTest *speaker_test)
+{
+        GtkWidget *face;
+
+        speaker_test->priv = GVC_SPEAKER_TEST_GET_PRIVATE (speaker_test);
+
+        ca_context_create (&speaker_test->priv->canberra);
+        ca_context_set_driver (speaker_test->priv->canberra, "pulse");
+        ca_context_change_props (speaker_test->priv->canberra,
+                                 CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+                                 NULL);
+        gvc_speaker_test_set_theme (speaker_test->priv->canberra);
+
+        gtk_widget_set_direction (GTK_WIDGET (speaker_test), GTK_TEXT_DIR_LTR);
+        gtk_table_resize (GTK_TABLE (speaker_test), 3, 5);
+        gtk_container_set_border_width (GTK_CONTAINER (speaker_test), 12);
+        gtk_table_set_homogeneous (GTK_TABLE (speaker_test), TRUE);
+        gtk_table_set_row_spacings (GTK_TABLE (speaker_test), 12);
+        gtk_table_set_col_spacings (GTK_TABLE (speaker_test), 12);
+
+        create_channel_controls (speaker_test);
+
+        face = gtk_image_new_from_icon_name ("face-smile", GTK_ICON_SIZE_DIALOG);
+        gtk_table_attach (GTK_TABLE (speaker_test), face,
+                          2, 3, 1, 2, GTK_EXPAND, GTK_EXPAND, 0, 0);
+        gtk_widget_show (face);
+}
+
+static void
+gvc_speaker_test_finalize (GObject *object)
+{
+        GvcSpeakerTest *speaker_test;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_SPEAKER_TEST (object));
+
+        speaker_test = GVC_SPEAKER_TEST (object);
+
+        g_return_if_fail (speaker_test->priv != NULL);
+
+        g_object_unref (speaker_test->priv->stream);
+        speaker_test->priv->stream = NULL;
+
+        g_object_unref (speaker_test->priv->control);
+        speaker_test->priv->control = NULL;
+
+        ca_context_destroy (speaker_test->priv->canberra);
+        speaker_test->priv->canberra = NULL;
+
+        G_OBJECT_CLASS (gvc_speaker_test_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_speaker_test_new (GvcMixerControl *control,
+                      GvcMixerStream *stream)
+{
+        GObject *speaker_test;
+
+        g_return_val_if_fail (stream != NULL, NULL);
+        g_return_val_if_fail (control != NULL, NULL);
+
+        speaker_test = g_object_new (GVC_TYPE_SPEAKER_TEST,
+                                  "stream", stream,
+                                  "control", control,
+                                  NULL);
+
+        return GTK_WIDGET (speaker_test);
+}
+
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-speaker-test.h gnome-control-center-3.6.0/panels/sound-nua/gvc-speaker-test.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-speaker-test.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-speaker-test.h	2012-09-28 19:08:52.503641691 -0400
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_SPEAKER_TEST_H
+#define __GVC_SPEAKER_TEST_H
+
+#include <glib-object.h>
+#include <gvc-mixer-card.h>
+#include <gvc-mixer-control.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_SPEAKER_TEST         (gvc_speaker_test_get_type ())
+#define GVC_SPEAKER_TEST(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_SPEAKER_TEST, GvcSpeakerTest))
+#define GVC_SPEAKER_TEST_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_SPEAKER_TEST, GvcSpeakerTestClass))
+#define GVC_IS_SPEAKER_TEST(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_SPEAKER_TEST))
+#define GVC_IS_SPEAKER_TEST_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_SPEAKER_TEST))
+#define GVC_SPEAKER_TEST_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_SPEAKER_TEST, GvcSpeakerTestClass))
+
+typedef struct GvcSpeakerTestPrivate GvcSpeakerTestPrivate;
+
+typedef struct
+{
+        GtkNotebook               parent;
+        GvcSpeakerTestPrivate *priv;
+} GvcSpeakerTest;
+
+typedef struct
+{
+        GtkNotebookClass        parent_class;
+} GvcSpeakerTestClass;
+
+GType               gvc_speaker_test_get_type            (void);
+
+GtkWidget *         gvc_speaker_test_new                 (GvcMixerControl *control,
+                                                          GvcMixerStream *stream);
+
+G_END_DECLS
+
+#endif /* __GVC_SPEAKER_TEST_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-stream-status-icon.c gnome-control-center-3.6.0/panels/sound-nua/gvc-stream-status-icon.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-stream-status-icon.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-stream-status-icon.c	2012-09-28 19:08:52.504641692 -0400
@@ -0,0 +1,780 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-stream.h"
+#include "gvc-channel-bar.h"
+#include "gvc-stream-status-icon.h"
+
+#define GVC_STREAM_STATUS_ICON_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_STREAM_STATUS_ICON, GvcStreamStatusIconPrivate))
+
+struct GvcStreamStatusIconPrivate
+{
+        char          **icon_names;
+        GvcMixerStream *mixer_stream;
+        GtkWidget      *dock;
+        GtkWidget      *bar;
+        guint           current_icon;
+        char           *display_name;
+        gboolean        thaw;
+};
+
+enum
+{
+        PROP_0,
+        PROP_DISPLAY_NAME,
+        PROP_MIXER_STREAM,
+        PROP_ICON_NAMES,
+};
+
+static void     gvc_stream_status_icon_class_init (GvcStreamStatusIconClass *klass);
+static void     gvc_stream_status_icon_init       (GvcStreamStatusIcon      *stream_status_icon);
+static void     gvc_stream_status_icon_finalize   (GObject                  *object);
+
+G_DEFINE_TYPE (GvcStreamStatusIcon, gvc_stream_status_icon, GTK_TYPE_STATUS_ICON)
+
+static void
+on_adjustment_value_changed (GtkAdjustment *adjustment,
+                             GvcStreamStatusIcon     *icon)
+{
+        gdouble volume;
+
+        if (icon->priv->thaw)
+                return;
+
+        volume = gtk_adjustment_get_value (adjustment);
+
+        /* Only push the volume if it's actually changed */
+        if (gvc_mixer_stream_set_volume(icon->priv->mixer_stream,
+                                    (pa_volume_t) round (volume)) != FALSE) {
+                gvc_mixer_stream_push_volume(icon->priv->mixer_stream);
+        }
+}
+
+static void
+update_dock (GvcStreamStatusIcon *icon)
+{
+        GtkAdjustment *adj;
+        gboolean       is_muted;
+
+        g_return_if_fail (icon);
+
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (icon->priv->bar)));
+
+        icon->priv->thaw = TRUE;
+        gtk_adjustment_set_value (adj,
+                                  gvc_mixer_stream_get_volume (icon->priv->mixer_stream));
+        is_muted = gvc_mixer_stream_get_is_muted (icon->priv->mixer_stream);
+        gvc_channel_bar_set_is_muted (GVC_CHANNEL_BAR (icon->priv->bar), is_muted);
+        icon->priv->thaw = FALSE;
+}
+
+static gboolean
+popup_dock (GvcStreamStatusIcon *icon,
+            guint                time)
+{
+        GdkRectangle   area;
+        GtkOrientation orientation;
+        GdkDisplay    *display;
+        GdkScreen     *screen;
+        gboolean       res;
+        int            x;
+        int            y;
+        int            monitor_num;
+        GdkRectangle   monitor;
+        GtkRequisition dock_req;
+
+        update_dock (icon);
+
+        screen = gtk_status_icon_get_screen (GTK_STATUS_ICON (icon));
+        res = gtk_status_icon_get_geometry (GTK_STATUS_ICON (icon),
+                                            &screen,
+                                            &area,
+                                            &orientation);
+        if (! res) {
+                g_warning ("Unable to determine geometry of status icon");
+                return FALSE;
+        }
+
+        /* position roughly */
+        gtk_window_set_screen (GTK_WINDOW (icon->priv->dock), screen);
+        gvc_channel_bar_set_orientation (GVC_CHANNEL_BAR (icon->priv->bar),
+                                         1 - orientation);
+
+        monitor_num = gdk_screen_get_monitor_at_point (screen, area.x, area.y);
+        gdk_screen_get_monitor_geometry (screen, monitor_num, &monitor);
+
+        gtk_container_foreach (GTK_CONTAINER (icon->priv->dock),
+                               (GtkCallback) gtk_widget_show_all, NULL);
+        gtk_widget_get_preferred_size (icon->priv->dock, &dock_req, NULL);
+
+        if (orientation == GTK_ORIENTATION_VERTICAL) {
+                if (area.x + area.width + dock_req.width <= monitor.x + monitor.width) {
+                        x = area.x + area.width;
+                } else {
+                        x = area.x - dock_req.width;
+                }
+                if (area.y + dock_req.height <= monitor.y + monitor.height) {
+                        y = area.y;
+                } else {
+                        y = monitor.y + monitor.height - dock_req.height;
+                }
+        } else {
+                if (area.y + area.height + dock_req.height <= monitor.y + monitor.height) {
+                        y = area.y + area.height;
+                } else {
+                        y = area.y - dock_req.height;
+                }
+                if (area.x + dock_req.width <= monitor.x + monitor.width) {
+                        x = area.x;
+                } else {
+                        x = monitor.x + monitor.width - dock_req.width;
+                }
+        }
+
+        gtk_window_move (GTK_WINDOW (icon->priv->dock), x, y);
+
+        /* FIXME: without this, the popup window appears as a square
+         * after changing the orientation
+         */
+        gtk_window_resize (GTK_WINDOW (icon->priv->dock), 1, 1);
+
+        gtk_widget_show_all (icon->priv->dock);
+
+        /* grab focus */
+        gtk_grab_add (icon->priv->dock);
+
+        if (gdk_pointer_grab (gtk_widget_get_window (icon->priv->dock), TRUE,
+                              GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+                              GDK_POINTER_MOTION_MASK | GDK_SCROLL_MASK, NULL, NULL,
+                              time)
+            != GDK_GRAB_SUCCESS) {
+                gtk_grab_remove (icon->priv->dock);
+                gtk_widget_hide (icon->priv->dock);
+                return FALSE;
+        }
+
+        if (gdk_keyboard_grab (gtk_widget_get_window (icon->priv->dock), TRUE, time) != GDK_GRAB_SUCCESS) {
+                display = gtk_widget_get_display (icon->priv->dock);
+                gdk_display_pointer_ungrab (display, time);
+                gtk_grab_remove (icon->priv->dock);
+                gtk_widget_hide (icon->priv->dock);
+                return FALSE;
+        }
+
+        gtk_widget_grab_focus (icon->priv->dock);
+
+        return TRUE;
+}
+
+static void
+on_status_icon_activate (GtkStatusIcon       *status_icon,
+                         GvcStreamStatusIcon *icon)
+{
+        popup_dock (icon, GDK_CURRENT_TIME);
+}
+
+static void
+on_menu_mute_toggled (GtkMenuItem         *item,
+                      GvcStreamStatusIcon *icon)
+{
+        gboolean is_muted;
+        is_muted = gtk_check_menu_item_get_active (GTK_CHECK_MENU_ITEM (item));
+        gvc_channel_bar_set_is_muted (GVC_CHANNEL_BAR (icon->priv->bar), is_muted);
+}
+
+static void
+on_menu_activate_open_volume_control (GtkMenuItem *item,
+                                      GvcStreamStatusIcon   *icon)
+{
+        GAppInfo *app;
+        GdkAppLaunchContext *context;
+        GError *error;
+
+        error = NULL;
+        context = gdk_app_launch_context_new ();
+        app = g_app_info_create_from_commandline ("gnome-control-center sound", "Sound preferences", 0, &error);
+        if (app)
+                g_app_info_launch (app, NULL, G_APP_LAUNCH_CONTEXT (context), &error);
+
+        if (error != NULL) {
+                GtkWidget *dialog;
+
+                dialog = gtk_message_dialog_new (NULL,
+                                                 0,
+                                                 GTK_MESSAGE_ERROR,
+                                                 GTK_BUTTONS_CLOSE,
+                                                 _("Failed to start Sound Preferences: %s"),
+                                                 error->message);
+                g_signal_connect (dialog,
+                                  "response",
+                                  G_CALLBACK (gtk_widget_destroy),
+                                  NULL);
+                gtk_widget_show (dialog);
+                g_error_free (error);
+        }
+
+        g_object_unref (context);
+        g_object_unref (app);
+}
+
+static void
+on_status_icon_popup_menu (GtkStatusIcon       *status_icon,
+                           guint                button,
+                           guint                activate_time,
+                           GvcStreamStatusIcon *icon)
+{
+        GtkWidget *menu;
+        GtkWidget *item;
+        GtkWidget *image;
+
+        menu = gtk_menu_new ();
+
+        item = gtk_check_menu_item_new_with_mnemonic (_("_Mute"));
+        gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item),
+                                        gvc_mixer_stream_get_is_muted (icon->priv->mixer_stream));
+        g_signal_connect (item,
+                          "toggled",
+                          G_CALLBACK (on_menu_mute_toggled),
+                          icon);
+        gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
+
+        item = gtk_image_menu_item_new_with_mnemonic (_("_Sound Preferences"));
+        image = gtk_image_new_from_icon_name ("multimedia-volume-control",
+                                              GTK_ICON_SIZE_MENU);
+        gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), image);
+        g_signal_connect (item,
+                          "activate",
+                          G_CALLBACK (on_menu_activate_open_volume_control),
+                          icon);
+        gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
+
+        gtk_widget_show_all (menu);
+        gtk_menu_popup (GTK_MENU (menu),
+                        NULL,
+                        NULL,
+                        gtk_status_icon_position_menu,
+                        status_icon,
+                        button,
+                        activate_time);
+}
+
+static gboolean
+on_status_icon_scroll_event (GtkStatusIcon       *status_icon,
+                             GdkEventScroll      *event,
+                             GvcStreamStatusIcon *icon)
+{
+        return gvc_channel_bar_scroll (GVC_CHANNEL_BAR (icon->priv->bar), event);
+}
+
+static void
+gvc_icon_release_grab (GvcStreamStatusIcon *icon,
+                         GdkEventButton    *event)
+{
+        GdkDisplay     *display;
+
+        /* ungrab focus */
+        display = gtk_widget_get_display (GTK_WIDGET (icon->priv->dock));
+        gdk_display_keyboard_ungrab (display, event->time);
+        gdk_display_pointer_ungrab (display, event->time);
+        gtk_grab_remove (icon->priv->dock);
+
+        /* hide again */
+        gtk_widget_hide (icon->priv->dock);
+}
+
+static gboolean
+on_dock_button_press (GtkWidget      *widget,
+                      GdkEventButton *event,
+                      GvcStreamStatusIcon      *icon)
+{
+        if (event->type == GDK_BUTTON_PRESS) {
+                gvc_icon_release_grab (icon, event);
+                return TRUE;
+        }
+
+        return FALSE;
+}
+
+static void
+popdown_dock (GvcStreamStatusIcon *icon)
+{
+        GdkDisplay *display;
+
+        /* ungrab focus */
+        display = gtk_widget_get_display (icon->priv->dock);
+        gdk_display_keyboard_ungrab (display, GDK_CURRENT_TIME);
+        gdk_display_pointer_ungrab (display, GDK_CURRENT_TIME);
+        gtk_grab_remove (icon->priv->dock);
+
+        /* hide again */
+        gtk_widget_hide (icon->priv->dock);
+}
+
+static gboolean
+on_dock_key_release (GtkWidget           *widget,
+                     GdkEventKey         *event,
+                     GvcStreamStatusIcon *icon)
+{
+        if (event->keyval == GDK_KEY_Escape) {
+                popdown_dock (icon);
+                return TRUE;
+        }
+
+#if 0
+        if (!gtk_bindings_activate_event (GTK_OBJECT (widget), event)) {
+                /* The popup hasn't managed the event, pass onto the button */
+                gtk_bindings_activate_event (GTK_OBJECT (user_data), event);
+        }
+#endif
+        return TRUE;
+}
+
+static gboolean
+on_dock_scroll_event (GtkWidget           *widget,
+                      GdkEventScroll      *event,
+                      GvcStreamStatusIcon *icon)
+{
+        /* Forward event to the status icon */
+        on_status_icon_scroll_event (NULL, event, icon);
+        return TRUE;
+}
+
+static void
+update_icon (GvcStreamStatusIcon *icon)
+{
+        guint    volume;
+        gboolean is_muted;
+        guint    n;
+        char    *markup;
+        gboolean can_decibel;
+        gdouble  db;
+
+        if (icon->priv->mixer_stream == NULL) {
+                return;
+        }
+
+        volume = gvc_mixer_stream_get_volume (icon->priv->mixer_stream);
+        is_muted = gvc_mixer_stream_get_is_muted (icon->priv->mixer_stream);
+        db = gvc_mixer_stream_get_decibel (icon->priv->mixer_stream);
+        can_decibel = gvc_mixer_stream_get_can_decibel (icon->priv->mixer_stream);
+
+        /* select image */
+        if (volume <= 0 || is_muted) {
+                n = 0;
+        } else {
+                n = 3 * volume / PA_VOLUME_NORM + 1;
+                if (n < 1) {
+                        n = 1;
+                } else if (n > 3) {
+                        n = 3;
+                }
+        }
+
+        /* apparently status icon will reset icon even if
+         * if doesn't change */
+        if (icon->priv->current_icon != n) {
+                gtk_status_icon_set_from_icon_name (GTK_STATUS_ICON (icon),
+                                                    icon->priv->icon_names [n]);
+                icon->priv->current_icon = n;
+        }
+
+
+        if (is_muted) {
+                markup = g_strdup_printf (
+                                          "<b>%s: %s</b>\n<small>%s</small>",
+                                          icon->priv->display_name,
+                                          _("Muted"),
+                                          gvc_mixer_stream_get_description (icon->priv->mixer_stream));
+        } else if (can_decibel && (db > PA_DECIBEL_MININFTY)) {
+                markup = g_strdup_printf (
+                                          "<b>%s: %.0f%%</b>\n<small>%0.2f dB\n%s</small>",
+                                          icon->priv->display_name,
+                                          100 * (float)volume / PA_VOLUME_NORM,
+                                          db,
+                                          gvc_mixer_stream_get_description (icon->priv->mixer_stream));
+        } else if (can_decibel) {
+                markup = g_strdup_printf (
+                                          "<b>%s: %.0f%%</b>\n<small>-&#8734; dB\n%s</small>",
+                                          icon->priv->display_name,
+                                          100 * (float)volume / PA_VOLUME_NORM,
+                                          gvc_mixer_stream_get_description (icon->priv->mixer_stream));
+        } else {
+                markup = g_strdup_printf (
+                                          "<b>%s: %.0f%%</b>\n<small>%s</small>",
+                                          icon->priv->display_name,
+                                          100 * (float)volume / PA_VOLUME_NORM,
+                                          gvc_mixer_stream_get_description (icon->priv->mixer_stream));
+        }
+        gtk_status_icon_set_tooltip_markup (GTK_STATUS_ICON (icon), markup);
+        g_free (markup);
+}
+
+void
+gvc_stream_status_icon_set_icon_names (GvcStreamStatusIcon  *icon,
+                                       const char          **names)
+{
+        g_return_if_fail (GVC_IS_STREAM_STATUS_ICON (icon));
+
+        g_strfreev (icon->priv->icon_names);
+        icon->priv->icon_names = g_strdupv ((char **)names);
+        update_icon (icon);
+        g_object_notify (G_OBJECT (icon), "icon-names");
+}
+
+static void
+on_stream_volume_notify (GObject             *object,
+                         GParamSpec          *pspec,
+                         GvcStreamStatusIcon *icon)
+{
+        update_icon (icon);
+        update_dock (icon);
+}
+
+static void
+on_stream_is_muted_notify (GObject             *object,
+                           GParamSpec          *pspec,
+                           GvcStreamStatusIcon *icon)
+{
+        update_icon (icon);
+        update_dock (icon);
+}
+
+void
+gvc_stream_status_icon_set_display_name (GvcStreamStatusIcon *icon,
+                                         const char          *name)
+{
+        g_return_if_fail (GVC_STREAM_STATUS_ICON (icon));
+
+        g_free (icon->priv->display_name);
+        icon->priv->display_name = g_strdup (name);
+        update_icon (icon);
+        g_object_notify (G_OBJECT (icon), "display-name");
+}
+
+void
+gvc_stream_status_icon_set_mixer_stream (GvcStreamStatusIcon *icon,
+                                         GvcMixerStream      *stream)
+{
+        g_return_if_fail (GVC_STREAM_STATUS_ICON (icon));
+
+        if (stream != NULL) {
+                g_object_ref (stream);
+        }
+
+        if (icon->priv->mixer_stream != NULL) {
+                g_signal_handlers_disconnect_by_func (icon->priv->mixer_stream,
+                                                      G_CALLBACK (on_stream_volume_notify),
+                                                      icon);
+                g_signal_handlers_disconnect_by_func (icon->priv->mixer_stream,
+                                                      G_CALLBACK (on_stream_is_muted_notify),
+                                                      icon);
+                g_object_unref (icon->priv->mixer_stream);
+                icon->priv->mixer_stream = NULL;
+        }
+
+        icon->priv->mixer_stream = stream;
+
+        if (icon->priv->mixer_stream != NULL) {
+                GtkAdjustment *adj;
+
+                g_object_ref (icon->priv->mixer_stream);
+
+                icon->priv->thaw = TRUE;
+                adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (icon->priv->bar)));
+                gtk_adjustment_set_value (adj,
+                                          gvc_mixer_stream_get_volume (icon->priv->mixer_stream));
+                icon->priv->thaw = FALSE;
+
+                g_signal_connect (icon->priv->mixer_stream,
+                                  "notify::volume",
+                                  G_CALLBACK (on_stream_volume_notify),
+                                  icon);
+                g_signal_connect (icon->priv->mixer_stream,
+                                  "notify::is-muted",
+                                  G_CALLBACK (on_stream_is_muted_notify),
+                                  icon);
+        }
+
+        update_icon (icon);
+
+        g_object_notify (G_OBJECT (icon), "mixer-stream");
+}
+
+static void
+gvc_stream_status_icon_set_property (GObject       *object,
+                                     guint          prop_id,
+                                     const GValue  *value,
+                                     GParamSpec    *pspec)
+{
+        GvcStreamStatusIcon *self = GVC_STREAM_STATUS_ICON (object);
+
+        switch (prop_id) {
+        case PROP_MIXER_STREAM:
+                gvc_stream_status_icon_set_mixer_stream (self, g_value_get_object (value));
+                break;
+        case PROP_DISPLAY_NAME:
+                gvc_stream_status_icon_set_display_name (self, g_value_get_string (value));
+                break;
+        case PROP_ICON_NAMES:
+                gvc_stream_status_icon_set_icon_names (self, g_value_get_boxed (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_stream_status_icon_get_property (GObject     *object,
+                                     guint        prop_id,
+                                     GValue      *value,
+                                     GParamSpec  *pspec)
+{
+        GvcStreamStatusIcon *self = GVC_STREAM_STATUS_ICON (object);
+        GvcStreamStatusIconPrivate *priv = self->priv;
+
+        switch (prop_id) {
+        case PROP_MIXER_STREAM:
+                g_value_set_object (value, priv->mixer_stream);
+                break;
+        case PROP_DISPLAY_NAME:
+                g_value_set_string (value, priv->display_name);
+                break;
+        case PROP_ICON_NAMES:
+                g_value_set_boxed (value, priv->icon_names);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+on_bar_is_muted_notify (GObject             *object,
+                        GParamSpec          *pspec,
+                        GvcStreamStatusIcon *icon)
+{
+        gboolean is_muted;
+
+        is_muted = gvc_channel_bar_get_is_muted (GVC_CHANNEL_BAR (object));
+
+        if (gvc_mixer_stream_get_is_muted (icon->priv->mixer_stream) != is_muted) {
+                /* Update the stream before pushing the change */
+                gvc_mixer_stream_set_is_muted (icon->priv->mixer_stream, is_muted);
+                gvc_mixer_stream_change_is_muted (icon->priv->mixer_stream,
+                                                  is_muted);
+        }
+}
+
+static GObject *
+gvc_stream_status_icon_constructor (GType                  type,
+                                    guint                  n_construct_properties,
+                                    GObjectConstructParam *construct_params)
+{
+        GObject             *object;
+        GvcStreamStatusIcon *icon;
+        GtkWidget           *frame;
+        GtkWidget           *box;
+        GtkAdjustment       *adj;
+
+        object = G_OBJECT_CLASS (gvc_stream_status_icon_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        icon = GVC_STREAM_STATUS_ICON (object);
+
+        gtk_status_icon_set_from_icon_name (GTK_STATUS_ICON (icon),
+                                            icon->priv->icon_names[0]);
+
+        /* window */
+        icon->priv->dock = gtk_window_new (GTK_WINDOW_POPUP);
+        gtk_widget_set_name (icon->priv->dock, "gvc-stream-status-icon-popup-window");
+        g_signal_connect (icon->priv->dock,
+                          "button-press-event",
+                          G_CALLBACK (on_dock_button_press),
+                          icon);
+        g_signal_connect (icon->priv->dock,
+                          "key-release-event",
+                          G_CALLBACK (on_dock_key_release),
+                          icon);
+        g_signal_connect (icon->priv->dock,
+                          "scroll-event",
+                          G_CALLBACK (on_dock_scroll_event),
+                          icon);
+
+        gtk_window_set_decorated (GTK_WINDOW (icon->priv->dock), FALSE);
+
+        frame = gtk_frame_new (NULL);
+        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_OUT);
+        gtk_container_add (GTK_CONTAINER (icon->priv->dock), frame);
+
+        box = gtk_vbox_new (FALSE, 6);
+        gtk_container_set_border_width (GTK_CONTAINER (box), 2);
+        gtk_container_add (GTK_CONTAINER (frame), box);
+
+        icon->priv->bar = gvc_channel_bar_new ();
+        gvc_channel_bar_set_orientation (GVC_CHANNEL_BAR (icon->priv->bar),
+                                         GTK_ORIENTATION_VERTICAL);
+
+        gtk_box_pack_start (GTK_BOX (box), icon->priv->bar, TRUE, FALSE, 0);
+        g_signal_connect (icon->priv->bar,
+                          "notify::is-muted",
+                          G_CALLBACK (on_bar_is_muted_notify),
+                          icon);
+
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (icon->priv->bar)));
+        g_signal_connect (adj,
+                          "value-changed",
+                          G_CALLBACK (on_adjustment_value_changed),
+                          icon);
+
+        return object;
+}
+
+static void
+gvc_stream_status_icon_dispose (GObject *object)
+{
+        GvcStreamStatusIcon *icon = GVC_STREAM_STATUS_ICON (object);
+
+        if (icon->priv->dock != NULL) {
+                gtk_widget_destroy (icon->priv->dock);
+                icon->priv->dock = NULL;
+        }
+
+        if (icon->priv->mixer_stream != NULL) {
+                g_object_unref (icon->priv->mixer_stream);
+                icon->priv->mixer_stream = NULL;
+        }
+
+        G_OBJECT_CLASS (gvc_stream_status_icon_parent_class)->dispose (object);
+}
+
+static void
+gvc_stream_status_icon_class_init (GvcStreamStatusIconClass *klass)
+{
+        GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_stream_status_icon_constructor;
+        object_class->finalize = gvc_stream_status_icon_finalize;
+        object_class->dispose = gvc_stream_status_icon_dispose;
+        object_class->set_property = gvc_stream_status_icon_set_property;
+        object_class->get_property = gvc_stream_status_icon_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_MIXER_STREAM,
+                                         g_param_spec_object ("mixer-stream",
+                                                              "mixer stream",
+                                                              "mixer stream",
+                                                              GVC_TYPE_MIXER_STREAM,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_DISPLAY_NAME,
+                                         g_param_spec_string ("display-name",
+                                                              "Display Name",
+                                                              "Name to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_ICON_NAMES,
+                                         g_param_spec_boxed ("icon-names",
+                                                             "Icon Names",
+                                                             "Name of icon to display for this stream",
+                                                              G_TYPE_STRV,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_type_class_add_private (klass, sizeof (GvcStreamStatusIconPrivate));
+}
+
+static void
+on_status_icon_visible_notify (GvcStreamStatusIcon *icon)
+{
+        gboolean visible;
+
+        g_object_get (icon, "visible", &visible, NULL);
+        if (! visible) {
+                if (icon->priv->dock != NULL) {
+                        gtk_widget_hide (icon->priv->dock);
+                }
+        }
+}
+
+static void
+gvc_stream_status_icon_init (GvcStreamStatusIcon *icon)
+{
+        icon->priv = GVC_STREAM_STATUS_ICON_GET_PRIVATE (icon);
+
+        g_signal_connect (icon,
+                          "activate",
+                          G_CALLBACK (on_status_icon_activate),
+                          icon);
+        g_signal_connect (icon,
+                          "popup-menu",
+                          G_CALLBACK (on_status_icon_popup_menu),
+                          icon);
+        g_signal_connect (icon,
+                          "scroll-event",
+                          G_CALLBACK (on_status_icon_scroll_event),
+                          icon);
+        g_signal_connect (icon,
+                          "notify::visible",
+                          G_CALLBACK (on_status_icon_visible_notify),
+                          NULL);
+
+        icon->priv->thaw = FALSE;
+}
+
+static void
+gvc_stream_status_icon_finalize (GObject *object)
+{
+        GvcStreamStatusIcon *stream_status_icon;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_STREAM_STATUS_ICON (object));
+
+        stream_status_icon = GVC_STREAM_STATUS_ICON (object);
+
+        g_return_if_fail (stream_status_icon->priv != NULL);
+
+        g_strfreev (stream_status_icon->priv->icon_names);
+
+        G_OBJECT_CLASS (gvc_stream_status_icon_parent_class)->finalize (object);
+}
+
+GvcStreamStatusIcon *
+gvc_stream_status_icon_new (GvcMixerStream *stream,
+                            const char    **icon_names)
+{
+        GObject *icon;
+        icon = g_object_new (GVC_TYPE_STREAM_STATUS_ICON,
+                             "mixer-stream", stream,
+                             "icon-names", icon_names,
+                             NULL);
+        return GVC_STREAM_STATUS_ICON (icon);
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-stream-status-icon.h gnome-control-center-3.6.0/panels/sound-nua/gvc-stream-status-icon.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/gvc-stream-status-icon.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/gvc-stream-status-icon.h	2012-09-28 19:08:52.504641692 -0400
@@ -0,0 +1,63 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_STREAM_STATUS_ICON_H
+#define __GVC_STREAM_STATUS_ICON_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_STREAM_STATUS_ICON         (gvc_stream_status_icon_get_type ())
+#define GVC_STREAM_STATUS_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_STREAM_STATUS_ICON, GvcStreamStatusIcon))
+#define GVC_STREAM_STATUS_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_STREAM_STATUS_ICON, GvcStreamStatusIconClass))
+#define GVC_IS_STREAM_STATUS_ICON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_STREAM_STATUS_ICON))
+#define GVC_IS_STREAM_STATUS_ICON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_STREAM_STATUS_ICON))
+#define GVC_STREAM_STATUS_ICON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_STREAM_STATUS_ICON, GvcStreamStatusIconClass))
+
+typedef struct GvcStreamStatusIconPrivate GvcStreamStatusIconPrivate;
+
+typedef struct
+{
+        GtkStatusIcon               parent;
+        GvcStreamStatusIconPrivate *priv;
+} GvcStreamStatusIcon;
+
+typedef struct
+{
+        GtkStatusIconClass          parent_class;
+} GvcStreamStatusIconClass;
+
+GType                 gvc_stream_status_icon_get_type            (void);
+
+GvcStreamStatusIcon * gvc_stream_status_icon_new                 (GvcMixerStream      *stream,
+                                                                  const char         **icon_names);
+
+void                  gvc_stream_status_icon_set_icon_names      (GvcStreamStatusIcon *icon,
+                                                                  const char         **icon_names);
+void                  gvc_stream_status_icon_set_display_name    (GvcStreamStatusIcon *icon,
+                                                                  const char          *display_name);
+void                  gvc_stream_status_icon_set_mixer_stream    (GvcStreamStatusIcon *icon,
+                                                                  GvcMixerStream      *stream);
+
+G_END_DECLS
+
+#endif /* __GVC_STREAM_STATUS_ICON_H */
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/Makefile.am gnome-control-center-3.6.0/panels/sound-nua/Makefile.am
--- gnome-control-center-3.6.0.orig/panels/sound-nua/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/Makefile.am	2012-09-28 19:08:52.505641691 -0400
@@ -0,0 +1,93 @@
+SUBDIRS = data
+
+# This is used in PANEL_CFLAGS
+cappletname = sound
+NULL =
+
+ccpanelsdir = $(PANELS_DIR)
+ccpanels_LTLIBRARIES = libsoundnua.la
+
+AM_CPPFLAGS =					\
+	$(PANEL_CFLAGS) 			\
+	$(SOUND_PANEL_CFLAGS)			\
+	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
+	-DLIBEXECDIR=\"$(libexecdir)\"		\
+	-DGLADEDIR=\""$(pkgdatadir)"\"		\
+        -DSOUND_DATA_DIR="\"$(datadir)/sounds\""	\
+        -DSOUND_SET_DIR="\"$(pkgdatadir)/sounds\""	\
+	-DICON_DATA_DIR="\"$(pkgdatadir)/icons\"" \
+	$(NULL)
+
+noinst_LTLIBRARIES = libgnomevolumecontrol.la
+libgnomevolumecontrol_la_SOURCES =		\
+	gvc-mixer-card.h			\
+	gvc-mixer-card.c			\
+	gvc-mixer-card-private.h		\
+	gvc-mixer-stream.h			\
+	gvc-mixer-stream.c			\
+	gvc-mixer-stream-private.h		\
+	gvc-mixer-ui-device.h			\
+	gvc-mixer-ui-device.c			\
+	gvc-channel-map.h			\
+	gvc-channel-map.c			\
+	gvc-channel-map-private.h		\
+	gvc-mixer-sink.h			\
+	gvc-mixer-sink.c			\
+	gvc-mixer-source.h			\
+	gvc-mixer-source.c			\
+	gvc-mixer-sink-input.h			\
+	gvc-mixer-sink-input.c			\
+	gvc-mixer-source-output.h		\
+	gvc-mixer-source-output.c		\
+	gvc-mixer-event-role.h			\
+	gvc-mixer-event-role.c			\
+	gvc-mixer-control.h			\
+	gvc-mixer-control.c			\
+	gvc-mixer-control-private.h		\
+	gvc-channel-bar.h			\
+	gvc-channel-bar.c			\
+	gvc-pulseaudio-fake.h			\
+	$(NULL)
+
+libsoundnua_la_LIBADD =				\
+	-lm					\
+	libgnomevolumecontrol.la		\
+	$(PANEL_LIBS)				\
+	$(SOUND_PANEL_LIBS)			\
+	$(NULL)
+
+libsoundnua_la_LDFLAGS =				\
+	$(PANEL_LDFLAGS)			\
+	$(NULL)
+
+libsoundnua_la_SOURCES =				\
+	gvc-balance-bar.h			\
+	gvc-balance-bar.c			\
+	gvc-mixer-dialog.h			\
+	gvc-mixer-dialog.c			\
+	gvc-level-bar.h				\
+	gvc-level-bar.c				\
+	gvc-combo-box.h				\
+	gvc-combo-box.c				\
+	gvc-speaker-test.h			\
+	gvc-speaker-test.c			\
+	gvc-sound-theme-chooser.c		\
+	gvc-sound-theme-chooser.h		\
+	sound-theme-file-utils.c		\
+	sound-theme-file-utils.h		\
+	cc-sound-panel.c			\
+	cc-sound-panel.h			\
+	$(NULL)
+
+BUILT_SOURCES =				\
+	$(NULL)
+
+CLEANFILES =				\
+	$(BUILT_SOURCES)		\
+	$(NULL)
+
+MAINTAINERCLEANFILES =                  \
+        *~                              \
+        Makefile.in
+
+-include $(top_srcdir)/git.mk
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/sound-theme-file-utils.c gnome-control-center-3.6.0/panels/sound-nua/sound-theme-file-utils.c
--- gnome-control-center-3.6.0.orig/panels/sound-nua/sound-theme-file-utils.c	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/sound-theme-file-utils.c	2012-09-28 19:08:52.505641691 -0400
@@ -0,0 +1,305 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ * Copyright (C) 2008 Bastien Nocera <hadess@hadess.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <config.h>
+#include <glib/gstdio.h>
+#include <glib/gi18n-lib.h>
+#include <gio/gio.h>
+#include <utime.h>
+#include <strings.h>
+
+#include "sound-theme-file-utils.h"
+
+#define CUSTOM_THEME_NAME       "__custom"
+
+/* This function needs to be called after each individual
+ * changeset to the theme */
+void
+custom_theme_update_time (void)
+{
+        char *path;
+
+        path = custom_theme_dir_path (NULL);
+        utime (path, NULL);
+        g_free (path);
+}
+
+char *
+custom_theme_dir_path (const char *child)
+{
+        static char *dir = NULL;
+        const char *data_dir;
+
+        if (dir == NULL) {
+                data_dir = g_get_user_data_dir ();
+                dir = g_build_filename (data_dir, "sounds", CUSTOM_THEME_NAME, NULL);
+        }
+        if (child == NULL)
+                return g_strdup (dir);
+
+        return g_build_filename (dir, child, NULL);
+}
+
+static gboolean
+directory_delete_recursive (GFile *directory, GError **error)
+{
+        GFileEnumerator *enumerator;
+        GFileInfo *info;
+        gboolean success = TRUE;
+
+        enumerator = g_file_enumerate_children (directory,
+                                                G_FILE_ATTRIBUTE_STANDARD_NAME ","
+                                                G_FILE_ATTRIBUTE_STANDARD_TYPE,
+                                                G_FILE_QUERY_INFO_NONE,
+                                                NULL, error);
+        if (enumerator == NULL)
+                return FALSE;
+
+        while (success &&
+               (info = g_file_enumerator_next_file (enumerator, NULL, NULL))) {
+                GFile *child;
+
+                child = g_file_get_child (directory, g_file_info_get_name (info));
+
+                if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY) {
+                        success = directory_delete_recursive (child, error);
+                }
+                g_object_unref (info);
+
+                if (success)
+                        success = g_file_delete (child, NULL, error);
+        }
+        g_file_enumerator_close (enumerator, NULL, NULL);
+
+        if (success)
+                success = g_file_delete (directory, NULL, error);
+
+        return success;
+}
+
+/**
+ * capplet_file_delete_recursive :
+ * @file :
+ * @error  :
+ *
+ * A utility routine to delete files and/or directories,
+ * including non-empty directories.
+ **/
+static gboolean
+capplet_file_delete_recursive (GFile *file, GError **error)
+{
+        GFileInfo *info;
+        GFileType type;
+
+        g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+        info = g_file_query_info (file,
+                                  G_FILE_ATTRIBUTE_STANDARD_TYPE,
+                                  G_FILE_QUERY_INFO_NONE,
+                                  NULL, error);
+        if (info == NULL)
+                return FALSE;
+
+        type = g_file_info_get_file_type (info);
+        g_object_unref (info);
+
+        if (type == G_FILE_TYPE_DIRECTORY)
+                return directory_delete_recursive (file, error);
+        else
+                return g_file_delete (file, NULL, error);
+}
+
+void
+delete_custom_theme_dir (void)
+{
+        char *dir;
+        GFile *file;
+
+        dir = custom_theme_dir_path (NULL);
+        file = g_file_new_for_path (dir);
+        g_free (dir);
+        capplet_file_delete_recursive (file, NULL);
+        g_object_unref (file);
+
+        g_debug ("deleted the custom theme dir");
+}
+
+gboolean
+custom_theme_dir_is_empty (void)
+{
+        char            *dir;
+        GFile           *file;
+        gboolean         is_empty;
+        GFileEnumerator *enumerator;
+        GFileInfo       *info;
+        GError          *error = NULL;
+
+        dir = custom_theme_dir_path (NULL);
+        file = g_file_new_for_path (dir);
+        g_free (dir);
+
+        is_empty = TRUE;
+
+        enumerator = g_file_enumerate_children (file,
+                                                G_FILE_ATTRIBUTE_STANDARD_NAME ","
+                                                G_FILE_ATTRIBUTE_STANDARD_TYPE,
+                                                G_FILE_QUERY_INFO_NONE,
+                                                NULL, &error);
+        if (enumerator == NULL) {
+                g_warning ("Unable to enumerate files: %s", error->message);
+                g_error_free (error);
+                goto out;
+        }
+
+        while (is_empty &&
+               (info = g_file_enumerator_next_file (enumerator, NULL, NULL))) {
+
+                if (strcmp ("index.theme", g_file_info_get_name (info)) != 0) {
+                        is_empty = FALSE;
+                }
+
+                g_object_unref (info);
+        }
+        g_file_enumerator_close (enumerator, NULL, NULL);
+
+ out:
+        g_object_unref (file);
+
+        return is_empty;
+}
+
+static void
+delete_one_file (const char *sound_name, const char *pattern)
+{
+        GFile *file;
+        char *name, *filename;
+
+        name = g_strdup_printf (pattern, sound_name);
+        filename = custom_theme_dir_path (name);
+        g_free (name);
+        file = g_file_new_for_path (filename);
+        g_free (filename);
+        capplet_file_delete_recursive (file, NULL);
+        g_object_unref (file);
+}
+
+void
+delete_old_files (const char **sounds)
+{
+        guint i;
+
+        for (i = 0; sounds[i] != NULL; i++) {
+                delete_one_file (sounds[i], "%s.ogg");
+        }
+}
+
+void
+delete_disabled_files (const char **sounds)
+{
+        guint i;
+
+        for (i = 0; sounds[i] != NULL; i++)
+                delete_one_file (sounds[i], "%s.disabled");
+}
+
+static void
+create_one_file (GFile *file)
+{
+        GFileOutputStream* stream;
+
+        stream = g_file_create (file, G_FILE_CREATE_NONE, NULL, NULL);
+        if (stream != NULL) {
+                g_output_stream_close (G_OUTPUT_STREAM (stream), NULL, NULL);
+                g_object_unref (stream);
+        }
+}
+
+void
+add_disabled_file (const char **sounds)
+{
+        guint i;
+
+        for (i = 0; sounds[i] != NULL; i++) {
+                GFile *file;
+                char *name, *filename;
+
+                name = g_strdup_printf ("%s.disabled", sounds[i]);
+                filename = custom_theme_dir_path (name);
+                g_free (name);
+                file = g_file_new_for_path (filename);
+                g_free (filename);
+
+                create_one_file (file);
+                g_object_unref (file);
+        }
+}
+
+void
+add_custom_file (const char **sounds, const char *filename)
+{
+        guint i;
+
+        for (i = 0; sounds[i] != NULL; i++) {
+                GFile *file;
+                char *name, *path;
+
+                /* We use *.ogg because it's the first type of file that
+                 * libcanberra looks at */
+                name = g_strdup_printf ("%s.ogg", sounds[i]);
+                path = custom_theme_dir_path (name);
+                g_free (name);
+                /* In case there's already a link there, delete it */
+                g_unlink (path);
+                file = g_file_new_for_path (path);
+                g_free (path);
+
+                /* Create the link */
+                g_file_make_symbolic_link (file, filename, NULL, NULL);
+                g_object_unref (file);
+        }
+}
+
+void
+create_custom_theme (const char *parent)
+{
+        GKeyFile *keyfile;
+        char     *data;
+        char     *path;
+
+        /* Create the custom directory */
+        path = custom_theme_dir_path (NULL);
+        g_mkdir_with_parents (path, 0755);
+        g_free (path);
+
+        /* Set the data for index.theme */
+        keyfile = g_key_file_new ();
+        g_key_file_set_string (keyfile, "Sound Theme", "Name", _("Custom"));
+        g_key_file_set_string (keyfile, "Sound Theme", "Inherits", parent);
+        g_key_file_set_string (keyfile, "Sound Theme", "Directories", ".");
+        data = g_key_file_to_data (keyfile, NULL, NULL);
+        g_key_file_free (keyfile);
+
+        /* Save the index.theme */
+        path = custom_theme_dir_path ("index.theme");
+        g_file_set_contents (path, data, -1, NULL);
+        g_free (path);
+        g_free (data);
+
+        custom_theme_update_time ();
+}
diff -Nru gnome-control-center-3.6.0.orig/panels/sound-nua/sound-theme-file-utils.h gnome-control-center-3.6.0/panels/sound-nua/sound-theme-file-utils.h
--- gnome-control-center-3.6.0.orig/panels/sound-nua/sound-theme-file-utils.h	1969-12-31 19:00:00.000000000 -0500
+++ gnome-control-center-3.6.0/panels/sound-nua/sound-theme-file-utils.h	2012-09-28 19:08:52.506641689 -0400
@@ -0,0 +1,37 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ * Copyright (C) 2008 Bastien Nocera <hadess@hadess.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+#ifndef __SOUND_THEME_FILE_UTILS_HH__
+#define __SOUND_THEME_FILE_UTILS_HH__
+
+#include <gio/gio.h>
+
+char *custom_theme_dir_path (const char *child);
+gboolean custom_theme_dir_is_empty (void);
+void create_custom_theme (const char *parent);
+
+void delete_custom_theme_dir (void);
+void delete_old_files (const char **sounds);
+void delete_disabled_files (const char **sounds);
+
+void add_disabled_file (const char **sounds);
+void add_custom_file (const char **sounds, const char *filename);
+
+void custom_theme_update_time (void);
+
+#endif /* __SOUND_THEME_FILE_UTILS_HH__ */
diff -Nru gnome-control-center-3.6.0.orig/panels/universal-access/cc-ua-panel.c gnome-control-center-3.6.0/panels/universal-access/cc-ua-panel.c
--- gnome-control-center-3.6.0.orig/panels/universal-access/cc-ua-panel.c	2012-09-28 19:07:33.382746177 -0400
+++ gnome-control-center-3.6.0/panels/universal-access/cc-ua-panel.c	2012-09-28 19:08:52.507641687 -0400
@@ -489,7 +489,10 @@
   CcShell *shell;
 
   shell = cc_panel_get_shell (CC_PANEL (panel));
-  cc_shell_set_active_panel_from_id (shell, "sound", NULL, NULL);
+  if (g_strcmp0 (g_getenv ("XDG_CURRENT_DESKTOP"), "Unity") == 0)
+    cc_shell_set_active_panel_from_id (shell, "sound-nua", NULL, NULL);
+  else
+    cc_shell_set_active_panel_from_id (shell, "sound", NULL, NULL);
 
   return TRUE;
 }
diff -Nru gnome-control-center-3.6.0.orig/shell/gnome-control-center.c gnome-control-center-3.6.0/shell/gnome-control-center.c
--- gnome-control-center-3.6.0.orig/shell/gnome-control-center.c	2012-09-28 19:07:33.558745974 -0400
+++ gnome-control-center-3.6.0/shell/gnome-control-center.c	2012-09-28 19:09:58.895541208 -0400
@@ -958,6 +958,10 @@
   GnomeControlCenterPrivate *priv = GNOME_CONTROL_CENTER (shell)->priv;
   GtkWidget *old_panel;
 
+  if (!g_strcmp0 (g_getenv ("XDG_CURRENT_DESKTOP"), "Unity") && 
+      !g_strcmp0(start_id, "sound"))
+      start_id = "sound-nua";
+
   /* When loading the same panel again, just set the argv */
   if (g_strcmp0 (priv->current_panel_id, start_id) == 0)
     {
