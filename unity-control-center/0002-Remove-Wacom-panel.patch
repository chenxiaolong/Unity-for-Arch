From 34e0e1d48f3c56d4fee5095a38d0915f10cf8b3f Mon Sep 17 00:00:00 2001
From: Xiao-Long Chen <chenxiaolong@cxl.epac.to>
Date: Sat, 5 Apr 2014 19:06:05 -0400
Subject: [PATCH 02/19] Remove Wacom panel

---
 configure.ac                                 |   29 -
 man/unity-control-center.xml                 |    8 -
 panels/Makefile.am                           |    4 -
 panels/wacom/Makefile.am                     |   89 --
 panels/wacom/button-mapping.ui               |  155 --
 panels/wacom/calibrator/COPYING              |   27 -
 panels/wacom/calibrator/Makefile.am          |   34 -
 panels/wacom/calibrator/calibrator.c         |  175 ---
 panels/wacom/calibrator/calibrator.h         |  101 --
 panels/wacom/calibrator/gui_gtk.c            |  579 -------
 panels/wacom/calibrator/gui_gtk.h            |   56 -
 panels/wacom/calibrator/main.c               |  418 -----
 panels/wacom/cc-wacom-mapping-panel.c        |  366 -----
 panels/wacom/cc-wacom-mapping-panel.h        |   77 -
 panels/wacom/cc-wacom-nav-button.c           |  263 ----
 panels/wacom/cc-wacom-nav-button.h           |   73 -
 panels/wacom/cc-wacom-page.c                 | 1411 -----------------
 panels/wacom/cc-wacom-page.h                 |   88 --
 panels/wacom/cc-wacom-panel.c                |  406 -----
 panels/wacom/cc-wacom-panel.h                |   77 -
 panels/wacom/cc-wacom-stylus-page.c          |  507 ------
 panels/wacom/cc-wacom-stylus-page.h          |   81 -
 panels/wacom/gnome-wacom-properties.ui       |  407 -----
 panels/wacom/gsd-enums.h                     |    7 -
 panels/wacom/gsd-input-helper.c              |  565 -------
 panels/wacom/gsd-input-helper.h              |   86 -
 panels/wacom/gsd-wacom-device.c              | 2185 --------------------------
 panels/wacom/gsd-wacom-device.h              |  202 ---
 panels/wacom/test-wacom.c                    |  103 --
 panels/wacom/unity-wacom-panel.desktop.in.in |   13 -
 panels/wacom/wacom-module.c                  |   41 -
 panels/wacom/wacom-stylus-airbrush.svg       |   94 --
 panels/wacom/wacom-stylus-art-pen.svg        |  127 --
 panels/wacom/wacom-stylus-classic.svg        |  103 --
 panels/wacom/wacom-stylus-inking.svg         |   87 -
 panels/wacom/wacom-stylus-page.ui            |  351 -----
 panels/wacom/wacom-stylus.svg                |  124 --
 panels/wacom/wacom-tablet-cintiq.svg         |   83 -
 panels/wacom/wacom-tablet-pc.svg             |   77 -
 panels/wacom/wacom-tablet.svg                |   81 -
 panels/wacom/wacom.gresource.xml             |   16 -
 po/POTFILES.in                               |   10 -
 po/POTFILES.skip                             |    1 -
 43 files changed, 9787 deletions(-)
 delete mode 100644 panels/wacom/Makefile.am
 delete mode 100644 panels/wacom/button-mapping.ui
 delete mode 100644 panels/wacom/calibrator/COPYING
 delete mode 100644 panels/wacom/calibrator/Makefile.am
 delete mode 100644 panels/wacom/calibrator/calibrator.c
 delete mode 100644 panels/wacom/calibrator/calibrator.h
 delete mode 100644 panels/wacom/calibrator/gui_gtk.c
 delete mode 100644 panels/wacom/calibrator/gui_gtk.h
 delete mode 100644 panels/wacom/calibrator/main.c
 delete mode 100644 panels/wacom/cc-wacom-mapping-panel.c
 delete mode 100644 panels/wacom/cc-wacom-mapping-panel.h
 delete mode 100644 panels/wacom/cc-wacom-nav-button.c
 delete mode 100644 panels/wacom/cc-wacom-nav-button.h
 delete mode 100644 panels/wacom/cc-wacom-page.c
 delete mode 100644 panels/wacom/cc-wacom-page.h
 delete mode 100644 panels/wacom/cc-wacom-panel.c
 delete mode 100644 panels/wacom/cc-wacom-panel.h
 delete mode 100644 panels/wacom/cc-wacom-stylus-page.c
 delete mode 100644 panels/wacom/cc-wacom-stylus-page.h
 delete mode 100644 panels/wacom/gnome-wacom-properties.ui
 delete mode 100644 panels/wacom/gsd-enums.h
 delete mode 100644 panels/wacom/gsd-input-helper.c
 delete mode 100644 panels/wacom/gsd-input-helper.h
 delete mode 100644 panels/wacom/gsd-wacom-device.c
 delete mode 100644 panels/wacom/gsd-wacom-device.h
 delete mode 100644 panels/wacom/test-wacom.c
 delete mode 100644 panels/wacom/unity-wacom-panel.desktop.in.in
 delete mode 100644 panels/wacom/wacom-module.c
 delete mode 100644 panels/wacom/wacom-stylus-airbrush.svg
 delete mode 100644 panels/wacom/wacom-stylus-art-pen.svg
 delete mode 100644 panels/wacom/wacom-stylus-classic.svg
 delete mode 100644 panels/wacom/wacom-stylus-inking.svg
 delete mode 100644 panels/wacom/wacom-stylus-page.ui
 delete mode 100644 panels/wacom/wacom-stylus.svg
 delete mode 100644 panels/wacom/wacom-tablet-cintiq.svg
 delete mode 100644 panels/wacom/wacom-tablet-pc.svg
 delete mode 100644 panels/wacom/wacom-tablet.svg
 delete mode 100644 panels/wacom/wacom.gresource.xml

diff --git a/configure.ac b/configure.ac
index 7265f3d..e74aede 100644
--- a/configure.ac
+++ b/configure.ac
@@ -100,7 +100,6 @@ NETWORK_MANAGER_REQUIRED_VERSION=0.8.992
 LIBNOTIFY_REQUIRED_VERSION=0.7.3
 GNOME_DESKTOP_REQUIRED_VERSION=3.5.91
 SCHEMAS_REQUIRED_VERSION=3.7.2.2
-LIBWACOM_REQUIRED_VERSION=0.7
 CLUTTER_REQUIRED_VERSION=1.11.3
 GOA_REQUIRED_VERSION=3.5.90
 ACCOUNTSSERVICE_REQUIRED_VERSION=0.6.30
@@ -222,26 +221,6 @@ else
 fi
 AM_CONDITIONAL(BUILD_CHEESE, test x${have_cheese} = xyes)
 
-# wacom is disabled for s390/s390x and non Linux platforms (needs udev)
-case $host_os in
-  linux*)
-    if test "$host_cpu" = s390 -o "$host_cpu" = s390x; then
-      have_wacom=no
-    else
-      PKG_CHECK_MODULES(WACOM_PANEL, $COMMON_MODULES
-                        unity-settings-daemon
-                        xi >= 1.2 x11 libwacom >= $LIBWACOM_REQUIRED_VERSION
-                        gnome-desktop-3.0 >= $GNOME_DESKTOP_REQUIRED_VERSION)
-      AC_DEFINE(BUILD_WACOM, 1, [Define to 1 to build the Wacom panel])
-      have_wacom=yes
-    fi
-    ;;
-  *)
-    have_wacom=no
-    ;;
-esac
-AM_CONDITIONAL(BUILD_WACOM, [test x"$have_wacom" = x"yes"])
-
 # This is a hard-dependency for the region and user-accounts panels
 PKG_CHECK_MODULES(ISOCODES, iso-codes)
 
@@ -462,9 +441,6 @@ panels/universal-access/unity-universal-access-panel.desktop.in
 panels/user-accounts/Makefile
 panels/user-accounts/data/Makefile
 panels/user-accounts/data/unity-user-accounts-panel.desktop.in
-panels/wacom/Makefile
-panels/wacom/calibrator/Makefile
-panels/wacom/unity-wacom-panel.desktop.in
 po/Makefile.in
 shell/Makefile
 shell/unity-control-center.desktop.in
@@ -492,11 +468,6 @@ if test "x$with_libsocialweb" = "xyes"; then
 else
 	AC_MSG_NOTICE([   Appearance panel Flickr support disabled])
 fi
-if test "x$have_wacom" = "xyes"; then
-	AC_MSG_NOTICE([** wacom (Wacom tablet panel)])
-else
-	AC_MSG_NOTICE([   Wacom panel disabled])
-fi
 if test "x$enable_ibus" == "xyes"; then
 	AC_MSG_NOTICE([** IBus (Region panel IBus support)])
 else
diff --git a/man/unity-control-center.xml b/man/unity-control-center.xml
index 7e0806e..331a869 100644
--- a/man/unity-control-center.xml
+++ b/man/unity-control-center.xml
@@ -237,14 +237,6 @@
                                 privileges.</para></listitem>
                         </varlistentry>
 
-                        <varlistentry>
-                                <term><option>wacom</option></term>
-
-                                <listitem><para>the wacom panel shows
-                                connected Wacom graphics tablets and lets
-                                you calibrate and configure such devices.</para></listitem>
-                        </varlistentry>
-
                 </variablelist>
 
         </refsect1>
diff --git a/panels/Makefile.am b/panels/Makefile.am
index 6ac50dc..7a0af01 100644
--- a/panels/Makefile.am
+++ b/panels/Makefile.am
@@ -14,10 +14,6 @@ SUBDIRS= \
 	universal-access \
 	user-accounts
 
-if BUILD_WACOM
-SUBDIRS += wacom
-endif
-
 if BUILD_PRINTERS
 SUBDIRS += printers
 endif
diff --git a/panels/wacom/Makefile.am b/panels/wacom/Makefile.am
deleted file mode 100644
index ebb7023..0000000
--- a/panels/wacom/Makefile.am
+++ /dev/null
@@ -1,89 +0,0 @@
-# This is used in PANEL_CFLAGS
-cappletname = wacom
-
-SUBDIRS = calibrator
-
-INCLUDES = 						\
-	$(PANEL_CFLAGS)					\
-	$(WACOM_PANEL_CFLAGS)				\
-	-I$(srcdir)/calibrator				\
-	-DGNOMELOCALEDIR="\"$(datadir)/locale\""	\
-	$(NULL)
-
-ccpanelsdir = $(PANELS_DIR)
-ccpanels_LTLIBRARIES = libwacom-properties.la
-
-
-BUILT_SOURCES =			\
-	cc-wacom-resources.c	\
-	cc-wacom-resources.h
-
-libwacom_properties_la_SOURCES =	\
-	$(BUILT_SOURCES)		\
-	wacom-module.c			\
-	cc-wacom-panel.c		\
-	cc-wacom-panel.h		\
-	cc-wacom-page.c			\
-	cc-wacom-page.h			\
-	cc-wacom-stylus-page.c		\
-	cc-wacom-stylus-page.h		\
-	gsd-wacom-device.c		\
-	gsd-wacom-device.h		\
-	gsd-input-helper.c		\
-	gsd-input-helper.h		\
-	cc-wacom-nav-button.c		\
-	cc-wacom-nav-button.h		\
-	cc-wacom-mapping-panel.c	\
-	cc-wacom-mapping-panel.h	\
-	gsd-enums.h
-
-libwacom_properties_la_LIBADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS) $(builddir)/calibrator/libwacom-calibrator.la
-libwacom_properties_la_LDFLAGS = $(PANEL_LDFLAGS)
-
-noinst_PROGRAMS = test-wacom
-
-test_wacom_SOURCES =			\
-	$(BUILT_SOURCES)		\
-	test-wacom.c			\
-	cc-wacom-page.c			\
-	cc-wacom-page.h			\
-	cc-wacom-stylus-page.c		\
-	cc-wacom-stylus-page.h		\
-	cc-wacom-nav-button.c		\
-	cc-wacom-nav-button.h		\
-	cc-wacom-mapping-panel.c	\
-	cc-wacom-mapping-panel.h	\
-	gsd-wacom-device.c		\
-	gsd-wacom-device.h		\
-	gsd-input-helper.c		\
-	gsd-input-helper.h		\
-	gsd-enums.h
-
-test_wacom_CPPFLAGS = $(INCLUDES)
-test_wacom_LDADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS) $(builddir)/calibrator/libwacom-calibrator.la
-
-resource_files = $(shell glib-compile-resources --sourcedir=$(srcdir) --generate-dependencies $(srcdir)/wacom.gresource.xml)
-cc-wacom-resources.c: wacom.gresource.xml $(resource_files)
-	$(AM_V_GEN) glib-compile-resources --target=$@ --sourcedir=$(srcdir) --generate-source --c-name cc_wacom $<
-cc-wacom-resources.h: wacom.gresource.xml $(resource_files)
-	$(AM_V_GEN) glib-compile-resources --target=$@ --sourcedir=$(srcdir) --generate-header --c-name cc_wacom $<
-
-@INTLTOOL_DESKTOP_RULE@
-
-desktopdir = $(datadir)/applications
-desktop_in_files = unity-wacom-panel.desktop.in
-desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)
-
-WACOMDIR=$(top_srcdir)/../gnome-settings-daemon/plugins/wacom/
-WACOMFILES=gsd-wacom-device.c gsd-wacom-device.h
-COMMONDIR=$(top_srcdir)/../gnome-settings-daemon/plugins/common/
-COMMONFILES=gsd-input-helper.c gsd-input-helper.h
-update-from-gsd:
-	FILES="$(WACOMFILES)" DIR="$(WACOMDIR)" $(top_srcdir)/update-from-gsd.sh && changed=true ; \
-	FILES="$(COMMONFILES)" DIR="$(COMMONDIR)" $(top_srcdir)/update-from-gsd.sh && changed=true ; \
-	git commit -m "wacom: Update from gnome-settings-daemon" $(WACOMFILES) $(COMMONFILES)
-
-CLEANFILES = $(Desktop_in_files) $(desktop_DATA) $(BUILT_SOURCES)
-EXTRA_DIST = $(resource_files) wacom.gresource.xml
-
--include $(top_srcdir)/git.mk
diff --git a/panels/wacom/button-mapping.ui b/panels/wacom/button-mapping.ui
deleted file mode 100644
index 5408443..0000000
--- a/panels/wacom/button-mapping.ui
+++ /dev/null
@@ -1,155 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <!-- interface-requires gtk+ 3.0 -->
-  <object class="GtkDialog" id="button-mapping-dialog">
-    <property name="width_request">600</property>
-    <property name="height_request">450</property>
-    <property name="can_focus">False</property>
-    <property name="border_width">5</property>
-    <property name="title" translatable="yes">Map Buttons</property>
-    <property name="resizable">False</property>
-    <property name="modal">True</property>
-    <property name="default_width">600</property>
-    <property name="default_height">450</property>
-    <property name="type_hint">dialog</property>
-    <property name="has_resize_grip">False</property>
-    <child internal-child="vbox">
-      <object class="GtkBox" id="top_vbox">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="orientation">vertical</property>
-        <property name="spacing">2</property>
-        <child internal-child="action_area">
-          <object class="GtkButtonBox" id="dialog-action_area1">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="layout_style">end</property>
-            <child>
-              <placeholder/>
-            </child>
-            <child>
-              <placeholder/>
-            </child>
-            <child>
-              <placeholder/>
-            </child>
-            <child>
-              <object class="GtkButton" id="close_button">
-                <property name="label">gtk-close</property>
-                <property name="use_action_appearance">False</property>
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="can_default">True</property>
-                <property name="receives_default">False</property>
-                <property name="use_action_appearance">False</property>
-                <property name="use_stock">True</property>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">False</property>
-                <property name="position">3</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">False</property>
-            <property name="fill">True</property>
-            <property name="pack_type">end</property>
-            <property name="position">0</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkVBox" id="shortcuts_vbox">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="spacing">6</property>
-            <child>
-              <object class="GtkLabel" id="label1">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="xalign">0</property>
-                <property name="ypad">12</property>
-                <property name="label" translatable="yes">Map buttons to functions</property>
-                <attributes>
-                  <attribute name="weight" value="bold"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkTable" id="table11">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="column_spacing">5</property>
-                <child>
-                  <object class="GtkScrolledWindow" id="actions_swindow">
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="hscrollbar_policy">never</property>
-                    <property name="shadow_type">in</property>
-                    <child>
-                      <object class="GtkTreeView" id="shortcut_treeview">
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="headers_visible">False</property>
-                        <property name="rules_hint">True</property>
-                        <child internal-child="selection">
-                          <object class="GtkTreeSelection" id="treeview-selection"/>
-                        </child>
-                      </object>
-                    </child>
-                  </object>
-                </child>
-              </object>
-              <packing>
-                <property name="expand">True</property>
-                <property name="fill">True</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkHBox" id="hbox1">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="border_width">5</property>
-                <property name="spacing">12</property>
-                <child>
-                  <object class="GtkLabel" id="label12">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="xalign">0</property>
-                    <property name="label" translatable="yes">To edit a shortcut, click the row and hold down the new keys or press Backspace to clear.</property>
-                    <property name="justify">fill</property>
-                    <property name="wrap">True</property>
-                  </object>
-                  <packing>
-                    <property name="expand">True</property>
-                    <property name="fill">True</property>
-                    <property name="position">0</property>
-                  </packing>
-                </child>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">2</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">True</property>
-            <property name="fill">True</property>
-            <property name="position">1</property>
-          </packing>
-        </child>
-      </object>
-    </child>
-    <action-widgets>
-      <action-widget response="0">close_button</action-widget>
-    </action-widgets>
-  </object>
-</interface>
diff --git a/panels/wacom/calibrator/COPYING b/panels/wacom/calibrator/COPYING
deleted file mode 100644
index e0a1dc9..0000000
--- a/panels/wacom/calibrator/COPYING
+++ /dev/null
@@ -1,27 +0,0 @@
-Copyright (c) 2010 Tias Guns <tias@ulyssis.org> and others
-See the respective files for detailed copyright information.
-
-
-Source code: MIT/X11 License
-------------
-Permission is hereby granted, free of charge, to any person
-obtaining a copy of this software and associated documentation
-files (the "Software"), to deal in the Software without
-restriction, including without limitation the rights to use,
-copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the
-Software is furnished to do so, subject to the following
-conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-OTHER DEALINGS IN THE SOFTWARE.
-
diff --git a/panels/wacom/calibrator/Makefile.am b/panels/wacom/calibrator/Makefile.am
deleted file mode 100644
index 372084f..0000000
--- a/panels/wacom/calibrator/Makefile.am
+++ /dev/null
@@ -1,34 +0,0 @@
-# This is used in PANEL_CFLAGS
-cappletname = wacom
-
-INCLUDES = 						\
-	$(PANEL_CFLAGS)					\
-	$(WACOM_PANEL_CFLAGS)				\
-	-DGNOMELOCALEDIR="\"$(datadir)/locale\""	\
-	$(NULL)
-
-
-noinst_LTLIBRARIES = libwacom-calibrator.la
-
-libwacom_calibrator_la_SOURCES =	\
-	calibrator.c			\
-	calibrator.h			\
-	gui_gtk.c			\
-	gui_gtk.h
-
-libwacom_calibrator_la_LIBADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS)
-libwacom_calibrator_la_LDFLAGS = $(PANEL_LDFLAGS)
-
-noinst_PROGRAMS = test-calibrator
-
-test_calibrator_SOURCES =		\
-	main.c				\
-	calibrator.c			\
-	calibrator.h			\
-	gui_gtk.c			\
-	gui_gtk.h
-
-test_calibrator_CPPFLAGS = $(INCLUDES)
-test_calibrator_LDADD = $(PANEL_LIBS) $(WACOM_PANEL_LIBS)
-
--include $(top_srcdir)/git.mk
diff --git a/panels/wacom/calibrator/calibrator.c b/panels/wacom/calibrator/calibrator.c
deleted file mode 100644
index c597d79..0000000
--- a/panels/wacom/calibrator/calibrator.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (c) 2009 Tias Guns
- * Copyright (c) 2009 Soren Hauberg
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#include <stdlib.h>
-
-#include "calibrator.h"
-
-#define SWAP(x,y)  do { int t; t=(x); x=(y); y=t; } while (0)
-
-/* reset clicks */
-void
-reset (struct Calib *c)
-{
-    c->num_clicks = 0;
-}
-
-/* check whether the coordinates are along the respective axis */
-static gboolean
-along_axis (struct Calib *c,
-            int           xy,
-            int           x0,
-            int           y0)
-{
-    return ((abs(xy - x0) <= c->threshold_misclick) ||
-            (abs(xy - y0) <= c->threshold_misclick));
-}
-
-/* add a click with the given coordinates */
-gboolean
-add_click (struct Calib *c,
-           int           x,
-           int           y)
-{
-    /* Double-click detection */
-    if (c->threshold_doubleclick > 0 && c->num_clicks > 0)
-    {
-        int i = c->num_clicks-1;
-        while (i >= 0)
-        {
-            if (abs(x - c->clicked_x[i]) <= c->threshold_doubleclick &&
-                abs(y - c->clicked_y[i]) <= c->threshold_doubleclick)
-            {
-                return FALSE;
-            }
-            i--;
-        }
-    }
-
-    /* Mis-click detection */
-    if (c->threshold_misclick > 0 && c->num_clicks > 0)
-    {
-        gboolean misclick = TRUE;
-
-        if (c->num_clicks == 1)
-        {
-            /* check that along one axis of first point */
-            if (along_axis(c, x,c->clicked_x[0],c->clicked_y[0]) ||
-                along_axis(c, y,c->clicked_x[0],c->clicked_y[0]))
-            {
-                misclick = FALSE;
-            }
-        }
-        else if (c->num_clicks == 2)
-        {
-            /* check that along other axis of first point than second point */
-            if ((along_axis(c, y,c->clicked_x[0],c->clicked_y[0]) &&
-                 along_axis(c, c->clicked_x[1],c->clicked_x[0],c->clicked_y[0])) ||
-                (along_axis(c, x,c->clicked_x[0],c->clicked_y[0]) &&
-                 along_axis(c, c->clicked_y[1],c->clicked_x[0],c->clicked_y[0])))
-            {
-                misclick = FALSE;
-            }
-        }
-        else if (c->num_clicks == 3)
-        {
-            /* check that along both axis of second and third point */
-            if ((along_axis(c, x,c->clicked_x[1],c->clicked_y[1]) &&
-                 along_axis(c, y,c->clicked_x[2],c->clicked_y[2])) ||
-                (along_axis(c, y,c->clicked_x[1],c->clicked_y[1]) &&
-                 along_axis(c, x,c->clicked_x[2],c->clicked_y[2])))
-            {
-                misclick = FALSE;
-            }
-        }
-
-        if (misclick)
-        {
-            reset(c);
-            return FALSE;
-        }
-    }
-
-    c->clicked_x[c->num_clicks] = x;
-    c->clicked_y[c->num_clicks] = y;
-    c->num_clicks++;
-
-    return TRUE;
-}
-
-/* calculate and apply the calibration */
-gboolean
-finish (struct Calib *c,
-        XYinfo       *new_axis,
-        gboolean         *swap)
-{
-    gboolean swap_xy;
-    float scale_x;
-    float scale_y;
-    int delta_x;
-    int delta_y;
-    XYinfo axis = {-1, -1, -1, -1};
-
-    if (c->num_clicks != 4)
-        return FALSE;
-
-    /* Should x and y be swapped? */
-    swap_xy = (abs (c->clicked_x [UL] - c->clicked_x [UR]) < abs (c->clicked_y [UL] - c->clicked_y [UR]));
-    if (swap_xy)
-    {
-        SWAP(c->clicked_x[LL], c->clicked_x[UR]);
-        SWAP(c->clicked_y[LL], c->clicked_y[UR]);
-    }
-
-    /* Compute min/max coordinates. */
-    /* These are scaled using the values of old_axis */
-    scale_x = (c->old_axis.x_max - c->old_axis.x_min)/(float)c->geometry.width;
-    axis.x_min = ((((c->clicked_x[UL] + c->clicked_x[LL]) / 2) - c->geometry.x) * scale_x) + c->old_axis.x_min;
-    axis.x_max = ((((c->clicked_x[UR] + c->clicked_x[LR]) / 2) - c->geometry.x) * scale_x) + c->old_axis.x_min;
-    scale_y = (c->old_axis.y_max - c->old_axis.y_min)/(float)c->geometry.height;
-    axis.y_min = ((((c->clicked_y[UL] + c->clicked_y[UR]) / 2) - c->geometry.y) * scale_y) + c->old_axis.y_min;
-    axis.y_max = ((((c->clicked_y[LL] + c->clicked_y[LR]) / 2) - c->geometry.y) * scale_y) + c->old_axis.y_min;
-
-    /* Add/subtract the offset that comes from not having the points in the
-     * corners (using the same coordinate system they are currently in)
-     */
-    delta_x = (axis.x_max - axis.x_min) / (float)(NUM_BLOCKS - 2);
-    axis.x_min -= delta_x;
-    axis.x_max += delta_x;
-    delta_y = (axis.y_max - axis.y_min) / (float)(NUM_BLOCKS - 2);
-    axis.y_min -= delta_y;
-    axis.y_max += delta_y;
-
-    /* If x and y has to be swapped we also have to swap the parameters */
-    if (swap_xy)
-    {
-        SWAP(axis.x_min, axis.y_max);
-        SWAP(axis.y_min, axis.x_max);
-    }
-
-    *new_axis = axis;
-    *swap = swap_xy;
-
-    return TRUE;
-}
-
diff --git a/panels/wacom/calibrator/calibrator.h b/panels/wacom/calibrator/calibrator.h
deleted file mode 100644
index 75d72d7..0000000
--- a/panels/wacom/calibrator/calibrator.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2009 Tias Guns
- * Copyright (c) 2009 Soren Hauberg
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#ifndef _calibrator_h
-#define _calibrator_h
-
-#include <glib.h>
-#include "gui_gtk.h"
-
-/*
- * Number of blocks. We partition the screen into 'num_blocks' x 'num_blocks'
- * rectangles of equal size. We then ask the user to press points that are
- * located at the corner closes to the center of the four blocks in the corners
- * of the screen. The following ascii art illustrates the situation. We partition
- * the screen into 8 blocks in each direction. We then let the user press the
- * points marked with 'O'.
- *
- *   +--+--+--+--+--+--+--+--+
- *   |  |  |  |  |  |  |  |  |
- *   +--O--+--+--+--+--+--O--+
- *   |  |  |  |  |  |  |  |  |
- *   +--+--+--+--+--+--+--+--+
- *   |  |  |  |  |  |  |  |  |
- *   +--+--+--+--+--+--+--+--+
- *   |  |  |  |  |  |  |  |  |
- *   +--+--+--+--+--+--+--+--+
- *   |  |  |  |  |  |  |  |  |
- *   +--+--+--+--+--+--+--+--+
- *   |  |  |  |  |  |  |  |  |
- *   +--+--+--+--+--+--+--+--+
- *   |  |  |  |  |  |  |  |  |
- *   +--O--+--+--+--+--+--O--+
- *   |  |  |  |  |  |  |  |  |
- *   +--+--+--+--+--+--+--+--+
- */
-#define NUM_BLOCKS 8
-
-/* Names of the points */
-enum
-{
-	UL = 0, /* Upper-left  */
-	UR = 1, /* Upper-right */
-	LL = 2, /* Lower-left  */
-	LR = 3  /* Lower-right */
-};
-
-struct Calib
-{
-    /* original axis values */
-    XYinfo old_axis;
-
-    /* Geometry of the calibration window */
-    GdkRectangle geometry;
-
-    /* nr of clicks registered */
-    int num_clicks;
-
-    /* click coordinates */
-    int clicked_x[4], clicked_y[4];
-
-    /* Threshold to keep the same point from being clicked twice.
-     * Set to zero if you don't want this check
-     */
-    int threshold_doubleclick;
-
-    /* Threshold to detect mis-clicks (clicks not along axes)
-     * A lower value forces more precise calibration
-     * Set to zero if you don't want this check
-     */
-    int threshold_misclick;
-};
-
-void reset      (struct Calib *c);
-gboolean add_click  (struct Calib *c,
-                 int           x,
-                 int           y);
-gboolean finish     (struct Calib *c,
-                 XYinfo       *new_axis,
-                 gboolean         *swap);
-
-#endif /* _calibrator_h */
diff --git a/panels/wacom/calibrator/gui_gtk.c b/panels/wacom/calibrator/gui_gtk.c
deleted file mode 100644
index ec07f08..0000000
--- a/panels/wacom/calibrator/gui_gtk.c
+++ /dev/null
@@ -1,579 +0,0 @@
-/*
- * Copyright (c) 2009 Tias Guns
- * Copyright (c) 2009 Soren Hauberg
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#include "config.h"
-
-#include <math.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <glib/gi18n.h>
-#include <gdk/gdkx.h>
-#include <gtk/gtk.h>
-#include <cairo.h>
-
-#include "calibrator.h"
-#include "gui_gtk.h"
-
-struct CalibArea
-{
-    struct Calib calibrator;
-    XYinfo       axis;
-    gboolean     swap;
-    gboolean     success;
-    int          device_id;
-
-    double X[4], Y[4];
-    int display_width, display_height;
-    int time_elapsed;
-
-    const char* message;
-
-    guint anim_id;
-
-    GtkWidget *window;
-    GdkPixbuf *icon_success;
-
-    FinishCallback callback;
-    gpointer       user_data;
-};
-
-
-/* Window parameters */
-#define WINDOW_OPACITY		0.9
-
-/* Timeout parameters */
-#define TIME_STEP		100   /* in milliseconds */
-#define MAX_TIME		15000 /* 5000 = 5 sec */
-#define END_TIME		750   /*  750 = 0.75 sec */
-
-/* Clock appereance */
-#define CROSS_LINES		47
-#define CROSS_CIRCLE		7
-#define CROSS_CIRCLE2		27
-#define CLOCK_RADIUS		50
-#define CLOCK_LINE_WIDTH	10
-#define CLOCK_LINE_PADDING	10
-
-/* Text printed on screen */
-#define HELP_TEXT_TITLE N_("Screen Calibration")
-#define HELP_TEXT_MAIN  N_("Please tap the target markers as they appear on screen to calibrate the tablet.")
-
-#define ICON_SUCCESS	"emblem-ok-symbolic"
-#define ICON_SIZE	300
-
-static void
-set_display_size(CalibArea *calib_area,
-                 int               width,
-                 int               height)
-{
-    int delta_x;
-    int delta_y;
-
-    calib_area->display_width = width;
-    calib_area->display_height = height;
-
-    /* Compute absolute circle centers */
-    delta_x = calib_area->display_width/NUM_BLOCKS;
-    delta_y = calib_area->display_height/NUM_BLOCKS;
-
-    calib_area->X[UL] = delta_x;
-    calib_area->Y[UL] = delta_y;
-
-    calib_area->X[UR] = calib_area->display_width - delta_x - 1;
-    calib_area->Y[UR] = delta_y;
-
-    calib_area->X[LL] = delta_x;
-    calib_area->Y[LL] = calib_area->display_height - delta_y - 1;
-
-    calib_area->X[LR] = calib_area->display_width - delta_x - 1;
-    calib_area->Y[LR] = calib_area->display_height - delta_y - 1;
-
-    /* reset calibration if already started */
-    reset(&calib_area->calibrator);
-}
-
-static void
-resize_display(CalibArea *calib_area)
-{
-    /* check that screensize did not change (if no manually specified geometry) */
-    GtkAllocation allocation;
-    gtk_widget_get_allocation(calib_area->window, &allocation);
-    if (calib_area->display_width != allocation.width ||
-        calib_area->display_height != allocation.height)
-    {
-        set_display_size(calib_area, allocation.width, allocation.height);
-    }
-}
-
-static void
-draw_success_icon (CalibArea *area, cairo_t *cr)
-{
-    GtkWidget *widget;
-    GtkStyleContext *context;
-    gint icon_width, icon_height;
-    gdouble x;
-    gdouble y;
-
-    widget = GTK_WIDGET (area->window);
-    context = gtk_widget_get_style_context (widget);
-
-    icon_width = gdk_pixbuf_get_width (area->icon_success);
-    icon_height = gdk_pixbuf_get_height (area->icon_success);
-
-    x = (area->display_width - icon_width) / 2;
-    y = (area->display_height - icon_height) / 2;
-
-    gtk_render_icon (context, cr, area->icon_success, x, y);
-}
-
-static void
-draw(GtkWidget *widget, cairo_t *cr, gpointer data)
-{
-    CalibArea *calib_area = (CalibArea*)data;
-    int i;
-    double x;
-    double y;
-    PangoLayout *layout;
-    PangoRectangle logical_rect;
-    GtkStyleContext *context;
-    char *markup;
-
-    resize_display(calib_area);
-
-    context = gtk_widget_get_style_context (widget);
-
-    /* Black background and reset the operator */
-    cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR);
-    cairo_paint (cr);
-    cairo_set_operator (cr, CAIRO_OPERATOR_OVER);
-
-    /* If calibration is successful, just draw the tick */
-    if (calib_area->icon_success) {
-        draw_success_icon (calib_area, cr);
-        return;
-    }
-
-    /* Print the help lines */
-    layout = pango_layout_new (gtk_widget_get_pango_context (widget));
-    pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
-    markup = g_strdup_printf ("<span foreground=\"white\"><big><b>%s</b></big>\n<big>%s</big></span>",
-			      _(HELP_TEXT_TITLE),
-			      _(HELP_TEXT_MAIN));
-    pango_layout_set_markup (layout, markup, -1);
-    g_free (markup);
-
-    pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
-
-    x = (calib_area->display_width - logical_rect.width) / 2 + logical_rect.x;
-    y = (calib_area->display_height - logical_rect.height) / 2  - logical_rect.height - 40 + logical_rect.y;
-
-    gtk_render_layout (context, cr,
-		       x + logical_rect.x,
-		       y + logical_rect.y,
-		       layout);
-    g_object_unref (layout);
-
-    /* Draw the points */
-    cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
-
-    i = calib_area->calibrator.num_clicks;
-
-    cairo_set_line_width(cr, 1);
-    cairo_move_to(cr, calib_area->X[i] - CROSS_LINES, calib_area->Y[i] - 0.5);
-    cairo_rel_line_to(cr, CROSS_LINES*2, 0);
-    cairo_move_to(cr, calib_area->X[i] - 0.5, calib_area->Y[i] - CROSS_LINES);
-    cairo_rel_line_to(cr, 0, CROSS_LINES*2);
-    cairo_stroke(cr);
-
-    cairo_set_line_width(cr, 2);
-    cairo_arc(cr, calib_area->X[i] - 0.5, calib_area->Y[i] - 0.5, CROSS_CIRCLE, 0.0, 2.0 * M_PI);
-    cairo_stroke(cr);
-
-    cairo_set_line_width(cr, 5);
-    cairo_arc(cr, calib_area->X[i] - 0.5, calib_area->Y[i] - 0.5, CROSS_CIRCLE2, 0.0, 2.0 * M_PI);
-    cairo_stroke(cr);
-
-    /* Draw the clock background */
-    cairo_arc(cr, calib_area->display_width/2, calib_area->display_height/2, CLOCK_RADIUS/2, 0.0, 2.0 * M_PI);
-    cairo_set_source_rgb(cr, 0.5, 0.5, 0.5);
-    cairo_fill_preserve(cr);
-    cairo_stroke(cr);
-
-    cairo_set_line_width(cr, CLOCK_LINE_WIDTH);
-    cairo_arc(cr, calib_area->display_width/2, calib_area->display_height/2, (CLOCK_RADIUS - CLOCK_LINE_WIDTH - CLOCK_LINE_PADDING)/2,
-         3/2.0*M_PI, (3/2.0*M_PI) + ((double)calib_area->time_elapsed/(double)MAX_TIME) * 2*M_PI);
-    cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
-    cairo_stroke(cr);
-
-    /* Draw the message (if any) */
-    if (calib_area->message != NULL)
-    {
-        cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
-
-        /* Frame the message */
-        layout = pango_layout_new (gtk_widget_get_pango_context (widget));
-        pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
-        markup = g_strdup_printf ("<span foreground=\"white\"><big>%s</big></span>",
-				  _(calib_area->message));
-        pango_layout_set_markup (layout, markup, -1);
-        g_free (markup);
-        pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
-
-        x = (calib_area->display_width - logical_rect.width) / 2 + logical_rect.x;
-        y = (calib_area->display_height - logical_rect.height + CLOCK_RADIUS) / 2 + 60 + logical_rect.y;
-        cairo_set_line_width(cr, 2);
-        cairo_rectangle(cr, x - 10 - 0.5 , y - 10 - 0.5,
-                logical_rect.width + 20 + 1, logical_rect.height + 20 + 1);
-        cairo_stroke (cr);
-
-        /* Print the message */
-	gtk_render_layout (context, cr,
-			   x + logical_rect.x,
-			   y + logical_rect.y,
-			   layout);
-	g_object_unref (layout);
-    }
-}
-
-static void
-draw_message(CalibArea *calib_area,
-             const char       *msg)
-{
-    calib_area->message = msg;
-}
-
-static void
-redraw(CalibArea *calib_area)
-{
-    GdkWindow *win = gtk_widget_get_window(calib_area->window);
-    if (win)
-    {
-        GdkRectangle rect;
-        rect.x = 0;
-        rect.y = 0;
-        rect.width = calib_area->display_width;
-        rect.height = calib_area->display_height;
-        gdk_window_invalidate_rect(win, &rect, FALSE);
-    }
-}
-
-static gboolean
-on_delete_event (GtkWidget *widget,
-		 GdkEvent  *event,
-		 CalibArea *area)
-{
-	if (area->anim_id > 0) {
-		g_source_remove (area->anim_id);
-		area->anim_id = 0;
-	}
-
-	gtk_widget_hide (area->window);
-
-	(*area->callback) (area, area->user_data);
-
-	return TRUE;
-}
-
-static gboolean
-draw_success_end_wait_callback (CalibArea *area)
-{
-    on_delete_event (NULL, NULL, area);
-
-    return FALSE;
-}
-
-static void
-set_calibration_status (CalibArea *area)
-{
-	GtkIconTheme *icon_theme;
-	GtkIconInfo  *icon_info;
-	GdkRGBA       white;
-
-	icon_theme = gtk_icon_theme_get_default ();
-	icon_info = gtk_icon_theme_lookup_icon (icon_theme,
-						ICON_SUCCESS,
-						ICON_SIZE,
-						GTK_ICON_LOOKUP_USE_BUILTIN);
-	if (icon_info == NULL) {
-		g_warning ("Failed to find icon \"%s\"", ICON_SUCCESS);
-		goto out;
-	}
-
-	gdk_rgba_parse (&white, "White");
-	area->icon_success = gtk_icon_info_load_symbolic (icon_info,
-							  &white,
-							  NULL,
-							  NULL,
-							  NULL,
-							  NULL,
-							  NULL);
-	g_object_unref (icon_info);
-	if (!area->icon_success)
-		g_warning ("Failed to load icon \"%s\"", ICON_SUCCESS);
-
-out:
-	area->success = finish (&area->calibrator, &area->axis, &area->swap);
-	if (area->success && area->icon_success) {
-		redraw(area);
-		g_timeout_add(END_TIME, (GSourceFunc) draw_success_end_wait_callback, area);
-	} else {
-		on_delete_event (NULL, NULL, area);
-	}
-}
-
-static gboolean
-on_button_press_event(GtkWidget      *widget,
-                      GdkEventButton *event,
-                      CalibArea      *area)
-{
-    gboolean success;
-
-    if (area->success)
-        return FALSE;
-
-    /* Check matching device ID if a device ID was provided */
-    if (area->device_id > -1) {
-        GdkDevice *device;
-
-        device = gdk_event_get_source_device ((GdkEvent *) event);
-        if (device != NULL && gdk_x11_device_get_id (device) != area->device_id)
-	    return FALSE;
-    }
-
-    /* Handle click */
-    area->time_elapsed = 0;
-    success = add_click(&area->calibrator, (int)event->x_root, (int)event->y_root);
-
-    if (!success && area->calibrator.num_clicks == 0)
-        draw_message(area, N_("Mis-click detected, restarting..."));
-    else
-        draw_message(area, NULL);
-
-    /* Are we done yet? */
-    if (area->calibrator.num_clicks >= 4)
-    {
-        set_calibration_status (area);
-        return FALSE;
-    }
-
-    /* Force a redraw */
-    redraw(area);
-
-    return FALSE;
-}
-
-static gboolean
-on_key_release_event(GtkWidget   *widget,
-                     GdkEventKey *event,
-                     CalibArea   *area)
-{
-    if (area->success)
-        return FALSE;
-    if (event->type != GDK_KEY_RELEASE)
-        return FALSE;
-    if (event->keyval != GDK_KEY_Escape)
-        return FALSE;
-
-    on_delete_event (widget, NULL, area);
-
-    return FALSE;
-}
-
-static gboolean
-on_focus_out_event (GtkWidget *widget,
-		    GdkEvent  *event,
-		    CalibArea *area)
-{
-    if (area->success)
-        return FALSE;
-
-    /* If the calibrator window looses focus, simply bail out... */
-    on_delete_event (widget, NULL, area);
-
-    return FALSE;
-}
-
-static gboolean
-on_timer_signal(CalibArea *area)
-{
-    GdkWindow *win;
-
-    area->time_elapsed += TIME_STEP;
-    if (area->time_elapsed > MAX_TIME)
-    {
-        set_calibration_status (area);
-        return FALSE;
-    }
-
-    /* Update clock */
-    win = gtk_widget_get_window (area->window);
-    if (win)
-    {
-        GdkRectangle rect;
-        rect.x = area->display_width/2 - CLOCK_RADIUS - CLOCK_LINE_WIDTH;
-        rect.y = area->display_height/2 - CLOCK_RADIUS - CLOCK_LINE_WIDTH;
-        rect.width = 2 * CLOCK_RADIUS + 1 + 2 * CLOCK_LINE_WIDTH;
-        rect.height = 2 * CLOCK_RADIUS + 1 + 2 * CLOCK_LINE_WIDTH;
-        gdk_window_invalidate_rect(win, &rect, FALSE);
-    }
-
-    return TRUE;
-}
-
-/**
- * Creates the windows and other objects required to do calibration
- * under GTK. When the window is closed (timed out, calibration finished
- * or user cancellation), callback will be called, where you should call
- * calib_area_finish().
- */
-CalibArea *
-calib_area_new (GdkScreen      *screen,
-		int             monitor,
-		int             device_id,
-		FinishCallback  callback,
-		gpointer        user_data,
-		XYinfo         *old_axis,
-		int             threshold_doubleclick,
-		int             threshold_misclick)
-{
-	CalibArea *calib_area;
-	GdkRectangle rect;
-	GdkWindow *window;
-	GdkRGBA black;
-	GdkCursor *cursor;
-
-	g_return_val_if_fail (old_axis, NULL);
-	g_return_val_if_fail (callback, NULL);
-
-	g_debug ("Current calibration: %d, %d, %d, %d\n",
-		 old_axis->x_min,
-		 old_axis->y_min,
-		 old_axis->x_max,
-		 old_axis->y_max);
-
-	calib_area = g_new0 (CalibArea, 1);
-	calib_area->callback = callback;
-	calib_area->user_data = user_data;
-	calib_area->device_id = device_id;
-	calib_area->calibrator.old_axis.x_min = old_axis->x_min;
-	calib_area->calibrator.old_axis.x_max = old_axis->x_max;
-	calib_area->calibrator.old_axis.y_min = old_axis->y_min;
-	calib_area->calibrator.old_axis.y_max = old_axis->y_max;
-	calib_area->calibrator.threshold_doubleclick = threshold_doubleclick;
-	calib_area->calibrator.threshold_misclick = threshold_misclick;
-
-	/* Set up the window */
-	calib_area->window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-	gtk_widget_set_app_paintable (GTK_WIDGET (calib_area->window), TRUE);
-
-	/* Black background */
-	gdk_rgba_parse (&black, "rgb(0,0,0)");
-	gtk_widget_set_opacity (calib_area->window, WINDOW_OPACITY);
-
-	gtk_widget_realize (calib_area->window);
-	window = gtk_widget_get_window (calib_area->window);
-	gdk_window_set_background_rgba (window, &black);
-
-	/* No cursor */
-	cursor = gdk_cursor_new (GDK_BLANK_CURSOR);
-	gdk_window_set_cursor (window, cursor);
-	g_object_unref (cursor);
-
-	/* Listen for mouse events */
-	gtk_widget_add_events (calib_area->window, GDK_KEY_RELEASE_MASK | GDK_BUTTON_PRESS_MASK);
-	gtk_widget_set_can_focus (calib_area->window, TRUE);
-	gtk_window_fullscreen (GTK_WINDOW (calib_area->window));
-	gtk_window_set_keep_above (GTK_WINDOW (calib_area->window), TRUE);
-
-	/* Connect callbacks */
-	g_signal_connect (calib_area->window, "draw",
-			  G_CALLBACK(draw), calib_area);
-	g_signal_connect (calib_area->window, "button-press-event",
-			  G_CALLBACK(on_button_press_event), calib_area);
-	g_signal_connect (calib_area->window, "key-release-event",
-			  G_CALLBACK(on_key_release_event), calib_area);
-	g_signal_connect (calib_area->window, "delete-event",
-			  G_CALLBACK(on_delete_event), calib_area);
-	g_signal_connect (calib_area->window, "focus-out-event",
-			  G_CALLBACK(on_focus_out_event), calib_area);
-
-	/* Setup timer for animation */
-	calib_area->anim_id = g_timeout_add(TIME_STEP, (GSourceFunc)on_timer_signal, calib_area);
-
-	/* Move to correct screen */
-	if (screen == NULL)
-		screen = gdk_screen_get_default ();
-	gdk_screen_get_monitor_geometry (screen, monitor, &rect);
-	gtk_window_move (GTK_WINDOW (calib_area->window), rect.x, rect.y);
-	gtk_window_set_default_size (GTK_WINDOW (calib_area->window), rect.width, rect.height);
-
-	calib_area->calibrator.geometry.x = rect.x;
-	calib_area->calibrator.geometry.y = rect.y;
-	calib_area->calibrator.geometry.width = rect.width;
-	calib_area->calibrator.geometry.height = rect.height;
-
-	gtk_widget_show_all (calib_area->window);
-
-	return calib_area;
-}
-
-/* Finishes the calibration. Note that CalibArea
- * needs to be destroyed with calib_area_free() afterwards */
-gboolean
-calib_area_finish (CalibArea *area,
-		   XYinfo    *new_axis,
-		   gboolean  *swap_xy)
-{
-	g_return_val_if_fail (area != NULL, FALSE);
-
-	*new_axis = area->axis;
-	*swap_xy  = area->swap;
-
-	if (area->success)
-		g_debug ("Final calibration: %d, %d, %d, %d\n",
-			 new_axis->x_min,
-			 new_axis->y_min,
-			 new_axis->x_max,
-			 new_axis->y_max);
-	else
-		g_debug ("Calibration was aborted or timed out");
-
-	return area->success;
-}
-
-void
-calib_area_free (CalibArea *area)
-{
-	g_return_if_fail (area != NULL);
-
-	if (area->anim_id > 0) {
-		g_source_remove (area->anim_id);
-		area->anim_id = 0;
-	}
-
-	if (area->icon_success)
-		g_object_unref (area->icon_success);
-
-	gtk_widget_destroy (area->window);
-	g_free (area);
-}
diff --git a/panels/wacom/calibrator/gui_gtk.h b/panels/wacom/calibrator/gui_gtk.h
deleted file mode 100644
index d3d12fc..0000000
--- a/panels/wacom/calibrator/gui_gtk.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2009 Tias Guns
- * Copyright (c) 2009 Soren Hauberg
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#ifndef _gui_gtk_h
-#define _gui_gtk_h
-
-#include <gtk/gtk.h>
-
-/* struct to hold min/max info of the X and Y axis */
-typedef struct
-{
-	int x_min;
-	int x_max;
-	int y_min;
-	int y_max;
-} XYinfo;
-
-typedef struct CalibArea CalibArea;
-typedef void (*FinishCallback) (CalibArea *area, gpointer user_data);
-
-CalibArea * calib_area_new (GdkScreen      *screen,
-			    int             monitor,
-			    int             device_id,
-			    FinishCallback  callback,
-			    gpointer        user_data,
-			    XYinfo         *old_axis,
-			    int             threshold_doubleclick,
-			    int             threshold_misclick);
-
-gboolean calib_area_finish (CalibArea *area,
-			    XYinfo    *new_axis,
-			    gboolean  *swap_xy);
-
-void calib_area_free (CalibArea *area);
-
-#endif /* _gui_gtk_h */
diff --git a/panels/wacom/calibrator/main.c b/panels/wacom/calibrator/main.c
deleted file mode 100644
index 2368a10..0000000
--- a/panels/wacom/calibrator/main.c
+++ /dev/null
@@ -1,418 +0,0 @@
-/*
- * Copyright (c) 2009 Tias Guns
- * Copyright (c) 2009 Soren Hauberg
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#include "config.h"
-
-#include <stdlib.h>
-#include <ctype.h>
-#include <string.h>
-#include <dirent.h>
-#include <glib/gi18n.h>
-
-#include <X11/extensions/XInput.h>
-
-#include "gui_gtk.h"
-#include "calibrator.h"
-
-/**
- * find a calibratable touchscreen device (using XInput)
- *
- * if pre_device is NULL, the last calibratable device is selected.
- * retuns number of devices found,
- * the data of the device is returned in the last 3 function parameters
- */
-static int find_device(const char* pre_device, gboolean verbose, gboolean list_devices,
-        XID* device_id, const char** device_name, XYinfo* device_axis)
-{
-    gboolean pre_device_is_id = TRUE;
-    int found = 0;
-
-    Display* display = XOpenDisplay(NULL);
-    if (display == NULL) {
-        fprintf(stderr, "Unable to connect to X server\n");
-        exit(1);
-    }
-
-    int xi_opcode, event, error;
-    if (!XQueryExtension(display, "XInputExtension", &xi_opcode, &event, &error)) {
-        fprintf(stderr, "X Input extension not available.\n");
-        exit(1);
-    }
-
-    /* verbose, get Xi version */
-    if (verbose) {
-        XExtensionVersion *version = XGetExtensionVersion(display, INAME);
-
-        if (version && (version != (XExtensionVersion*) NoSuchExtension)) {
-            printf("DEBUG: %s version is %i.%i\n",
-                INAME, version->major_version, version->minor_version);
-            XFree(version);
-        }
-    }
-
-    if (pre_device != NULL) {
-        /* check whether the pre_device is an ID (only digits) */
-        int len = strlen(pre_device);
-        int loop;
-        for (loop=0; loop<len; loop++) {
-	        if (!isdigit(pre_device[loop])) {
-	            pre_device_is_id = FALSE;
-	            break;
-	        }
-        }
-    }
-
-
-    if (verbose)
-        printf("DEBUG: Skipping virtual master devices and devices without axis valuators.\n");
-    int ndevices;
-    XDeviceInfoPtr list, slist;
-    slist=list=(XDeviceInfoPtr) XListInputDevices (display, &ndevices);
-    int i;
-    for (i=0; i<ndevices; i++, list++)
-    {
-        if (list->use == IsXKeyboard || list->use == IsXPointer) /* virtual master device */
-            continue;
-
-        /* if we are looking for a specific device */
-        if (pre_device != NULL) {
-            if ((pre_device_is_id && list->id == (XID) atoi(pre_device)) ||
-                (!pre_device_is_id && strcmp(list->name, pre_device) == 0)) {
-                /* OK, fall through */
-            } else {
-                /* skip, not this device */
-                continue;
-            }
-        }
-
-        XAnyClassPtr any = (XAnyClassPtr) (list->inputclassinfo);
-        int j;
-        for (j=0; j<list->num_classes; j++)
-        {
-
-            if (any->class == ValuatorClass)
-            {
-                XValuatorInfoPtr V = (XValuatorInfoPtr) any;
-                XAxisInfoPtr ax = (XAxisInfoPtr) V->axes;
-
-                if (V->mode != Absolute) {
-                    if (verbose)
-                        printf("DEBUG: Skipping device '%s' id=%i, does not report Absolute events.\n",
-                            list->name, (int)list->id);
-                } else if (V->num_axes < 2 ||
-                    (ax[0].min_value == -1 && ax[0].max_value == -1) ||
-                    (ax[1].min_value == -1 && ax[1].max_value == -1)) {
-                    if (verbose)
-                        printf("DEBUG: Skipping device '%s' id=%i, does not have two calibratable axes.\n",
-                            list->name, (int)list->id);
-                } else {
-                    /* a calibratable device (has 2 axis valuators) */
-                    found++;
-                    *device_id = list->id;
-                    *device_name = g_strdup(list->name);
-                    device_axis->x_min = ax[0].min_value;
-                    device_axis->x_max = ax[0].max_value;
-                    device_axis->y_min = ax[1].min_value;
-                    device_axis->y_max = ax[1].max_value;
-
-                    if (list_devices)
-                        printf("Device \"%s\" id=%i\n", *device_name, (int)*device_id);
-                }
-
-            }
-
-            /*
-             * Increment 'any' to point to the next item in the linked
-             * list.  The length is in bytes, so 'any' must be cast to
-             * a character pointer before being incremented.
-             */
-            any = (XAnyClassPtr) ((char *) any + any->length);
-        }
-
-    }
-    XFreeDeviceList(slist);
-    XCloseDisplay(display);
-
-    return found;
-}
-
-static void usage(char* cmd, unsigned thr_misclick)
-{
-    fprintf(stderr, "Usage: %s [-h|--help] [-v|--verbose] [--list] [--device <device name or id>] [--precalib <minx> <maxx> <miny> <maxy>] [--misclick <nr of pixels>] [--output-type <auto|xorg.conf.d|hal|xinput>] [--fake]\n", cmd);
-    fprintf(stderr, "\t-h, --help: print this help message\n");
-    fprintf(stderr, "\t-v, --verbose: print debug messages during the process\n");
-    fprintf(stderr, "\t--list: list calibratable input devices and quit\n");
-    fprintf(stderr, "\t--device <device name or id>: select a specific device to calibrate\n");
-    fprintf(stderr, "\t--precalib: manually provide the current calibration setting (eg. the values in xorg.conf)\n");
-    fprintf(stderr, "\t--misclick: set the misclick threshold (0=off, default: %i pixels)\n",
-        thr_misclick);
-    fprintf(stderr, "\t--fake: emulate a fake device (for testing purposes)\n");
-}
-
-static struct Calib* CalibratorXorgPrint(const char* const device_name0, const XYinfo *axis0, const gboolean verbose0, const int thr_misclick, const int thr_doubleclick)
-{
-    struct Calib* c = (struct Calib*)calloc(1, sizeof(struct Calib));
-    c->old_axis = *axis0;
-    c->threshold_misclick = thr_misclick;
-    c->threshold_doubleclick = thr_doubleclick;
-
-    printf("Calibrating standard Xorg driver \"%s\"\n", device_name0);
-    printf("\tcurrent calibration values: min_x=%d, max_x=%d and min_y=%d, max_y=%d\n",
-                c->old_axis.x_min, c->old_axis.x_max, c->old_axis.y_min, c->old_axis.y_max);
-    printf("\tIf these values are estimated wrong, either supply it manually with the --precalib option, or run the 'get_precalib.sh' script to automatically get it (through HAL).\n");
-
-    return c;
-}
-
-static struct Calib* main_common(int argc, char** argv)
-{
-    gboolean verbose = FALSE;
-    gboolean list_devices = FALSE;
-    gboolean fake = FALSE;
-    gboolean precalib = FALSE;
-    XYinfo pre_axis = {-1, -1, -1, -1};
-    const char* pre_device = NULL;
-    unsigned thr_misclick = 15;
-    unsigned thr_doubleclick = 7;
-
-    /* parse input */
-    if (argc > 1) {
-        int i;
-        for (i=1; i!=argc; i++) {
-            /* Display help ? */
-            if (strcmp("-h", argv[i]) == 0 ||
-                strcmp("--help", argv[i]) == 0) {
-                fprintf(stderr, "xinput_calibratior, v%s\n\n", "0.0.0");
-                usage(argv[0], thr_misclick);
-                exit(0);
-            } else
-
-            /* Verbose output ? */
-            if (strcmp("-v", argv[i]) == 0 ||
-                strcmp("--verbose", argv[i]) == 0) {
-                verbose = TRUE;
-            } else
-
-            /* Just list devices ? */
-            if (strcmp("--list", argv[i]) == 0) {
-                list_devices = TRUE;
-            } else
-
-            /* Select specific device ? */
-            if (strcmp("--device", argv[i]) == 0) {
-                if (argc > i+1)
-                    pre_device = argv[++i];
-                else {
-                    fprintf(stderr, "Error: --device needs a device name or id as argument; use --list to list the calibratable input devices.\n\n");
-                    usage(argv[0], thr_misclick);
-                    exit(1);
-                }
-            } else
-
-            /* Get pre-calibration ? */
-            if (strcmp("--precalib", argv[i]) == 0) {
-                precalib = TRUE;
-                if (argc > i+1)
-                    pre_axis.x_min = atoi(argv[++i]);
-                if (argc > i+1)
-                    pre_axis.x_max = atoi(argv[++i]);
-                if (argc > i+1)
-                    pre_axis.y_min = atoi(argv[++i]);
-                if (argc > i+1)
-                    pre_axis.y_max = atoi(argv[++i]);
-            } else
-
-            /* Get mis-click threshold ? */
-            if (strcmp("--misclick", argv[i]) == 0) {
-                if (argc > i+1)
-                    thr_misclick = atoi(argv[++i]);
-                else {
-                    fprintf(stderr, "Error: --misclick needs a number (the pixel threshold) as argument. Set to 0 to disable mis-click detection.\n\n");
-                    usage(argv[0], thr_misclick);
-                    exit(1);
-                }
-            } else
-
-            /* Fake calibratable device ? */
-            if (strcmp("--fake", argv[i]) == 0) {
-                fake = TRUE;
-            }
-            
-            /* unknown option */
-            else {
-                fprintf(stderr, "Unknown option: %s\n\n", argv[i]);
-                usage(argv[0], thr_misclick);
-                exit(0);
-            }
-        }
-    }
-    
-
-    /* Choose the device to calibrate */
-    XID         device_id   = (XID) -1;
-    const char* device_name = NULL;
-    XYinfo      device_axis = {-1, -1, -1, -1};
-    if (fake) {
-        /* Fake a calibratable device */
-        device_name = "Fake_device";
-        device_axis.x_min=0;
-        device_axis.x_max=1000;
-        device_axis.y_min=0;
-        device_axis.y_max=1000;
-
-        if (verbose) {
-            printf("DEBUG: Faking device: %s\n", device_name);
-        }
-    } else {
-        /* Find the right device */
-        int nr_found = find_device(pre_device, verbose, list_devices, &device_id, &device_name, &device_axis);
-
-        if (list_devices) {
-            /* printed the list in find_device */
-            if (nr_found == 0)
-                printf("No calibratable devices found.\n");
-            exit(0);
-        }
-
-        if (nr_found == 0) {
-            if (pre_device == NULL)
-                fprintf (stderr, "Error: No calibratable devices found.\n");
-            else
-                fprintf (stderr, "Error: Device \"%s\" not found; use --list to list the calibratable input devices.\n", pre_device);
-            exit(1);
-
-        } else if (nr_found > 1) {
-            printf ("Warning: multiple calibratable devices found, calibrating last one (%s)\n\tuse --device to select another one.\n", device_name);
-        }
-
-        if (verbose) {
-            printf("DEBUG: Selected device: %s\n", device_name);
-        }
-    }
-
-    /* override min/max XY from command line ? */
-    if (precalib) {
-        if (pre_axis.x_min != -1)
-            device_axis.x_min = pre_axis.x_min;
-        if (pre_axis.x_max != -1)
-            device_axis.x_max = pre_axis.x_max;
-        if (pre_axis.y_min != -1)
-            device_axis.y_min = pre_axis.y_min;
-        if (pre_axis.y_max != -1)
-            device_axis.y_max = pre_axis.y_max;
-
-        if (verbose) {
-            printf("DEBUG: Setting precalibration: %i, %i, %i, %i\n",
-                device_axis.x_min, device_axis.x_max,
-                device_axis.y_min, device_axis.y_max);
-        }
-    }
-
-    /* lastly, presume a standard Xorg driver (evtouch, mutouch, ...) */
-    return CalibratorXorgPrint(device_name, &device_axis,
-            verbose, thr_misclick, thr_doubleclick);
-}
-
-static gboolean output_xorgconfd(const XYinfo new_axis, int swap_xy, int new_swap_xy)
-{
-    const char* sysfs_name = "!!Name_Of_TouchScreen!!";
-
-    /* xorg.conf.d snippet */
-    printf("  copy the snippet below into '/etc/X11/xorg.conf.d/99-calibration.conf'\n");
-    printf("Section \"InputClass\"\n");
-    printf("	Identifier	\"calibration\"\n");
-    printf("	MatchProduct	\"%s\"\n", sysfs_name);
-    printf("	Option	\"MinX\"	\"%d\"\n", new_axis.x_min);
-    printf("	Option	\"MaxX\"	\"%d\"\n", new_axis.x_max);
-    printf("	Option	\"MinY\"	\"%d\"\n", new_axis.y_min);
-    printf("	Option	\"MaxY\"	\"%d\"\n", new_axis.y_max);
-    if (swap_xy != 0)
-        printf("	Option	\"SwapXY\"	\"%d\" # unless it was already set to 1\n", new_swap_xy);
-    printf("EndSection\n");
-
-    return TRUE;
-}
-
-static gboolean finish_data(const XYinfo new_axis, int swap_xy)
-{
-    gboolean success = TRUE;
-
-    /* we suppose the previous 'swap_xy' value was 0 */
-    /* (unfortunately there is no way to verify this (yet)) */
-    int new_swap_xy = swap_xy;
-
-    printf("\n\n--> Making the calibration permanent <--\n");
-    success &= output_xorgconfd(new_axis, swap_xy, new_swap_xy);
-
-    return success;
-}
-
-static void
-calibration_finished_cb (CalibArea *area,
-			 gpointer   user_data)
-{
-	gboolean success;
-	XYinfo axis;
-	gboolean swap_xy;
-
-	success = calib_area_finish (area, &axis, &swap_xy);
-	if (success)
-		success = finish_data (axis, swap_xy);
-	else
-		fprintf(stderr, "Error: unable to apply or save configuration values\n");
-
-	gtk_main_quit ();
-}
-
-int main(int argc, char** argv)
-{
-
-    struct Calib* calibrator = main_common(argc, argv);
-    CalibArea *calib_area;
-
-    bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
-    bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-    textdomain (GETTEXT_PACKAGE);
-
-    g_setenv ("G_MESSAGES_DEBUG", "all", TRUE);
-
-    /* GTK setup */
-    gtk_init(&argc, &argv);
-
-    calib_area = calib_area_new (NULL,
-				 0,  /* monitor */
-				 -1, /* -1 to ignore device ID */
-				 calibration_finished_cb,
-				 NULL,
-				 &calibrator->old_axis,
-				 calibrator->threshold_doubleclick,
-				 calibrator->threshold_misclick);
-
-    gtk_main ();
-
-    calib_area_free (calib_area);
-
-    free(calibrator);
-
-    return 0;
-}
diff --git a/panels/wacom/cc-wacom-mapping-panel.c b/panels/wacom/cc-wacom-mapping-panel.c
deleted file mode 100644
index e8654a8..0000000
--- a/panels/wacom/cc-wacom-mapping-panel.c
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright  2012 Wacom.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Jason Gerecke <killertofu@gmail.com>
- *
- */
-
-#include <config.h>
-
-#include <gtk/gtk.h>
-#include <glib/gi18n.h>
-#define GNOME_DESKTOP_USE_UNSTABLE_API
-#include <libgnome-desktop/gnome-rr.h>
-#include <libgnome-desktop/gnome-rr-config.h>
-
-#include <string.h>
-
-#include "gsd-wacom-device.h"
-#include "cc-wacom-mapping-panel.h"
-
-G_DEFINE_TYPE (CcWacomMappingPanel, cc_wacom_mapping_panel, GTK_TYPE_BOX)
-
-#define WACOM_MAPPING_PANEL_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_MAPPING_PANEL, CcWacomMappingPanelPrivate))
-
-struct _CcWacomMappingPanelPrivate
-{
-	GsdWacomDevice *device;
-	GtkWidget      *label;
-	GtkWidget      *combobox;
-	GtkWidget      *checkbutton;
-	GtkWidget      *aspectlabel;
-	GtkWidget      *aspectswitch;
-};
-
-enum {
-	MONITOR_NAME_COLUMN,
-	MONITOR_NUM_COLUMN,
-	MONITOR_NUM_COLUMNS
-};
-
-static void combobox_changed_cb (GtkWidget *widget, CcWacomMappingPanel *self);
-static void checkbutton_toggled_cb (GtkWidget *widget, CcWacomMappingPanel *self);
-static void aspectswitch_toggled_cb (GtkWidget *widget, GParamSpec *pspec, CcWacomMappingPanel *self);
-
-static GnomeRROutputInfo**
-get_rr_outputs (void)
-{
-	GError *error = NULL;
-	GnomeRRScreen *rr_screen;
-	GnomeRRConfig *rr_config;
-
-	/* TODO: Check the value of 'error' */
-	rr_screen = gnome_rr_screen_new (gdk_screen_get_default (), &error);
-	rr_config = gnome_rr_config_new_current (rr_screen, &error);
-	return gnome_rr_config_get_outputs (rr_config);
-}
-
-static void
-set_combobox_sensitive (CcWacomMappingPanel *self,
-			gboolean             sensitive)
-{
-	gtk_widget_set_sensitive (GTK_WIDGET(self->priv->combobox), sensitive);
-	gtk_widget_set_sensitive (GTK_WIDGET(self->priv->label), sensitive);
-	gtk_widget_set_sensitive (GTK_WIDGET(self->priv->aspectswitch), sensitive);
-	gtk_widget_set_sensitive (GTK_WIDGET(self->priv->aspectlabel), sensitive);
-}
-
-/* Update the display of available monitors based on the latest
- * information from RandR. At the moment the chooser is just a
- * a combobox crudely listing available outputs. The UI mockup
- * has something more akin to the Display panel, with the ability
- * to do rubber-band selection of multiple outputs (note: the
- * g-s-d backend can only handle a single output at the moment)
- */
-static void
-update_monitor_chooser (CcWacomMappingPanel *self)
-{
-	GtkListStore *store;
-	GnomeRROutputInfo **outputs;
-	GdkRectangle geom;
-	GSettings *settings;
-	gint monitor;
-	gboolean single_mon;
-	guint i;
-
-	store = gtk_list_store_new (MONITOR_NUM_COLUMNS, G_TYPE_STRING, G_TYPE_INT);
-	gtk_combo_box_set_model (GTK_COMBO_BOX(self->priv->combobox), GTK_TREE_MODEL(store));
-
-	if (self->priv->device == NULL) {
-		set_combobox_sensitive (self, FALSE);
-		g_object_unref (store);
-		return;
-	}
-
-	settings = gsd_wacom_device_get_settings (self->priv->device);
-	monitor = gsd_wacom_device_get_display_monitor (self->priv->device);
-	single_mon = (monitor != GSD_WACOM_SET_ALL_MONITORS);
-
-	g_signal_handlers_block_by_func (G_OBJECT (self->priv->checkbutton), checkbutton_toggled_cb, self);
-	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(self->priv->checkbutton), single_mon);
-	g_signal_handlers_unblock_by_func (G_OBJECT (self->priv->checkbutton), checkbutton_toggled_cb, self);
-
-	g_signal_handlers_block_by_func (G_OBJECT (self->priv->aspectswitch), aspectswitch_toggled_cb, self);
-	gtk_switch_set_active (GTK_SWITCH(self->priv->aspectswitch), g_settings_get_boolean (settings, "keep-aspect"));
-	g_signal_handlers_unblock_by_func (G_OBJECT (self->priv->aspectswitch), aspectswitch_toggled_cb, self);
-
-	/* FIXME: does this break screen tablets? What's the default
-	 * for unconfigured tablets? */
-	if (monitor < 0)
-		monitor = 0;
-	gdk_screen_get_monitor_geometry (gdk_screen_get_default (), monitor, &geom);
-
-	outputs = get_rr_outputs ();
-	if (outputs == NULL)
-		goto bail;
-
-	for (i = 0; outputs[i] != NULL; i++) {
-		GnomeRROutputInfo *output = outputs[i];
-
-		if (gnome_rr_output_info_is_active (output)) {
-			GtkTreeIter iter;
-			gchar *name, *disp_name, *text;
-			int x, y, w, h;
-			int mon_at_point;
-
-			name = gnome_rr_output_info_get_name (output);
-			disp_name = gnome_rr_output_info_get_display_name (output);
-			text = g_strdup_printf ("%s (%s)", name, disp_name);
-
-			gnome_rr_output_info_get_geometry (output, &x, &y, &w, &h);
-			mon_at_point = gdk_screen_get_monitor_at_point (gdk_screen_get_default (), x, y);
-			gtk_list_store_append (store, &iter);
-			gtk_list_store_set (store, &iter, MONITOR_NAME_COLUMN, text, MONITOR_NUM_COLUMN, mon_at_point, -1);
-
-			if (x == geom.x && y == geom.y && w == geom.width && h == geom.height) {
-				g_signal_handlers_block_by_func (G_OBJECT (self->priv->combobox), combobox_changed_cb, self);
-				gtk_combo_box_set_active_iter (GTK_COMBO_BOX(self->priv->combobox), &iter);
-				g_signal_handlers_unblock_by_func (G_OBJECT (self->priv->combobox), combobox_changed_cb, self);
-			}
-
-			g_free (text);
-		}
-	}
-
-bail:
-	set_combobox_sensitive (self, single_mon);
-	g_object_unref (store);
-}
-
-static void
-update_ui (CcWacomMappingPanel *self)
-{
-	if (self->priv->device == NULL) {
-		gtk_widget_set_sensitive (GTK_WIDGET(self->priv->checkbutton), FALSE);
-		gtk_toggle_button_set_inconsistent (GTK_TOGGLE_BUTTON(self->priv->checkbutton), TRUE);
-	} else {
-		gboolean is_screen_tablet;
-
-		is_screen_tablet = gsd_wacom_device_is_screen_tablet (self->priv->device);
-		gtk_widget_set_sensitive (GTK_WIDGET(self->priv->checkbutton), !is_screen_tablet);
-		gtk_toggle_button_set_inconsistent (GTK_TOGGLE_BUTTON(self->priv->checkbutton), FALSE);
-	}
-
-	update_monitor_chooser (self);
-}
-
-static void
-update_mapping (CcWacomMappingPanel *self)
-{
-	int monitor = GSD_WACOM_SET_ALL_MONITORS;
-
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (self->priv->checkbutton))) {
-		GtkTreeIter iter;
-		GtkTreeModel *model;
-		char *name;
-
-		model = gtk_combo_box_get_model (GTK_COMBO_BOX (self->priv->combobox));
-		if (!gtk_combo_box_get_active_iter (GTK_COMBO_BOX (self->priv->combobox), &iter)) {
-			g_warning ("Map to single monitor checked, but no screen selected.");
-			return;
-		}
-
-		gtk_tree_model_get (model, &iter, MONITOR_NAME_COLUMN, &name, MONITOR_NUM_COLUMN, &monitor, -1);
-	}
-
-	gsd_wacom_device_set_display (self->priv->device, monitor);
-
-	if (monitor >= 0) {
-		GsdWacomRotation rotation;
-		GSettings *settings;
-
-		rotation = gsd_wacom_device_get_display_rotation (self->priv->device);
-		settings = gsd_wacom_device_get_settings (self->priv->device);
-		g_settings_set_string (settings,
-				       "rotation",
-				       gsd_wacom_device_rotation_type_to_name (rotation));
-	}
-}
-
-void
-cc_wacom_mapping_panel_set_device (CcWacomMappingPanel *self,
-                                   GsdWacomDevice *device)
-{
-	self->priv->device = device;
-	update_ui (self);
-}
-
-static void
-checkbutton_toggled_cb (GtkWidget           *widget,
-			CcWacomMappingPanel *self)
-{
-	gboolean active;
-
-	active = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget));
-	set_combobox_sensitive (self, active);
-	if (!active)
-		gtk_switch_set_active (GTK_SWITCH(self->priv->aspectswitch), FALSE);
-	update_mapping (self);
-}
-
-static void
-aspectswitch_toggled_cb (GtkWidget           *widget,
-                         GParamSpec          *pspec,
-			 CcWacomMappingPanel *self)
-{
-	GSettings *settings;
-
-	settings = gsd_wacom_device_get_settings (self->priv->device);
-	g_settings_set_boolean (settings,
-				"keep-aspect",
-				gtk_switch_get_active (GTK_SWITCH (widget)));
-}
-
-static void
-combobox_changed_cb (GtkWidget           *widget,
-                     CcWacomMappingPanel *self)
-{
-	update_mapping (self);
-}
-
-static void
-cc_wacom_mapping_panel_init (CcWacomMappingPanel *self)
-{
-	CcWacomMappingPanelPrivate *priv;
-	GtkWidget *vbox, *grid;
-	GtkCellRenderer *renderer;
-
-	priv = self->priv = WACOM_MAPPING_PANEL_PRIVATE (self);
-
-	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);
-	gtk_container_add (GTK_CONTAINER (self), vbox);
-	gtk_container_set_border_width (GTK_CONTAINER (self), 12);
-	gtk_widget_set_vexpand (GTK_WIDGET (vbox), TRUE);
-	gtk_widget_set_hexpand (GTK_WIDGET (vbox), TRUE);
-
-	/* Output Combobox */
-	grid = gtk_grid_new();
-	gtk_grid_set_row_spacing (GTK_GRID (grid), 10);
-	gtk_grid_set_column_spacing (GTK_GRID (grid), 10);
-	priv->label = gtk_label_new (_("Output:"));
-	gtk_widget_set_halign (priv->label, GTK_ALIGN_END);
-	priv->combobox = gtk_combo_box_new ();
-	g_signal_connect (G_OBJECT (priv->combobox), "changed",
-	                      G_CALLBACK (combobox_changed_cb), self);
-	renderer = gtk_cell_renderer_text_new ();
-	gtk_cell_layout_pack_start (GTK_CELL_LAYOUT(priv->combobox), renderer, TRUE);
-	gtk_cell_layout_add_attribute (GTK_CELL_LAYOUT(priv->combobox), renderer, "text", 0);
-	gtk_grid_attach (GTK_GRID(grid), GTK_WIDGET(priv->label), 0, 0, 1, 1);
-	gtk_grid_attach (GTK_GRID(grid), GTK_WIDGET(priv->combobox), 1, 0, 1, 1);
-
-	/* Keep ratio switch */
-	priv->aspectlabel = gtk_label_new (_("Keep aspect ratio (letterbox):"));
-	gtk_widget_set_halign (priv->aspectlabel, GTK_ALIGN_END);
-	priv->aspectswitch = gtk_switch_new ();
-	gtk_widget_set_halign (priv->aspectswitch, GTK_ALIGN_START);
-	gtk_switch_set_active (GTK_SWITCH (priv->aspectswitch), FALSE);
-	g_signal_connect (GTK_SWITCH (priv->aspectswitch), "notify::active",
-                      G_CALLBACK (aspectswitch_toggled_cb), self);
-	gtk_grid_attach (GTK_GRID(grid), GTK_WIDGET(priv->aspectlabel), 0, 1, 1, 1);
-	gtk_grid_attach (GTK_GRID(grid), GTK_WIDGET(priv->aspectswitch), 1, 1, 1, 1);
-
-	/* Whole-desktop checkbox */
-	priv->checkbutton = gtk_check_button_new_with_label (_("Map to single monitor"));
-	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (priv->checkbutton), FALSE);
-	g_signal_connect (G_OBJECT (priv->checkbutton), "toggled",
-                      G_CALLBACK (checkbutton_toggled_cb), self);
-
-	gtk_box_pack_start (GTK_BOX(vbox), GTK_WIDGET(priv->checkbutton),
-				FALSE, FALSE, 0);
-	gtk_box_pack_start (GTK_BOX(vbox), GTK_WIDGET(grid),
-				FALSE, FALSE, 8);
-
-	/* Update display */
-	cc_wacom_mapping_panel_set_device (self, NULL);
-	gtk_widget_show_all(GTK_WIDGET(self));
-}
-
-GtkWidget *
-cc_wacom_mapping_panel_new (void)
-{
-	CcWacomMappingPanel *panel;
-
-	panel = CC_WACOM_MAPPING_PANEL(g_object_new (CC_TYPE_WACOM_MAPPING_PANEL, NULL));
-	panel->priv->device = NULL;
-
-	return GTK_WIDGET(panel);
-}
-
-static void
-cc_wacom_mapping_panel_get_property (GObject    *object,
-                                     guint       property_id,
-                                     GValue     *value,
-                                     GParamSpec *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_mapping_panel_set_property (GObject      *object,
-                                     guint         property_id,
-                                     const GValue *value,
-                                     GParamSpec   *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_mapping_panel_dispose (GObject *object)
-{
-	G_OBJECT_CLASS (cc_wacom_mapping_panel_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_mapping_panel_class_init (CcWacomMappingPanelClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomMappingPanelPrivate));
-
-	object_class->get_property = cc_wacom_mapping_panel_get_property;
-	object_class->set_property = cc_wacom_mapping_panel_set_property;
-	object_class->dispose = cc_wacom_mapping_panel_dispose;
-}
diff --git a/panels/wacom/cc-wacom-mapping-panel.h b/panels/wacom/cc-wacom-mapping-panel.h
deleted file mode 100644
index f49994d..0000000
--- a/panels/wacom/cc-wacom-mapping-panel.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright  2012 Wacom.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Jason Gerecke <killertofu@gmail.com>
- *
- */
-
-#ifndef CC_WACOM_MAPPING_PANEL_H_
-#define CC_WACOM_MAPPING_PANEL_H_
-
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_MAPPING_PANEL cc_wacom_mapping_panel_get_type()
-
-#define CC_WACOM_MAPPING_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_MAPPING_PANEL, CcWacomMappingPanel))
-
-#define CC_WACOM_MAPPING_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_MAPPING_PANEL, CcWacomMappignPanelClass))
-
-#define CC_IS_WACOM_MAPPING_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_MAPPING_PANEL))
-
-#define CC_IS_WACOM_MAPPING_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_MAPPING_PANEL))
-
-#define CC_WACOM_MAPPING_PANEL_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_MAPPING_PANEL, CcWacomMappingPanelClass))
-
-typedef struct _CcWacomMappingPanel CcWacomMappingPanel;
-typedef struct _CcWacomMappingPanelClass CcWacomMappingPanelClass;
-typedef struct _CcWacomMappingPanelPrivate CcWacomMappingPanelPrivate;
-
-struct _CcWacomMappingPanel
-{
-  GtkBox parent;
-
-  CcWacomMappingPanelPrivate *priv;
-};
-
-struct _CcWacomMappingPanelClass
-{
-  GtkBoxClass parent_class;
-};
-
-GType cc_wacom_mapping_panel_get_type (void) G_GNUC_CONST;
-
-GtkWidget * cc_wacom_mapping_panel_new (void);
-
-
-void cc_wacom_mapping_panel_set_device (CcWacomMappingPanel *self,
-                                        GsdWacomDevice *device);
-
-G_END_DECLS
-
-#endif /* CC_WACOM_MAPPING_PANEL_H_ */
diff --git a/panels/wacom/cc-wacom-nav-button.c b/panels/wacom/cc-wacom-nav-button.c
deleted file mode 100644
index 3c48e35..0000000
--- a/panels/wacom/cc-wacom-nav-button.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * Copyright  2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include <config.h>
-
-#include <glib/gi18n.h>
-#include <gtk/gtk.h>
-
-#include "cc-wacom-nav-button.h"
-
-G_DEFINE_TYPE (CcWacomNavButton, cc_wacom_nav_button, GTK_TYPE_BOX)
-
-#define WACOM_NAV_BUTTON_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_NAV_BUTTON, CcWacomNavButtonPrivate))
-
-struct _CcWacomNavButtonPrivate
-{
-	GtkNotebook *notebook;
-	GtkWidget   *label;
-	GtkWidget   *prev;
-	GtkWidget   *next;
-	guint        page_added_id;
-	guint        page_removed_id;
-	guint        page_switched_id;
-	gboolean     ignore_first_page;
-};
-
-enum {
-	PROP_0,
-	PROP_NOTEBOOK,
-	PROP_IGNORE_FIRST
-};
-
-static void
-cc_wacom_nav_button_update (CcWacomNavButton *nav)
-{
-	CcWacomNavButtonPrivate *priv = nav->priv;
-	int num_pages;
-	int current_page;
-	char *text;
-
-	if (priv->notebook == NULL) {
-		gtk_widget_hide (GTK_WIDGET (nav));
-		return;
-	}
-
-	num_pages = gtk_notebook_get_n_pages (GTK_NOTEBOOK (priv->notebook));
-	if (num_pages == 0)
-		return;
-	if (priv->ignore_first_page && num_pages == 1)
-		return;
-
-	if (priv->ignore_first_page)
-		num_pages--;
-
-	g_assert (num_pages >= 1);
-
-	if (num_pages == 1)
-		gtk_widget_hide (GTK_WIDGET (nav));
-	else
-		gtk_widget_show (GTK_WIDGET (nav));
-
-	current_page = gtk_notebook_get_current_page (GTK_NOTEBOOK (priv->notebook));
-	if (current_page < 0)
-		return;
-	if (priv->ignore_first_page)
-		current_page--;
-	gtk_widget_set_sensitive (priv->prev, current_page == 0 ? FALSE : TRUE);
-	gtk_widget_set_sensitive (priv->next, current_page + 1 == num_pages ? FALSE : TRUE);
-
-	text = g_strdup_printf (_("%d of %d"),
-				current_page + 1,
-				num_pages);
-	gtk_label_set_text (GTK_LABEL (priv->label), text);
-}
-
-static void
-pages_changed (GtkNotebook      *notebook,
-	       GtkWidget        *child,
-	       guint             page_num,
-	       CcWacomNavButton *nav)
-{
-	cc_wacom_nav_button_update (nav);
-}
-
-static void
-page_switched (GtkNotebook      *notebook,
-	       GParamSpec       *pspec,
-	       CcWacomNavButton *nav)
-{
-	cc_wacom_nav_button_update (nav);
-}
-
-static void
-next_clicked (GtkButton        *button,
-	      CcWacomNavButton *nav)
-{
-	int current_page;
-
-	current_page = gtk_notebook_get_current_page (GTK_NOTEBOOK (nav->priv->notebook));
-	current_page++;
-	gtk_notebook_set_current_page (GTK_NOTEBOOK (nav->priv->notebook), current_page);
-}
-
-static void
-prev_clicked (GtkButton        *button,
-	      CcWacomNavButton *nav)
-{
-	int current_page;
-
-	current_page = gtk_notebook_get_current_page (GTK_NOTEBOOK (nav->priv->notebook));
-	current_page--;
-	gtk_notebook_set_current_page (GTK_NOTEBOOK (nav->priv->notebook), current_page--);
-}
-
-static void
-cc_wacom_nav_button_set_property (GObject      *object,
-				  guint         property_id,
-				  const GValue *value,
-				  GParamSpec   *pspec)
-{
-	CcWacomNavButton *nav = CC_WACOM_NAV_BUTTON (object);
-	CcWacomNavButtonPrivate *priv = nav->priv;
-
-	switch (property_id) {
-	case PROP_NOTEBOOK:
-		if (priv->notebook) {
-			g_signal_handler_disconnect (priv->notebook, priv->page_added_id);
-			g_signal_handler_disconnect (priv->notebook, priv->page_removed_id);
-			g_signal_handler_disconnect (priv->notebook, priv->page_switched_id);
-			g_object_unref (priv->notebook);
-		}
-		priv->notebook = g_value_dup_object (value);
-		priv->page_added_id = g_signal_connect (G_OBJECT (priv->notebook), "page-added",
-							G_CALLBACK (pages_changed), nav);
-		priv->page_removed_id = g_signal_connect (G_OBJECT (priv->notebook), "page-removed",
-							  G_CALLBACK (pages_changed), nav);
-		priv->page_switched_id = g_signal_connect (G_OBJECT (priv->notebook), "notify::page",
-							   G_CALLBACK (page_switched), nav);
-		cc_wacom_nav_button_update (nav);
-		break;
-	case PROP_IGNORE_FIRST:
-		priv->ignore_first_page = g_value_get_boolean (value);
-		cc_wacom_nav_button_update (nav);
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_nav_button_dispose (GObject *object)
-{
-	CcWacomNavButtonPrivate *priv = CC_WACOM_NAV_BUTTON (object)->priv;
-
-	if (priv->notebook) {
-		g_signal_handler_disconnect (priv->notebook, priv->page_added_id);
-		priv->page_added_id = 0;
-		g_signal_handler_disconnect (priv->notebook, priv->page_removed_id);
-		priv->page_removed_id = 0;
-		g_signal_handler_disconnect (priv->notebook, priv->page_switched_id);
-		priv->page_switched_id = 0;
-		g_object_unref (priv->notebook);
-		priv->notebook = NULL;
-	}
-
-	G_OBJECT_CLASS (cc_wacom_nav_button_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_nav_button_class_init (CcWacomNavButtonClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomNavButtonPrivate));
-
-	object_class->set_property = cc_wacom_nav_button_set_property;
-	object_class->dispose = cc_wacom_nav_button_dispose;
-
-	g_object_class_install_property (object_class, PROP_NOTEBOOK,
-					 g_param_spec_object ("notebook", "notebook", "notebook",
-							      GTK_TYPE_NOTEBOOK,
-							      G_PARAM_WRITABLE));
-	g_object_class_install_property (object_class, PROP_IGNORE_FIRST,
-					 g_param_spec_boolean ("ignore-first", "ignore-first", "ignore-first",
-							       FALSE,
-							       G_PARAM_WRITABLE));
-}
-
-static void
-cc_wacom_nav_button_init (CcWacomNavButton *self)
-{
-	CcWacomNavButtonPrivate *priv;
-	GtkStyleContext *context;
-	GtkWidget *image, *box;
-	gboolean rtl;
-
-	rtl = (gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL);
-
-	priv = self->priv = WACOM_NAV_BUTTON_PRIVATE (self);
-
-	/* Label */
-	priv->label = gtk_label_new (NULL);
-	gtk_style_context_add_class (gtk_widget_get_style_context (priv->label), "dim-label-ucc");
-	gtk_box_pack_start (GTK_BOX (self), priv->label,
-			    FALSE, FALSE, 8);
-
-	box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
-	context = gtk_widget_get_style_context (GTK_WIDGET (box));
-	gtk_style_context_add_class (context, GTK_STYLE_CLASS_LINKED);
-	gtk_box_pack_start (GTK_BOX (self), box,
-			    FALSE, FALSE, 0);
-
-	/* Prev button */
-	priv->prev = gtk_button_new ();
-	image = gtk_image_new_from_icon_name (rtl ? "go-previous-rtl-symbolic" : "go-previous-symbolic",
-					      GTK_ICON_SIZE_MENU);
-	gtk_container_add (GTK_CONTAINER (priv->prev), image);
-	g_signal_connect (G_OBJECT (priv->prev), "clicked",
-			  G_CALLBACK (prev_clicked), self);
-	gtk_widget_set_valign (priv->prev, GTK_ALIGN_CENTER);
-
-	/* Next button */
-	priv->next = gtk_button_new ();
-	image = gtk_image_new_from_icon_name (rtl ? "go-next-rtl-symbolic" : "go-next-symbolic",
-					      GTK_ICON_SIZE_MENU);
-	gtk_container_add (GTK_CONTAINER (priv->next), image);
-	g_signal_connect (G_OBJECT (priv->next), "clicked",
-			  G_CALLBACK (next_clicked), self);
-	gtk_widget_set_valign (priv->next, GTK_ALIGN_CENTER);
-
-	gtk_box_pack_start (GTK_BOX (box), priv->prev,
-			    FALSE, FALSE, 0);
-	gtk_box_pack_start (GTK_BOX (box), priv->next,
-			    FALSE, FALSE, 0);
-
-	gtk_widget_show (priv->label);
-	gtk_widget_show_all (box);
-}
-
-GtkWidget *
-cc_wacom_nav_button_new (void)
-{
-	return GTK_WIDGET (g_object_new (CC_TYPE_WACOM_NAV_BUTTON, NULL));
-}
diff --git a/panels/wacom/cc-wacom-nav-button.h b/panels/wacom/cc-wacom-nav-button.h
deleted file mode 100644
index bc58b01..0000000
--- a/panels/wacom/cc-wacom-nav-button.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright  2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Bastien Nocera <hadess@hadess.net>
- */
-
-
-#ifndef _CC_WACOM_NAV_BUTTON_H
-#define _CC_WACOM_NAV_BUTTON_H
-
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_NAV_BUTTON cc_wacom_nav_button_get_type()
-
-#define CC_WACOM_NAV_BUTTON(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_NAV_BUTTON, CcWacomNavButton))
-
-#define CC_WACOM_NAV_BUTTON_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_NAV_BUTTON, CcWacomNavButtonClass))
-
-#define CC_IS_WACOM_NAV_BUTTON(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_NAV_BUTTON))
-
-#define CC_IS_WACOM_NAV_BUTTON_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_NAV_BUTTON))
-
-#define CC_WACOM_NAV_BUTTON_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_NAV_BUTTON, CcWacomNavButtonClass))
-
-typedef struct _CcWacomNavButton CcWacomNavButton;
-typedef struct _CcWacomNavButtonClass CcWacomNavButtonClass;
-typedef struct _CcWacomNavButtonPrivate CcWacomNavButtonPrivate;
-
-struct _CcWacomNavButton
-{
-  GtkBox parent;
-
-  CcWacomNavButtonPrivate *priv;
-};
-
-struct _CcWacomNavButtonClass
-{
-  GtkBoxClass parent_class;
-};
-
-GType cc_wacom_nav_button_get_type (void) G_GNUC_CONST;
-
-GtkWidget * cc_wacom_nav_button_new (void);
-
-G_END_DECLS
-
-#endif /* _CC_WACOM_NAV_BUTTON_H */
diff --git a/panels/wacom/cc-wacom-page.c b/panels/wacom/cc-wacom-page.c
deleted file mode 100644
index 77d479b..0000000
--- a/panels/wacom/cc-wacom-page.c
+++ /dev/null
@@ -1,1411 +0,0 @@
-/*
- * Copyright  2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include <config.h>
-
-#include <glib/gi18n-lib.h>
-#include <gtk/gtk.h>
-
-#include "cc-wacom-page.h"
-#include "cc-wacom-nav-button.h"
-#include "cc-wacom-mapping-panel.h"
-#include "cc-wacom-stylus-page.h"
-#include "gsd-enums.h"
-#include "gui_gtk.h"
-
-#include <string.h>
-
-#define WID(x) (GtkWidget *) gtk_builder_get_object (priv->builder, x)
-#define CWID(x) (GtkContainer *) gtk_builder_get_object (priv->builder, x)
-#define MWID(x) (GtkWidget *) gtk_builder_get_object (priv->mapping_builder, x)
-
-G_DEFINE_TYPE (CcWacomPage, cc_wacom_page, GTK_TYPE_BOX)
-
-#define WACOM_PAGE_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_PAGE, CcWacomPagePrivate))
-
-#define THRESHOLD_MISCLICK	15
-#define THRESHOLD_DOUBLECLICK	7
-
-#define ACTION_TYPE_KEY         "action-type"
-#define CUSTOM_ACTION_KEY       "custom-action"
-#define KEY_CUSTOM_ELEVATOR_ACTION "custom-elevator-action"
-
-enum {
-	MAPPING_DESCRIPTION_COLUMN,
-	MAPPING_TYPE_COLUMN,
-	MAPPING_BUTTON_COLUMN,
-	MAPPING_BUTTON_DIRECTION,
-	MAPPING_N_COLUMNS
-};
-
-enum {
-	ACTION_NAME_COLUMN,
-	ACTION_TYPE_COLUMN,
-	ACTION_N_COLUMNS
-};
-
-struct _CcWacomPagePrivate
-{
-	CcWacomPanel   *panel;
-	GsdWacomDevice *stylus, *eraser, *pad;
-	GtkBuilder     *builder;
-	GtkWidget      *nav;
-	GtkWidget      *notebook;
-	CalibArea      *area;
-	GSettings      *wacom_settings;
-
-	/* Button mapping */
-	GtkBuilder     *mapping_builder;
-	GtkWidget      *button_map;
-	GtkListStore   *action_store;
-
-	/* Display mapping */
-	GtkWidget      *mapping;
-	GtkWidget      *dialog;
-};
-
-/* Button combo box storage columns */
-enum {
-	BUTTONNUMBER_COLUMN,
-	BUTTONNAME_COLUMN,
-	N_BUTTONCOLUMNS
-};
-
-/* Tablet mode combo box storage columns */
-enum {
-	MODENUMBER_COLUMN,
-	MODELABEL_COLUMN,
-	N_MODECOLUMNS
-};
-
-/* Tablet mode options - keep in sync with .ui */
-enum {
-	MODE_ABSOLUTE, /* stylus + eraser absolute */
-	MODE_RELATIVE, /* stylus + eraser relative */
-};
-
-/* Different types of layout for the tablet config */
-enum {
-	LAYOUT_NORMAL,        /* tracking mode, button mapping */
-	LAYOUT_REVERSIBLE,    /* tracking mode, button mapping, left-hand orientation */
-	LAYOUT_SCREEN        /* button mapping, calibration, display resolution */
-};
-
-static struct {
-       GsdWacomActionType  action_type;
-       const gchar        *action_name;
-} action_table[] = {
-       { GSD_WACOM_ACTION_TYPE_NONE,           NC_("Wacom action-type", "None")                },
-       { GSD_WACOM_ACTION_TYPE_CUSTOM,         NC_("Wacom action-type", "Send Keystroke")      },
-       { GSD_WACOM_ACTION_TYPE_SWITCH_MONITOR, NC_("Wacom action-type", "Switch Monitor")      },
-       { GSD_WACOM_ACTION_TYPE_HELP,           NC_("Wacom action-type", "Show On-Screen Help") }
-};
-
-#define WACOM_C(x) g_dpgettext2(NULL, "Wacom action-type", x)
-
-static void
-update_tablet_ui (CcWacomPage *page,
-		  int          layout);
-
-static int
-get_layout_type (GsdWacomDevice *device)
-{
-	int layout;
-
-	if (gsd_wacom_device_is_screen_tablet (device))
-		layout = LAYOUT_SCREEN;
-	else if (gsd_wacom_device_reversible (device))
-		layout = LAYOUT_REVERSIBLE;
-	else
-		layout = LAYOUT_NORMAL;
-
-	return layout;
-}
-
-static void
-set_calibration (gint      *cal,
-                 gsize      ncal,
-                 GSettings *settings)
-{
-	GVariant    *current; /* current calibration */
-	GVariant    *array;   /* new calibration */
-	GVariant   **tmp;
-	gsize        nvalues;
-	int          i;
-
-	current = g_settings_get_value (settings, "area");
-	g_variant_get_fixed_array (current, &nvalues, sizeof (gint32));
-	if ((ncal != 4) || (nvalues != 4)) {
-		g_warning("Unable set set device calibration property. Got %"G_GSIZE_FORMAT" items to put in %"G_GSIZE_FORMAT" slots; expected %d items.\n", ncal, nvalues, 4);
-		return;
-	}
-
-	tmp = g_malloc (nvalues * sizeof (GVariant*));
-	for (i = 0; i < ncal; i++)
-		tmp[i] = g_variant_new_int32 (cal[i]);
-
-	array = g_variant_new_array (G_VARIANT_TYPE_INT32, tmp, nvalues);
-	g_settings_set_value (settings, "area", array);
-
-	g_free (tmp);
-}
-
-static void
-finish_calibration (CalibArea *area,
-		    gpointer   user_data)
-{
-	CcWacomPage *page = (CcWacomPage *) user_data;
-	CcWacomPagePrivate *priv = page->priv;
-	XYinfo axis;
-	gboolean swap_xy;
-	int cal[4];
-
-	if (calib_area_finish (area, &axis, &swap_xy)) {
-		cal[0] = axis.x_min;
-		cal[1] = axis.y_min;
-		cal[2] = axis.x_max;
-		cal[3] = axis.y_max;
-
-		set_calibration(cal, 4, priv->wacom_settings);
-	}
-
-	calib_area_free (area);
-	priv->area = NULL;
-	gtk_widget_set_sensitive (WID ("button-calibrate"), TRUE);
-}
-
-static gboolean
-run_calibration (CcWacomPage *page,
-		 gint        *cal,
-		 gint         monitor)
-{
-	XYinfo              old_axis;
-	GdkDevice          *gdk_device;
-	CcWacomPagePrivate *priv;
-	int                 device_id;
-
-	g_assert (page->priv->area == NULL);
-
-	old_axis.x_min = cal[0];
-	old_axis.y_min = cal[1];
-	old_axis.x_max = cal[2];
-	old_axis.y_max = cal[3];
-
-	priv = page->priv;
-	g_object_get (priv->stylus, "gdk-device", &gdk_device, NULL);
-
-	if (gdk_device != NULL)
-		g_object_get (gdk_device, "device-id", &device_id, NULL);
-	else
-		device_id = -1;
-
-	priv->area = calib_area_new (NULL,
-				     monitor,
-				     device_id,
-				     finish_calibration,
-				     page,
-				     &old_axis,
-				     THRESHOLD_MISCLICK,
-				     THRESHOLD_DOUBLECLICK);
-
-	return FALSE;
-}
-
-static void
-calibrate_button_clicked_cb (GtkButton   *button,
-			     CcWacomPage *page)
-{
-	int i, calibration[4];
-	GVariant *variant;
-	int *current;
-	gsize ncal;
-	gint monitor;
-
-	monitor = gsd_wacom_device_get_display_monitor (page->priv->stylus);
-	if (monitor < 0) {
-		/* The display the tablet should be mapped to could not be located.
-		 * This shouldn't happen if the EDID data is good...
-		 */
-		g_critical("Output associated with the tablet is not connected. Unable to calibrate.");
-		return;
-	}
-
-	variant = g_settings_get_value (page->priv->wacom_settings, "area");
-	current = (int *) g_variant_get_fixed_array (variant, &ncal, sizeof (gint32));
-
-	if (ncal != 4) {
-		g_warning("Device calibration property has wrong length. Got %"G_GSIZE_FORMAT" items; expected %d.\n", ncal, 4);
-		g_free (current);
-		return;
-	}
-
-	for (i = 0; i < 4; i++)
-		calibration[i] = current[i];
-
-	if (calibration[0] == -1 &&
-	    calibration[1] == -1 &&
-	    calibration[2] == -1 &&
-	    calibration[3] == -1) {
-		gint *device_cal;
-		device_cal = gsd_wacom_device_get_area (page->priv->stylus);
-		for (i = 0; i < 4; i++)
-			calibration[i] = device_cal[i];
-		g_free (device_cal);
-	}
-
-	run_calibration (page, calibration, monitor);
-	gtk_widget_set_sensitive (GTK_WIDGET (button), FALSE);
-}
-
-/* This avoids us crashing when a newer version of
- * gnome-control-center has been used, and we load up an
- * old one, as the action type if unknown to the old g-c-c */
-static gboolean
-action_type_is_valid (GsdWacomActionType type)
-{
-	if (type >= G_N_ELEMENTS(action_table))
-		return FALSE;
-	return TRUE;
-}
-
-static char *
-get_elevator_shortcut_string (GSettings        *settings,
-			      GtkDirectionType  dir)
-{
-	char **strv, *str;
-
-	strv = g_settings_get_strv (settings, KEY_CUSTOM_ELEVATOR_ACTION);
-	if (strv == NULL)
-		return NULL;
-
-	if (g_strv_length (strv) >= 1 && dir == GTK_DIR_UP)
-		str = g_strdup (strv[0]);
-	else if (g_strv_length (strv) >= 2 && dir == GTK_DIR_DOWN)
-		str = g_strdup (strv[1]);
-	else
-		str = NULL;
-
-	g_strfreev (strv);
-
-	return str;
-}
-
-static void
-accel_set_func (GtkTreeViewColumn *tree_column,
-		GtkCellRenderer   *cell,
-		GtkTreeModel      *model,
-		GtkTreeIter       *iter,
-		gpointer           data)
-{
-	GsdWacomTabletButton *button;
-	GsdWacomActionType type;
-	GtkDirectionType dir;
-	char *str;
-	guint keyval;
-	guint mask;
-
-	gtk_tree_model_get (model, iter,
-			    MAPPING_BUTTON_COLUMN, &button,
-			    MAPPING_BUTTON_DIRECTION, &dir,
-			    -1);
-
-	if (button == NULL) {
-		g_object_set (cell,
-			      "visible", FALSE,
-			      NULL);
-		return;
-	}
-
-	if (button->type == WACOM_TABLET_BUTTON_TYPE_HARDCODED) {
-		/* FIXME this should list the name of the button,
-		 * Switch Modes Touchring #1 for example */
-		g_object_set (cell,
-			      "visible", TRUE,
-			      "editable", FALSE,
-			      "accel-key", 0,
-			      "accel-mods", 0,
-			      "style", PANGO_STYLE_NORMAL,
-			      "text", "",
-			      NULL);
-		return;
-	}
-
-	if (button->settings == NULL) {
-		g_warning ("Button '%s' does not have an associated GSettings", button->id);
-		return;
-	}
-
-	type = g_settings_get_enum (button->settings, ACTION_TYPE_KEY);
-	if (type != GSD_WACOM_ACTION_TYPE_CUSTOM) {
-		g_object_set (cell,
-			      "visible", TRUE,
-			      "editable", TRUE,
-			      "accel-key", 0,
-			      "accel-mods", 0,
-			      "style", PANGO_STYLE_NORMAL,
-			      "text", "",
-			      NULL);
-		return;
-	}
-
-	if (button->type == WACOM_TABLET_BUTTON_TYPE_STRIP ||
-	    button->type == WACOM_TABLET_BUTTON_TYPE_RING)
-		str = get_elevator_shortcut_string (button->settings, dir);
-	else
-		str = g_settings_get_string (button->settings, CUSTOM_ACTION_KEY);
-
-	if (str == NULL || *str == '\0') {
-		g_object_set (cell,
-			      "visible", TRUE,
-			      "editable", TRUE,
-			      "accel-key", 0,
-			      "accel-mods", 0,
-			      "style", PANGO_STYLE_NORMAL,
-			      "text", C_("Wacom action-type", "None"),
-			      NULL);
-		g_free (str);
-		return;
-	}
-	gtk_accelerator_parse (str, &keyval, &mask);
-	g_free (str);
-
-	g_object_set (cell,
-		      "visible", TRUE,
-		      "editable", TRUE,
-		      "accel-key", keyval,
-		      "accel-mods", mask,
-		      "style", PANGO_STYLE_NORMAL,
-		      NULL);
-}
-
-static gboolean
-start_editing_cb (GtkTreeView    *tree_view,
-		  GdkEventButton *event,
-		  gpointer        user_data)
-{
-	GtkTreePath *path;
-	GtkTreeViewColumn *column;
-	gboolean handled;
-
-	if (event->window != gtk_tree_view_get_bin_window (tree_view))
-		return FALSE;
-
-	handled = FALSE;
-	if (gtk_tree_view_get_path_at_pos (tree_view,
-					   (gint) event->x,
-					   (gint) event->y,
-					   &path, &column,
-					   NULL, NULL))
-	{
-		GtkTreeModel *model;
-		GtkTreeIter iter;
-		GsdWacomTabletButton *button;
-		GsdWacomActionType type;
-
-		if (column == gtk_tree_view_get_column (tree_view, MAPPING_TYPE_COLUMN))
-			goto out;
-
-		model = gtk_tree_view_get_model (tree_view);
-		gtk_tree_model_get_iter (model, &iter, path);
-		gtk_tree_model_get (model, &iter,
-				    MAPPING_BUTTON_COLUMN, &button,
-				    -1);
-		if (button == NULL)
-			goto out;
-
-		if (button->settings == NULL)
-			goto out;
-
-		type = g_settings_get_enum (button->settings, ACTION_TYPE_KEY);
-		if (type != GSD_WACOM_ACTION_TYPE_CUSTOM)
-			goto out;
-
-		gtk_widget_grab_focus (GTK_WIDGET (tree_view));
-		gtk_tree_view_set_cursor (tree_view,
-					  path,
-					  gtk_tree_view_get_column (tree_view, MAPPING_BUTTON_COLUMN),
-					  TRUE);
-		g_signal_stop_emission_by_name (tree_view, "button_press_event");
-		handled = TRUE;
-out:
-		gtk_tree_path_free (path);
-	}
-	return handled;
-}
-
-static void
-start_editing_kb_cb (GtkTreeView *treeview,
-                          GtkTreePath *path,
-                          GtkTreeViewColumn *column,
-                          gpointer user_data)
-{
-  GtkTreeModel *model;
-  GtkTreeIter iter;
-  GsdWacomTabletButton *button;
-
-  model = gtk_tree_view_get_model (treeview);
-  gtk_tree_model_get_iter (model, &iter, path);
-  gtk_tree_model_get (model, &iter,
-                      MAPPING_BUTTON_COLUMN, &button,
-                      -1);
-
-  gtk_widget_grab_focus (GTK_WIDGET (treeview));
-  gtk_tree_view_set_cursor (treeview,
-			    path,
-			    gtk_tree_view_get_column (treeview, MAPPING_BUTTON_COLUMN),
-			    TRUE);
-}
-
-static void
-accel_edited_callback (GtkCellRendererText   *cell,
-                       const char            *path_string,
-                       guint                  keyval,
-                       GdkModifierType        mask,
-                       guint                  keycode,
-                       CcWacomPage           *page)
-{
-  GtkTreeModel *model;
-  GtkTreePath *path = gtk_tree_path_new_from_string (path_string);
-  GtkTreeView *view;
-  GtkTreeIter iter;
-  CcWacomPagePrivate *priv;
-  GsdWacomTabletButton *button;
-  GtkDirectionType dir;
-  char *str;
-
-  priv = page->priv;
-  view = GTK_TREE_VIEW (MWID("shortcut_treeview"));
-  model = gtk_tree_view_get_model (view);
-  gtk_tree_model_get_iter (model, &iter, path);
-  gtk_tree_path_free (path);
-  gtk_tree_model_get (model, &iter,
-		      MAPPING_BUTTON_COLUMN, &button,
-		      MAPPING_BUTTON_DIRECTION, &dir,
-                      -1);
-
-  /* sanity check */
-  if (button == NULL)
-    return;
-
-  /* CapsLock isn't supported as a keybinding modifier, so keep it from confusing us */
-  mask &= ~GDK_LOCK_MASK;
-
-  str = gtk_accelerator_name (keyval, mask);
-
-  if (button->type == WACOM_TABLET_BUTTON_TYPE_STRIP ||
-      button->type == WACOM_TABLET_BUTTON_TYPE_RING) {
-    char *strs[3];
-    char **strv;
-
-    strs[2] = NULL;
-    strs[0] = strs[1] = "";
-    strv = g_settings_get_strv (button->settings, KEY_CUSTOM_ELEVATOR_ACTION);
-    if (strv != NULL) {
-	    if (g_strv_length (strv) >= 1)
-		    strs[0] = strv[0];
-	    if (g_strv_length (strv) >= 2)
-		    strs[1] = strv[1];
-    }
-
-    if (dir == GTK_DIR_UP)
-	    strs[0] = str;
-    else
-	    strs[1] = str;
-
-    g_settings_set_strv (button->settings, KEY_CUSTOM_ELEVATOR_ACTION, (const gchar * const*) strs);
-    if (strv != NULL)
-	    g_strfreev (strv);
-  } else {
-    g_settings_set_string (button->settings, CUSTOM_ACTION_KEY, str);
-  }
-  g_settings_set_enum (button->settings, ACTION_TYPE_KEY, GSD_WACOM_ACTION_TYPE_CUSTOM);
-  g_free (str);
-}
-
-static void
-accel_cleared_callback (GtkCellRendererText *cell,
-                        const char          *path_string,
-                        CcWacomPage         *page)
-{
-  GtkTreeView *view;
-  GtkTreePath *path = gtk_tree_path_new_from_string (path_string);
-  GtkTreeIter iter;
-  GtkTreeModel *model;
-  GsdWacomTabletButton *button;
-  CcWacomPagePrivate *priv;
-  GtkDirectionType dir;
-
-  priv = page->priv;
-  view = GTK_TREE_VIEW (MWID("shortcut_treeview"));
-  model = gtk_tree_view_get_model (view);
-  gtk_tree_model_get_iter (model, &iter, path);
-  gtk_tree_path_free (path);
-  gtk_tree_model_get (model, &iter,
-		      MAPPING_BUTTON_COLUMN, &button,
-		      MAPPING_BUTTON_DIRECTION, &dir,
-                      -1);
-
-  /* sanity check */
-  if (button == NULL)
-    return;
-
-  /* Unset the key */
-  if (button->type == WACOM_TABLET_BUTTON_TYPE_STRIP ||
-      button->type == WACOM_TABLET_BUTTON_TYPE_RING) {
-    char *strs[3];
-    char **strv;
-
-    strs[2] = NULL;
-    strs[0] = strs[1] = "";
-    strv = g_settings_get_strv (button->settings, KEY_CUSTOM_ELEVATOR_ACTION);
-    if (strv != NULL) {
-	    if (g_strv_length (strv) >= 1)
-		    strs[0] = strv[0];
-	    if (g_strv_length (strv) >= 2)
-		    strs[1] = strv[1];
-    }
-
-    if (dir == GTK_DIR_UP)
-	    strs[0] = "";
-    else
-	    strs[1] = "";
-
-    if (*strs[0] == '\0' && *strs[1] == '\0')
-	    g_settings_set_enum (button->settings, ACTION_TYPE_KEY, GSD_WACOM_ACTION_TYPE_NONE);
-    g_settings_set_strv (button->settings, KEY_CUSTOM_ELEVATOR_ACTION, (const gchar * const*) strs);
-    if (strv != NULL)
-	    g_strfreev (strv);
-  } else {
-	  g_settings_set_enum (button->settings, ACTION_TYPE_KEY, GSD_WACOM_ACTION_TYPE_NONE);
-	  g_settings_set_string (button->settings, CUSTOM_ACTION_KEY, "");
-  }
-}
-
-static void
-add_button_to_store (GtkListStore         *model,
-		     GsdWacomTabletButton *button,
-		     GtkDirectionType      dir,
-		     GsdWacomActionType    type)
-{
-	GtkTreeIter new_row;
-	char *dir_name;
-
-	if (dir == GTK_DIR_UP || dir == GTK_DIR_DOWN) {
-		if (button->type == WACOM_TABLET_BUTTON_TYPE_RING) {
-			dir_name = g_strdup_printf ("%s (%s)",
-						    button->name,
-						    dir == GTK_DIR_UP ? "" : "");
-		} else {
-			dir_name = g_strdup_printf ("%s (%s)",
-						    button->name,
-						    dir == GTK_DIR_UP ? C_("Wacom tablet button", "Up") : C_("Wacom tablet button", "Down"));
-		}
-	} else {
-		dir_name = NULL;
-	}
-
-	if (action_type_is_valid (type) == FALSE)
-		type = GSD_WACOM_ACTION_TYPE_NONE;
-
-	gtk_list_store_append (model, &new_row);
-	gtk_list_store_set (model, &new_row,
-			    MAPPING_DESCRIPTION_COLUMN, dir_name ? dir_name : button->name,
-			    MAPPING_TYPE_COLUMN, WACOM_C(action_table[type].action_name),
-			    MAPPING_BUTTON_COLUMN, button,
-			    MAPPING_BUTTON_DIRECTION, dir,
-			    -1);
-	g_free (dir_name);
-}
-
-static void
-action_set_func (GtkTreeViewColumn *tree_column,
-		 GtkCellRenderer   *cell,
-		 GtkTreeModel      *model,
-		 GtkTreeIter       *iter,
-		 gpointer           data)
-{
-	GsdWacomTabletButton *button;
-	GsdWacomActionType type;
-
-	gtk_tree_model_get (model, iter, MAPPING_BUTTON_COLUMN, &button, -1);
-
-	if (button == NULL) {
-		g_object_set (cell, "visible", FALSE, NULL);
-		return;
-	}
-
-	if (button->type == WACOM_TABLET_BUTTON_TYPE_HARDCODED) {
-		g_object_set (cell,
-			      "visible", TRUE,
-			      "editable", FALSE,
-			      "style", PANGO_STYLE_NORMAL,
-			      "text", _("Switch Modes"),
-			      NULL);
-		return;
-	}
-
-	if (button->type == WACOM_TABLET_BUTTON_TYPE_STRIP ||
-	    button->type == WACOM_TABLET_BUTTON_TYPE_RING) {
-		g_object_set (cell,
-			      "visible", TRUE,
-			      "editable", FALSE,
-			      "style", PANGO_STYLE_NORMAL,
-			      "text", WACOM_C(action_table[GSD_WACOM_ACTION_TYPE_CUSTOM].action_name),
-			      NULL);
-		return;
-	}
-
-	if (button->settings == NULL) {
-		g_warning ("Button '%s' does not have an associated GSettings", button->id);
-		return;
-	}
-
-	type = g_settings_get_enum (button->settings, ACTION_TYPE_KEY);
-	if (action_type_is_valid (type) == FALSE)
-		type = GSD_WACOM_ACTION_TYPE_NONE;
-
-	g_object_set (cell,
-		      "visible", TRUE,
-		      "editable", TRUE,
-		      "style", PANGO_STYLE_NORMAL,
-		      "text",  WACOM_C(action_table[type].action_name),
-		      NULL);
-}
-
-static void
-combo_action_cell_changed (GtkCellRendererCombo *cell,
-                           const gchar          *path_string,
-                           GtkTreeIter          *new_iter,
-                           CcWacomPage          *page)
-{
-	GtkTreeView          *tree_view;
-	GtkTreePath          *path;
-	GtkTreeModel         *model;
-	CcWacomPagePrivate   *priv;
-	GsdWacomActionType    type;
-	GtkTreeIter           iter;
-	GsdWacomTabletButton *button;
-
-	priv = page->priv;
-	tree_view = GTK_TREE_VIEW (MWID("shortcut_treeview"));
-	model = gtk_tree_view_get_model (tree_view);
-	path = gtk_tree_path_new_from_string (path_string);
-
-	gtk_tree_model_get (GTK_TREE_MODEL (priv->action_store), new_iter, ACTION_TYPE_COLUMN, &type, -1);
-	gtk_tree_model_get_iter (model, &iter, path);
-	gtk_list_store_set (GTK_LIST_STORE (model), &iter, MAPPING_TYPE_COLUMN, WACOM_C(action_table[type].action_name), -1);
-	gtk_tree_path_free (path);
-
-	gtk_tree_model_get (model, &iter, MAPPING_BUTTON_COLUMN, &button, -1);
-	if (button == NULL)
-		return;
-	if (button->settings == NULL)
-		return;
-	g_settings_set_enum (button->settings, ACTION_TYPE_KEY, type);
-
-	gtk_widget_grab_focus (GTK_WIDGET (tree_view));
-}
-
-static void
-setup_mapping_treeview (CcWacomPage *page)
-{
-	CcWacomPagePrivate *priv;
-	GtkTreeView *treeview;
-	GtkCellRenderer *renderer;
-	GtkTreeViewColumn *column;
-	GtkListStore *model;
-	GtkTreeIter iter;
-	GList *list, *l;
-	gint i;
-
-	priv = page->priv;
-	treeview = GTK_TREE_VIEW(MWID ("shortcut_treeview"));
-
-	g_signal_connect (treeview, "button_press_event",
-			  G_CALLBACK (start_editing_cb), page);
-	g_signal_connect (treeview, "row-activated",
-			  G_CALLBACK (start_editing_kb_cb), page);
-
-	renderer = gtk_cell_renderer_text_new ();
-	g_object_set (G_OBJECT (renderer), "ellipsize", PANGO_ELLIPSIZE_END, NULL);
-
-	column = gtk_tree_view_column_new_with_attributes (_("Button"),
-							   renderer,
-							   "text", MAPPING_DESCRIPTION_COLUMN,
-							   NULL);
-	gtk_tree_view_column_set_resizable (column, FALSE);
-	gtk_tree_view_column_set_expand (column, TRUE);
-
-	gtk_tree_view_append_column (treeview, column);
-	gtk_tree_view_column_set_sort_column_id (column, MAPPING_DESCRIPTION_COLUMN);
-
-	priv->action_store = gtk_list_store_new (ACTION_N_COLUMNS, G_TYPE_STRING, G_TYPE_INT);
-	for (i = 0; i < G_N_ELEMENTS (action_table); i++) {
-		/* Screen tablets cannot switch monitors (as the monitor is the tablet) */
-		if (action_table[i].action_type == GSD_WACOM_ACTION_TYPE_SWITCH_MONITOR &&
-		    gsd_wacom_device_is_screen_tablet (priv->stylus))
-			continue;
-
-		/* Do not list on-screen help if libwacom do no provide a layout */
-		if (action_table[i].action_type == GSD_WACOM_ACTION_TYPE_HELP &&
-		    gsd_wacom_device_get_layout_path (priv->stylus) == NULL)
-			continue;
-
-		gtk_list_store_append (priv->action_store, &iter);
-		gtk_list_store_set (priv->action_store, &iter,
-		                    ACTION_NAME_COLUMN, WACOM_C(action_table[i].action_name),
-		                    ACTION_TYPE_COLUMN, action_table[i].action_type, -1);
-	}
-	renderer = gtk_cell_renderer_combo_new ();
-	g_object_set (renderer,
-                      "text-column", ACTION_NAME_COLUMN,
-                      "has-entry", FALSE,
-                      "model", priv->action_store,
-                      "editable", TRUE,
-                      NULL);
-	g_signal_connect (renderer, "changed",
-	                  G_CALLBACK (combo_action_cell_changed), page);
-
-	column = gtk_tree_view_column_new_with_attributes (_("Type"),
-							   renderer,
-							   "text", MAPPING_TYPE_COLUMN,
-							   NULL);
-	gtk_tree_view_column_set_cell_data_func (column, renderer, action_set_func, NULL, NULL);
-	gtk_tree_view_column_set_resizable (column, FALSE);
-	gtk_tree_view_column_set_expand (column, FALSE);
-
-	gtk_tree_view_append_column (treeview, column);
-
-	renderer = (GtkCellRenderer *) g_object_new (GTK_TYPE_CELL_RENDERER_ACCEL,
-						     "accel-mode", GTK_CELL_RENDERER_ACCEL_MODE_OTHER,
-						     NULL);
-
-	g_signal_connect (renderer, "accel_edited",
-			  G_CALLBACK (accel_edited_callback),
-			  page);
-	g_signal_connect (renderer, "accel_cleared",
-			  G_CALLBACK (accel_cleared_callback),
-			  page);
-
-	column = gtk_tree_view_column_new_with_attributes (_("Action"), renderer, NULL);
-	gtk_tree_view_column_set_cell_data_func (column, renderer, accel_set_func, NULL, NULL);
-	gtk_tree_view_column_set_resizable (column, FALSE);
-	gtk_tree_view_column_set_expand (column, FALSE);
-
-	gtk_tree_view_append_column (treeview, column);
-
-	model = gtk_list_store_new (MAPPING_N_COLUMNS, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_POINTER, G_TYPE_INT);
-	gtk_tree_view_set_model (treeview, GTK_TREE_MODEL (model));
-
-	/* Fill it up! */
-	list = gsd_wacom_device_get_buttons (priv->pad);
-	for (l = list; l != NULL; l = l->next) {
-		GsdWacomTabletButton *button = l->data;
-		GsdWacomActionType type = GSD_WACOM_ACTION_TYPE_NONE;
-
-		if (button->settings)
-			type = g_settings_get_enum (button->settings, ACTION_TYPE_KEY);
-
-		if (button->type == WACOM_TABLET_BUTTON_TYPE_STRIP ||
-		    button->type == WACOM_TABLET_BUTTON_TYPE_RING) {
-			add_button_to_store (model, button, GTK_DIR_UP, GSD_WACOM_ACTION_TYPE_CUSTOM);
-			add_button_to_store (model, button, GTK_DIR_DOWN, GSD_WACOM_ACTION_TYPE_CUSTOM);
-		} else {
-			add_button_to_store (model, button, 0, type);
-		}
-	}
-	g_list_free (list);
-	g_object_unref (model);
-}
-
-static void
-button_mapping_dialog_closed (GtkDialog   *dialog,
-			      int          response_id,
-			      CcWacomPage *page)
-{
-	CcWacomPagePrivate *priv;
-
-	priv = page->priv;
-	gtk_widget_destroy (MWID ("button-mapping-dialog"));
-	g_object_unref (priv->mapping_builder);
-	priv->mapping_builder = NULL;
-}
-
-static void
-map_buttons_button_clicked_cb (GtkButton   *button,
-			       CcWacomPage *page)
-{
-	GError *error = NULL;
-	GtkWidget *dialog;
-	CcWacomPagePrivate *priv;
-	GtkWidget *toplevel;
-
-	priv = page->priv;
-
-	g_assert (priv->mapping_builder == NULL);
-	priv->mapping_builder = gtk_builder_new ();
-	gtk_builder_add_from_resource (priv->mapping_builder,
-                                       "/org/gnome/control-center/wacom/button-mapping.ui",
-                                       &error);
-
-	if (error != NULL) {
-		g_warning ("Error loading UI file: %s", error->message);
-		g_object_unref (priv->mapping_builder);
-		priv->mapping_builder = NULL;
-		g_error_free (error);
-		return;
-	}
-
-	setup_mapping_treeview (page);
-
-	dialog = MWID ("button-mapping-dialog");
-	toplevel = gtk_widget_get_toplevel (GTK_WIDGET (page));
-	gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (toplevel));
-	gtk_window_set_modal (GTK_WINDOW (dialog), TRUE);
-	g_signal_connect (G_OBJECT (dialog), "response",
-			  G_CALLBACK (button_mapping_dialog_closed), page);
-
-	gtk_widget_show (dialog);
-
-	priv->button_map = dialog;
-	g_object_add_weak_pointer (G_OBJECT (dialog), (gpointer *) &priv->button_map);
-}
-
-static void
-display_mapping_dialog_closed (GtkDialog   *dialog,
-			       int          response_id,
-			       CcWacomPage *page)
-{
-	CcWacomPagePrivate *priv;
-	int layout;
-
-	priv = page->priv;
-	gtk_widget_destroy (priv->dialog);
-	priv->dialog = NULL;
-	priv->mapping = NULL;
-	layout = get_layout_type (priv->stylus);
-	update_tablet_ui (page, layout);
-}
-
-static void
-display_mapping_button_clicked_cb (GtkButton   *button,
-				   CcWacomPage *page)
-{
-	CcWacomPagePrivate *priv;
-
-	priv = page->priv;
-
-	g_assert (priv->mapping == NULL);
-
-	priv->dialog = gtk_dialog_new_with_buttons (_("Display Mapping"),
-						    GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (page))),
-						    GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
-						    _("_Close"),
-						    GTK_RESPONSE_ACCEPT,
-						    NULL);
-	priv->mapping = cc_wacom_mapping_panel_new ();
-	cc_wacom_mapping_panel_set_device (CC_WACOM_MAPPING_PANEL (priv->mapping),
-					   priv->stylus);
-	gtk_container_add (GTK_CONTAINER (gtk_dialog_get_content_area (GTK_DIALOG (priv->dialog))),
-			   priv->mapping);
-	g_signal_connect (G_OBJECT (priv->dialog), "response",
-			  G_CALLBACK (display_mapping_dialog_closed), page);
-	gtk_widget_show_all (priv->dialog);
-
-	g_object_add_weak_pointer (G_OBJECT (priv->mapping), (gpointer *) &priv->dialog);
-}
-
-static void
-tabletmode_changed_cb (GtkComboBox *combo, gpointer user_data)
-{
-	CcWacomPagePrivate	*priv	= CC_WACOM_PAGE(user_data)->priv;
-	GtkListStore		*liststore;
-	GtkTreeIter		iter;
-	gint			mode;
-	gboolean		is_absolute;
-
-	if (!gtk_combo_box_get_active_iter (combo, &iter))
-		return;
-
-	liststore = GTK_LIST_STORE (WID ("liststore-tabletmode"));
-	gtk_tree_model_get (GTK_TREE_MODEL (liststore), &iter,
-			    MODENUMBER_COLUMN, &mode,
-			    -1);
-
-	is_absolute = (mode == MODE_ABSOLUTE);
-	g_settings_set_boolean (priv->wacom_settings, "is-absolute", is_absolute);
-}
-
-static const gchar*
-opposite_rotation (const gchar *rotation)
-{
-	/* Order matters here, if not found we return "none"  */
-	static const gchar *rotations[] = { "half", "cw", "none", "ccw" };
-	guint i, n;
-
-	n = G_N_ELEMENTS (rotations);
-	for (i = 0; i < n; i++) {
-		if (strcmp (rotation, rotations[i]) == 0)
-			break;
-	}
-
-	return rotations[(i + n / 2) % n];
-}
-
-static void
-left_handed_toggled_cb (GtkSwitch *sw, GParamSpec *pspec, gpointer *user_data)
-{
-	CcWacomPagePrivate	*priv = CC_WACOM_PAGE(user_data)->priv;
-	GsdWacomDevice          *device = priv->stylus;
-	GsdWacomRotation 	display_rotation;
-	const gchar*		rotation;
-
-	display_rotation = gsd_wacom_device_get_display_rotation (device);
-	rotation = gsd_wacom_device_rotation_type_to_name (display_rotation);
-	if (gtk_switch_get_active (sw))
-		rotation = opposite_rotation (rotation);
-
-	g_settings_set_string (priv->wacom_settings, "rotation", rotation);
-}
-
-static void
-set_left_handed_from_gsettings (CcWacomPage *page)
-{
-	CcWacomPagePrivate	*priv = CC_WACOM_PAGE(page)->priv;
-	GsdWacomDevice          *device = priv->stylus;
-	GsdWacomRotation 	display_rotation;
-	const gchar*		rotation;
-
-	display_rotation = gsd_wacom_device_get_display_rotation (device);
-	rotation = g_settings_get_string (priv->wacom_settings, "rotation");
-	if (strcmp (rotation, gsd_wacom_device_rotation_type_to_name (display_rotation)) != 0)
-		gtk_switch_set_active (GTK_SWITCH (WID ("switch-left-handed")), TRUE);
-}
-
-static void
-set_mode_from_gsettings (GtkComboBox *combo, CcWacomPage *page)
-{
-	CcWacomPagePrivate	*priv = page->priv;
-	gboolean		is_absolute;
-
-	is_absolute = g_settings_get_boolean (priv->wacom_settings, "is-absolute");
-
-	/* this must be kept in sync with the .ui file */
-	gtk_combo_box_set_active (combo, is_absolute ? MODE_ABSOLUTE : MODE_RELATIVE);
-}
-
-static void
-combobox_text_cellrenderer (GtkComboBox *combo, int name_column)
-{
-	GtkCellRenderer	*renderer;
-
-	renderer = gtk_cell_renderer_text_new ();
-	gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo), renderer, TRUE);
-	gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo), renderer,
-					"text", BUTTONNAME_COLUMN, NULL);
-}
-
-static gboolean
-display_clicked_cb (GtkButton   *button,
-		    CcWacomPage *page)
-{
-	cc_wacom_panel_switch_to_panel (page->priv->panel, "display");
-	return TRUE;
-}
-
-/* Boilerplate code goes below */
-
-static void
-cc_wacom_page_get_property (GObject    *object,
-                             guint       property_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_page_set_property (GObject      *object,
-                             guint         property_id,
-                             const GValue *value,
-                             GParamSpec   *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_page_dispose (GObject *object)
-{
-	CcWacomPagePrivate *priv = CC_WACOM_PAGE (object)->priv;
-
-	if (priv->area) {
-		calib_area_free (priv->area);
-		priv->area = NULL;
-	}
-
-	if (priv->button_map) {
-		gtk_widget_destroy (priv->button_map);
-		priv->button_map = NULL;
-	}
-
-	if (priv->dialog) {
-		gtk_widget_destroy (priv->dialog);
-		priv->dialog = NULL;
-	}
-
-	if (priv->builder) {
-		g_object_unref (priv->builder);
-		priv->builder = NULL;
-	}
-
-	priv->panel = NULL;
-
-	G_OBJECT_CLASS (cc_wacom_page_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_page_class_init (CcWacomPageClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomPagePrivate));
-
-	object_class->get_property = cc_wacom_page_get_property;
-	object_class->set_property = cc_wacom_page_set_property;
-	object_class->dispose = cc_wacom_page_dispose;
-}
-
-static void
-cc_wacom_page_init (CcWacomPage *self)
-{
-	CcWacomPagePrivate *priv;
-	GError *error = NULL;
-	GtkComboBox *combo;
-	GtkWidget *box;
-	GtkSwitch *sw;
-	char *objects[] = {
-		"main-grid",
-		"liststore-tabletmode",
-		"liststore-buttons",
-		"adjustment-tip-feel",
-		"adjustment-eraser-feel",
-		NULL
-	};
-
-	priv = self->priv = WACOM_PAGE_PRIVATE (self);
-
-	priv->builder = gtk_builder_new ();
-
-	gtk_builder_add_objects_from_resource (priv->builder,
-                                               "/org/gnome/control-center/wacom/gnome-wacom-properties.ui",
-                                               objects,
-                                               &error);
-	if (error != NULL) {
-		g_warning ("Error loading UI file: %s", error->message);
-		g_object_unref (priv->builder);
-		g_error_free (error);
-		return;
-	}
-
-	box = WID ("main-grid");
-	gtk_container_add (GTK_CONTAINER (self), box);
-	gtk_widget_set_vexpand (GTK_WIDGET (box), TRUE);
-
-	self->priv->notebook = WID ("stylus-notebook");
-
-	g_signal_connect (WID ("button-calibrate"), "clicked",
-			  G_CALLBACK (calibrate_button_clicked_cb), self);
-	g_signal_connect (WID ("map-buttons-button"), "clicked",
-			  G_CALLBACK (map_buttons_button_clicked_cb), self);
-
-	combo = GTK_COMBO_BOX (WID ("combo-tabletmode"));
-	combobox_text_cellrenderer (combo, MODELABEL_COLUMN);
-	g_signal_connect (G_OBJECT (combo), "changed",
-			  G_CALLBACK (tabletmode_changed_cb), self);
-
-	sw = GTK_SWITCH (WID ("switch-left-handed"));
-	g_signal_connect (G_OBJECT (sw), "notify::active",
-			  G_CALLBACK (left_handed_toggled_cb), self);
-
-	g_signal_connect (G_OBJECT (WID ("display-link")), "activate-link",
-			  G_CALLBACK (display_clicked_cb), self);
-
-	g_signal_connect (G_OBJECT (WID ("display-mapping-button")), "clicked",
-			  G_CALLBACK (display_mapping_button_clicked_cb), self);
-
-	priv->nav = cc_wacom_nav_button_new ();
-        gtk_widget_set_halign (priv->nav, GTK_ALIGN_END);
-        gtk_widget_set_margin_left (priv->nav, 10);
-	gtk_grid_attach (GTK_GRID (box), priv->nav, 1, 0, 1, 1);
-}
-
-static void
-set_icon_name (CcWacomPage *page,
-	       const char  *widget_name,
-	       const char  *icon_name)
-{
-	CcWacomPagePrivate *priv;
-	char *resource;
-
-	priv = page->priv;
-
-	resource = g_strdup_printf ("/org/gnome/control-center/wacom/%s.svg", icon_name);
-	gtk_image_set_from_resource (GTK_IMAGE (WID (widget_name)), resource);
-	g_free (resource);
-}
-
-typedef struct {
-	GsdWacomStylus *stylus;
-	GsdWacomStylus *eraser;
-} StylusPair;
-
-static void
-add_styli (CcWacomPage *page)
-{
-	GList *styli, *l;
-	CcWacomPagePrivate *priv;
-
-	priv = page->priv;
-
-	styli = gsd_wacom_device_list_styli (priv->stylus);
-
-	for (l = styli; l; l = l->next) {
-		GsdWacomStylus *stylus, *eraser;
-		GtkWidget *page;
-
-		stylus = l->data;
-
-		if (gsd_wacom_stylus_get_stylus_type (stylus) == WACOM_STYLUS_TYPE_PUCK)
-			continue;
-
-		if (gsd_wacom_stylus_get_has_eraser (stylus)) {
-			GsdWacomDeviceType type;
-			type = gsd_wacom_stylus_get_stylus_type (stylus);
-			eraser = gsd_wacom_device_get_stylus_for_type (priv->eraser, type);
-		} else {
-			eraser = NULL;
-		}
-
-		page = cc_wacom_stylus_page_new (stylus, eraser);
-		cc_wacom_stylus_page_set_navigation (CC_WACOM_STYLUS_PAGE (page), GTK_NOTEBOOK (priv->notebook));
-		gtk_widget_show (page);
-		gtk_notebook_append_page (GTK_NOTEBOOK (priv->notebook), page, NULL);
-	}
-	g_list_free (styli);
-}
-
-static void
-stylus_changed (GsdWacomDevice *device,
-		GParamSpec     *pspec,
-		CcWacomPage    *page)
-{
-	GsdWacomStylus *stylus;
-	CcWacomPagePrivate *priv;
-	int num_pages;
-	guint i;
-
-	priv = page->priv;
-	g_object_get (G_OBJECT (device), "last-stylus", &stylus, NULL);
-	if (stylus == NULL)
-		return;
-
-	num_pages = gtk_notebook_get_n_pages (GTK_NOTEBOOK (priv->notebook));
-	for (i = 0; i < num_pages; i++) {
-		GsdWacomStylus *s;
-		CcWacomStylusPage *spage;
-
-		spage = CC_WACOM_STYLUS_PAGE (gtk_notebook_get_nth_page (GTK_NOTEBOOK (priv->notebook), i));
-		s = cc_wacom_stylus_page_get_stylus (spage);
-		if (s == stylus) {
-			gtk_notebook_set_current_page (GTK_NOTEBOOK (priv->notebook), i);
-			return;
-		}
-	}
-
-	g_warning ("Failed to find the page for stylus '%s'",
-		   gsd_wacom_stylus_get_name (stylus));
-}
-
-static void
-remove_left_handed (CcWacomPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("label-left-handed"));
-	gtk_widget_destroy (WID ("switch-left-handed"));
-}
-
-static void
-remove_display_link (CcWacomPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("display-link"));
-
-        gtk_container_child_set (CWID ("main-grid"),
-                                 WID ("tablet-buttons-box"),
-                                 "top_attach", 2, NULL);
-}
-
-static void
-update_tablet_ui (CcWacomPage *page,
-		  int          layout)
-{
-	CcWacomPagePrivate *priv;
-	gboolean has_monitor = FALSE;
-
-	priv = page->priv;
-
-	/* Hide the pad buttons if no pad is present */
-	gtk_widget_set_visible (WID ("map-buttons-button"), priv->pad != NULL);
-
-	switch (layout) {
-	case LAYOUT_NORMAL:
-		remove_left_handed (priv);
-		remove_display_link (priv);
-		break;
-	case LAYOUT_REVERSIBLE:
-		remove_display_link (priv);
-		break;
-	case LAYOUT_SCREEN:
-		remove_left_handed (priv);
-
-		gtk_widget_destroy (WID ("combo-tabletmode"));
-		gtk_widget_destroy (WID ("label-trackingmode"));
-		gtk_widget_destroy (WID ("display-mapping-button"));
-
-		gtk_widget_show (WID ("button-calibrate"));
-		if (gsd_wacom_device_get_display_monitor (priv->stylus) >= 0)
-			has_monitor = TRUE;
-		gtk_widget_set_sensitive (WID ("button-calibrate"), has_monitor);
-		gtk_widget_show (WID ("display-link"));
-
-		gtk_container_child_set (CWID ("main-grid"),
-					 WID ("tablet-buttons-box"),
-					 "top_attach", 1, NULL);
-		gtk_container_child_set (CWID ("main-grid"),
-					 WID ("display-link"),
-					 "top_attach", 2, NULL);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-}
-
-gboolean
-cc_wacom_page_update_tools (CcWacomPage    *page,
-			    GsdWacomDevice *stylus,
-			    GsdWacomDevice *eraser,
-			    GsdWacomDevice *pad)
-{
-	CcWacomPagePrivate *priv;
-	int layout;
-	gboolean changed;
-
-	/* Type of layout */
-	layout = get_layout_type (stylus);
-
-	priv = page->priv;
-	changed = (priv->stylus != stylus || priv->eraser != eraser || priv->pad != pad);
-	if (!changed)
-		return FALSE;
-
-	priv->stylus = stylus;
-	priv->eraser = eraser;
-	priv->pad = pad;
-
-	update_tablet_ui (CC_WACOM_PAGE (page), layout);
-
-	return TRUE;
-}
-
-GtkWidget *
-cc_wacom_page_new (CcWacomPanel   *panel,
-		   GsdWacomDevice *stylus,
-		   GsdWacomDevice *eraser,
-		   GsdWacomDevice *pad)
-{
-	CcWacomPage *page;
-	CcWacomPagePrivate *priv;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (stylus), NULL);
-	g_return_val_if_fail (gsd_wacom_device_get_device_type (stylus) == WACOM_TYPE_STYLUS, NULL);
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (eraser), NULL);
-	g_return_val_if_fail (gsd_wacom_device_get_device_type (eraser) == WACOM_TYPE_ERASER, NULL);
-
-	if (pad != NULL)
-		g_return_val_if_fail (gsd_wacom_device_get_device_type (pad) == WACOM_TYPE_PAD, NULL);
-
-	page = g_object_new (CC_TYPE_WACOM_PAGE, NULL);
-
-	priv = page->priv;
-	priv->panel = panel;
-
-	cc_wacom_page_update_tools (page, stylus, eraser, pad);
-
-	/* FIXME move this to construct */
-	priv->wacom_settings  = gsd_wacom_device_get_settings (stylus);
-	set_mode_from_gsettings (GTK_COMBO_BOX (WID ("combo-tabletmode")), page);
-
-	/* Tablet name */
-	gtk_label_set_text (GTK_LABEL (WID ("label-tabletmodel")), gsd_wacom_device_get_name (stylus));
-
-	/* Left-handedness */
-	if (gsd_wacom_device_reversible (stylus))
-		set_left_handed_from_gsettings (page);
-
-	/* Tablet icon */
-	set_icon_name (page, "image-tablet", gsd_wacom_device_get_icon_name (stylus));
-
-	/* Add styli */
-	add_styli (page);
-
-	/* Get the current stylus and switch to its page */
-	stylus_changed (priv->stylus, NULL, page);
-	g_signal_connect (G_OBJECT (priv->stylus), "notify::last-stylus",
-			  G_CALLBACK (stylus_changed), page);
-
-	return GTK_WIDGET (page);
-}
-
-void
-cc_wacom_page_set_navigation (CcWacomPage *page,
-			      GtkNotebook *notebook,
-			      gboolean     ignore_first_page)
-{
-	CcWacomPagePrivate *priv;
-
-	g_return_if_fail (CC_IS_WACOM_PAGE (page));
-
-	priv = page->priv;
-
-	g_object_set (G_OBJECT (priv->nav),
-		      "notebook", notebook,
-		      "ignore-first", ignore_first_page,
-		      NULL);
-}
diff --git a/panels/wacom/cc-wacom-page.h b/panels/wacom/cc-wacom-page.h
deleted file mode 100644
index 12c520e..0000000
--- a/panels/wacom/cc-wacom-page.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright  2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- */
-
-
-#ifndef _CC_WACOM_PAGE_H
-#define _CC_WACOM_PAGE_H
-
-#include <gtk/gtk.h>
-#include "cc-wacom-panel.h"
-#include "gsd-wacom-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_PAGE cc_wacom_page_get_type()
-
-#define CC_WACOM_PAGE(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_PAGE, CcWacomPage))
-
-#define CC_WACOM_PAGE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_PAGE, CcWacomPageClass))
-
-#define CC_IS_WACOM_PAGE(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_PAGE))
-
-#define CC_IS_WACOM_PAGE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_PAGE))
-
-#define CC_WACOM_PAGE_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_PAGE, CcWacomPageClass))
-
-typedef struct _CcWacomPage CcWacomPage;
-typedef struct _CcWacomPageClass CcWacomPageClass;
-typedef struct _CcWacomPagePrivate CcWacomPagePrivate;
-
-struct _CcWacomPage
-{
-  GtkBox parent;
-
-  CcWacomPagePrivate *priv;
-};
-
-struct _CcWacomPageClass
-{
-  GtkBoxClass parent_class;
-};
-
-GType cc_wacom_page_get_type (void) G_GNUC_CONST;
-
-GtkWidget * cc_wacom_page_new (CcWacomPanel   *panel,
-			       GsdWacomDevice *stylus,
-			       GsdWacomDevice *eraser,
-			       GsdWacomDevice *pad);
-
-gboolean cc_wacom_page_update_tools (CcWacomPage    *page,
-				     GsdWacomDevice *stylus,
-				     GsdWacomDevice *eraser,
-				     GsdWacomDevice *pad);
-
-void cc_wacom_page_set_navigation (CcWacomPage *page,
-				   GtkNotebook *notebook,
-				   gboolean     ignore_first_page);
-
-G_END_DECLS
-
-#endif /* _CC_WACOM_PAGE_H */
diff --git a/panels/wacom/cc-wacom-panel.c b/panels/wacom/cc-wacom-panel.c
deleted file mode 100644
index 9b25267..0000000
--- a/panels/wacom/cc-wacom-panel.c
+++ /dev/null
@@ -1,406 +0,0 @@
-/*
- * Copyright  2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include <config.h>
-
-#include <string.h>
-#include <gtk/gtk.h>
-
-#include "cc-wacom-panel.h"
-#include "cc-wacom-page.h"
-#include "cc-wacom-resources.h"
-#include "gsd-wacom-device.h"
-
-#define WID(x) (GtkWidget *) gtk_builder_get_object (priv->builder, x)
-
-CC_PANEL_REGISTER (CcWacomPanel, cc_wacom_panel)
-
-#define WACOM_PANEL_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_PANEL, CcWacomPanelPrivate))
-
-struct _CcWacomPanelPrivate
-{
-	GtkBuilder       *builder;
-	GtkWidget        *notebook;
-	GHashTable       *devices; /* key=GdkDevice, value=GsdWacomDevice */
-	GHashTable       *pages; /* key=device name, value=GtkWidget */
-	GdkDeviceManager *manager;
-	guint             device_added_id;
-	guint             device_removed_id;
-};
-
-typedef struct {
-	const char *name;
-	GsdWacomDevice *stylus;
-	GsdWacomDevice *eraser;
-	GsdWacomDevice *pad;
-} Tablet;
-
-enum {
-	WACOM_PAGE = -1,
-	PLUG_IN_PAGE = 0,
-};
-
-/* Boilerplate code goes below */
-
-static void
-cc_wacom_panel_get_property (GObject    *object,
-                             guint       property_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_panel_set_property (GObject      *object,
-                             guint         property_id,
-                             const GValue *value,
-                             GParamSpec   *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_panel_dispose (GObject *object)
-{
-	CcWacomPanelPrivate *priv = CC_WACOM_PANEL (object)->priv;
-
-	if (priv->builder)
-	{
-		g_object_unref (priv->builder);
-		priv->builder = NULL;
-	}
-
-	if (priv->manager)
-	{
-		g_signal_handler_disconnect (priv->manager, priv->device_added_id);
-		g_signal_handler_disconnect (priv->manager, priv->device_removed_id);
-		priv->manager = NULL;
-	}
-
-	if (priv->devices)
-	{
-		g_hash_table_destroy (priv->devices);
-		priv->devices = NULL;
-	}
-
-	if (priv->pages)
-	{
-		g_hash_table_destroy (priv->pages);
-		priv->pages = NULL;
-	}
-
-	G_OBJECT_CLASS (cc_wacom_panel_parent_class)->dispose (object);
-}
-
-static const char *
-cc_wacom_panel_get_help_uri (CcPanel *panel)
-{
-  if (!g_strcmp0(g_getenv("XDG_CURRENT_DESKTOP"), "Unity"))
-    return "help:ubuntu-help/wacom";
-  else
-    return "help:gnome-help/wacom";
-}
-
-static void
-cc_wacom_panel_class_init (CcWacomPanelClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-	CcPanelClass *panel_class = CC_PANEL_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomPanelPrivate));
-
-	object_class->get_property = cc_wacom_panel_get_property;
-	object_class->set_property = cc_wacom_panel_set_property;
-	object_class->dispose = cc_wacom_panel_dispose;
-
-	panel_class->get_help_uri = cc_wacom_panel_get_help_uri;
-}
-
-static void
-remove_page (GtkNotebook *notebook,
-	     GtkWidget   *widget)
-{
-	int num_pages, i;
-
-	num_pages = gtk_notebook_get_n_pages (notebook);
-	g_return_if_fail (num_pages > 1);
-	for (i = 1; i < num_pages; i++) {
-		if (gtk_notebook_get_nth_page (notebook, i) == widget) {
-			gtk_notebook_remove_page (notebook, i);
-			return;
-		}
-	}
-}
-
-static void
-update_current_page (CcWacomPanel *self)
-{
-	GHashTable *ht;
-	GList *devices, *tablets, *l;
-	gboolean changed;
-	CcWacomPanelPrivate *priv;
-
-	priv = self->priv;
-	changed = FALSE;
-
-	ht = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
-	devices = g_hash_table_get_values (priv->devices);
-	for (l = devices; l; l = l->next) {
-		Tablet *tablet;
-		GsdWacomDevice *device;
-
-		device = l->data;
-		tablet = g_hash_table_lookup (ht, gsd_wacom_device_get_name (device));
-		if (tablet == NULL) {
-			tablet = g_new0 (Tablet, 1);
-			tablet->name = gsd_wacom_device_get_name (device);
-			g_hash_table_insert (ht, (gpointer) tablet->name, tablet);
-		}
-
-		switch (gsd_wacom_device_get_device_type (device)) {
-		case WACOM_TYPE_STYLUS:
-			tablet->stylus = device;
-			break;
-		case WACOM_TYPE_ERASER:
-			tablet->eraser = device;
-			break;
-		case WACOM_TYPE_PAD:
-			tablet->pad = device;
-			break;
-		default:
-			/* Nothing */
-			;
-		}
-	}
-	g_list_free (devices);
-
-	/* We now have a list of Tablet structs,
-	 * see which ones are full tablets */
-	tablets = g_hash_table_get_values (ht);
-	for (l = tablets; l; l = l->next) {
-		Tablet *tablet;
-		GtkWidget *page;
-
-		tablet = l->data;
-		if (tablet->stylus == NULL ||
-		    tablet->eraser == NULL) {
-			page = g_hash_table_lookup (priv->pages, tablet->name);
-			if (page != NULL) {
-				remove_page (GTK_NOTEBOOK (priv->notebook), page);
-				g_hash_table_remove (priv->pages, tablet->name);
-
-				changed = TRUE;
-			}
-			continue;
-		}
-		/* this code is called once the stylus + eraser were set up, but the pad does not exist yet */
-		page = g_hash_table_lookup (priv->pages, tablet->name);
-		if (page == NULL) {
-			page = cc_wacom_page_new (self, tablet->stylus, tablet->eraser, tablet->pad);
-			cc_wacom_page_set_navigation (CC_WACOM_PAGE (page), GTK_NOTEBOOK (priv->notebook), TRUE);
-			gtk_widget_show (page);
-			gtk_notebook_append_page (GTK_NOTEBOOK (priv->notebook), page, NULL);
-			g_hash_table_insert (priv->pages, g_strdup (tablet->name), page);
-
-			changed = TRUE;
-		} else {
-			cc_wacom_page_update_tools (CC_WACOM_PAGE (page), tablet->stylus, tablet->eraser, tablet->pad);
-		}
-	}
-	g_list_free (tablets);
-
-	g_hash_table_destroy (ht);
-
-	if (changed == TRUE) {
-		int num_pages;
-
-		num_pages = gtk_notebook_get_n_pages (GTK_NOTEBOOK (priv->notebook));
-		if (num_pages > 1)
-			gtk_notebook_set_current_page (GTK_NOTEBOOK (priv->notebook), WACOM_PAGE);
-	}
-}
-
-static void
-add_known_device (CcWacomPanel *self,
-		  GdkDevice    *gdk_device)
-{
-	CcWacomPanelPrivate *priv;
-	GsdWacomDevice *device;
-
-	priv = self->priv;
-
-	device = gsd_wacom_device_new (gdk_device);
-	if (gsd_wacom_device_get_device_type (device) == WACOM_TYPE_INVALID) {
-		g_object_unref (device);
-		return;
-	}
-	g_debug ("Adding device '%s' (type: '%s') to known devices list",
-		 gsd_wacom_device_get_tool_name (device),
-		 gsd_wacom_device_type_to_string (gsd_wacom_device_get_device_type (device)));
-	g_hash_table_insert (priv->devices, (gpointer) gdk_device, device);
-}
-
-static void
-device_removed_cb (GdkDeviceManager *manager,
-		   GdkDevice        *gdk_device,
-		   CcWacomPanel     *self)
-{
-	g_hash_table_remove (self->priv->devices, gdk_device);
-	update_current_page (self);
-}
-
-static void
-device_added_cb (GdkDeviceManager *manager,
-		 GdkDevice        *device,
-		 CcWacomPanel     *self)
-{
-	add_known_device (self, device);
-	update_current_page (self);
-}
-
-static gboolean
-link_activated (GtkLinkButton *button,
-		CcWacomPanel  *self)
-{
-	cc_wacom_panel_switch_to_panel (self, "bluetooth");
-	return TRUE;
-}
-
-void
-cc_wacom_panel_switch_to_panel (CcWacomPanel *self,
-				const char   *panel)
-{
-	CcShell *shell;
-	GError *error = NULL;
-
-	g_return_if_fail (self);
-
-	shell = cc_panel_get_shell (CC_PANEL (self));
-	if (cc_shell_set_active_panel_from_id (shell, panel, NULL, &error) == FALSE)
-	{
-		g_warning ("Failed to activate '%s' panel: %s", panel, error->message);
-		g_error_free (error);
-	}
-}
-
-static void
-enbiggen_label (GtkLabel *label)
-{
-	const char *str;
-	char *new_str;
-
-	str = gtk_label_get_text (label);
-	new_str = g_strdup_printf ("<big>%s</big>", str);
-	gtk_label_set_markup (label, new_str);
-	g_free (new_str);
-}
-
-static void
-cc_wacom_panel_init (CcWacomPanel *self)
-{
-	CcWacomPanelPrivate *priv;
-	GtkNotebook *notebook;
-	GtkWidget *widget;
-	GList *devices, *l;
-	GError *error = NULL;
-	char *objects[] = {
-		"main-box",
-		NULL
-	};
-
-	priv = self->priv = WACOM_PANEL_PRIVATE (self);
-        g_resources_register (cc_wacom_get_resource ());
-
-	priv->builder = gtk_builder_new ();
-
-	gtk_builder_add_objects_from_resource (priv->builder,
-                                               "/org/gnome/control-center/wacom/gnome-wacom-properties.ui",
-                                               objects,
-                                               &error);
-	if (error != NULL)
-	{
-		g_warning ("Error loading UI file: %s", error->message);
-		g_object_unref (priv->builder);
-		g_error_free (error);
-		return;
-	}
-
-	/* Notebook */
-	notebook = GTK_NOTEBOOK (gtk_notebook_new ());
-	priv->notebook = GTK_WIDGET (notebook);
-
-	gtk_notebook_set_show_tabs (notebook, FALSE);
-	gtk_widget_set_vexpand (GTK_WIDGET (notebook), TRUE);
-	gtk_container_set_border_width (GTK_CONTAINER (notebook), 0);
-	g_object_set (G_OBJECT (notebook),
-		      "margin-top", 6,
-		      "margin-right", 30,
-		      "margin-left", 30,
-		      "margin-bottom", 30,
-		      NULL);
-
-	gtk_container_add (GTK_CONTAINER (self), GTK_WIDGET (notebook));
-	gtk_widget_show (priv->notebook);
-
-	/* No tablets page */
-	widget = WID ("main-box");
-	enbiggen_label (GTK_LABEL (WID ("advice-label1")));
-	gtk_notebook_append_page (notebook, widget, NULL);
-
-	g_signal_connect (G_OBJECT (WID ("linkbutton")), "activate-link",
-			  G_CALLBACK (link_activated), self);
-
-	priv->devices = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
-	priv->pages = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
-
-	priv->manager = gdk_display_get_device_manager (gdk_display_get_default ());
-	priv->device_added_id = g_signal_connect (G_OBJECT (priv->manager), "device-added",
-						  G_CALLBACK (device_added_cb), self);
-	priv->device_removed_id = g_signal_connect (G_OBJECT (priv->manager), "device-removed",
-						    G_CALLBACK (device_removed_cb), self);
-
-	devices = gdk_device_manager_list_devices (priv->manager, GDK_DEVICE_TYPE_SLAVE);
-	for (l = devices; l ; l = l->next)
-		add_known_device (self, l->data);
-	g_list_free (devices);
-
-	update_current_page (self);
-}
-
-void
-cc_wacom_panel_register (GIOModule *module)
-{
-	cc_wacom_panel_register_type (G_TYPE_MODULE (module));
-	g_io_extension_point_implement (CC_SHELL_PANEL_EXTENSION_POINT,
-					CC_TYPE_WACOM_PANEL, "wacom", 0);
-}
-
diff --git a/panels/wacom/cc-wacom-panel.h b/panels/wacom/cc-wacom-panel.h
deleted file mode 100644
index 54b8faa..0000000
--- a/panels/wacom/cc-wacom-panel.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright  2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- */
-
-
-#ifndef _CC_WACOM_PANEL_H
-#define _CC_WACOM_PANEL_H
-
-#include <shell/cc-panel.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_PANEL cc_wacom_panel_get_type()
-
-#define CC_WACOM_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_PANEL, CcWacomPanel))
-
-#define CC_WACOM_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_PANEL, CcWacomPanelClass))
-
-#define CC_IS_WACOM_PANEL(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_PANEL))
-
-#define CC_IS_WACOM_PANEL_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_PANEL))
-
-#define CC_WACOM_PANEL_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_PANEL, CcWacomPanelClass))
-
-typedef struct _CcWacomPanel CcWacomPanel;
-typedef struct _CcWacomPanelClass CcWacomPanelClass;
-typedef struct _CcWacomPanelPrivate CcWacomPanelPrivate;
-
-struct _CcWacomPanel
-{
-  CcPanel parent;
-
-  CcWacomPanelPrivate *priv;
-};
-
-struct _CcWacomPanelClass
-{
-  CcPanelClass parent_class;
-};
-
-GType cc_wacom_panel_get_type (void) G_GNUC_CONST;
-
-void  cc_wacom_panel_register (GIOModule *module);
-
-void  cc_wacom_panel_switch_to_panel (CcWacomPanel *self,
-				      const char   *panel);
-
-G_END_DECLS
-
-#endif /* _CC_WACOM_PANEL_H */
diff --git a/panels/wacom/cc-wacom-stylus-page.c b/panels/wacom/cc-wacom-stylus-page.c
deleted file mode 100644
index b063d52..0000000
--- a/panels/wacom/cc-wacom-stylus-page.c
+++ /dev/null
@@ -1,507 +0,0 @@
-/*
- * Copyright  2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include <config.h>
-
-#include <glib/gi18n.h>
-#include "cc-wacom-stylus-page.h"
-#include "cc-wacom-nav-button.h"
-#include <gtk/gtk.h>
-
-#include <string.h>
-
-#define WID(x) (GtkWidget *) gtk_builder_get_object (priv->builder, x)
-#define CWID(x) (GtkContainer *) gtk_builder_get_object (priv->builder, x)
-
-G_DEFINE_TYPE (CcWacomStylusPage, cc_wacom_stylus_page, GTK_TYPE_BOX)
-
-#define WACOM_STYLUS_PAGE_PRIVATE(o) \
-  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_WACOM_STYLUS_PAGE, CcWacomStylusPagePrivate))
-
-struct _CcWacomStylusPagePrivate
-{
-	GsdWacomStylus *stylus, *eraser;
-	GtkBuilder     *builder;
-	GtkWidget      *nav;
-	GSettings      *stylus_settings, *eraser_settings;
-};
-
-/* Button combo box storage columns */
-enum {
-	BUTTONNUMBER_COLUMN,
-	BUTTONNAME_COLUMN,
-	N_BUTTONCOLUMNS
-};
-
-/* GSettings stores pressurecurve as 4 values like the driver. We map slider
- * scale to these values given the array below. These settings were taken from
- * wacomcpl, where they've been around for years.
- */
-#define N_PRESSURE_CURVES 7
-static const gint32 PRESSURE_CURVES[N_PRESSURE_CURVES][4] = {
-		{	0,	75,	25,	100	},	/* soft */
-		{	0,	50,	50,	100	},
-		{	0,	25,	75,	100	},
-		{	0,	0,	100,	100	},	/* neutral */
-		{	25,	0,	100,	75	},
-		{	50,	0,	100,	50	},
-		{	75,	0,	100,	25	}	/* firm */
-};
-
-static void
-set_pressurecurve (GtkRange *range, GSettings *settings)
-{
-	gint		slider_val = gtk_range_get_value (range);
-	GVariant	*values[4],
-			*array;
-	int		i;
-
-	for (i = 0; i < G_N_ELEMENTS (values); i++)
-		values[i] = g_variant_new_int32 (PRESSURE_CURVES[slider_val][i]);
-
-	array = g_variant_new_array (G_VARIANT_TYPE_INT32, values, G_N_ELEMENTS (values));
-
-	g_settings_set_value (settings, "pressurecurve", array);
-}
-
-static void
-tip_feel_value_changed_cb (GtkRange *range, gpointer user_data)
-{
-    set_pressurecurve (range, CC_WACOM_STYLUS_PAGE(user_data)->priv->stylus_settings);
-}
-
-static void
-eraser_feel_value_changed_cb (GtkRange *range, gpointer user_data)
-{
-    set_pressurecurve (range, CC_WACOM_STYLUS_PAGE(user_data)->priv->eraser_settings);
-}
-
-static void
-set_feel_from_gsettings (GtkAdjustment *adjustment, GSettings *settings)
-{
-	GVariant	*variant;
-	const gint32	*values;
-	gsize		nvalues;
-	int		i;
-
-	variant = g_settings_get_value (settings, "pressurecurve");
-	values = g_variant_get_fixed_array (variant, &nvalues, sizeof (gint32));
-
-	if (nvalues != 4) {
-		g_warning ("Invalid pressure curve format, expected 4 values (got %"G_GSIZE_FORMAT")", nvalues);
-		return;
-	}
-
-	for (i = 0; i < N_PRESSURE_CURVES; i++) {
-		if (memcmp (PRESSURE_CURVES[i], values, sizeof (gint32) * 4) == 0) {
-			gtk_adjustment_set_value (adjustment, i);
-			break;
-		}
-	}
-}
-
-static void
-set_button_mapping_from_gsettings (GtkComboBox *combo, GSettings* settings, gint current_button)
-{
-	GVariant	*current;
-	gsize		 nvalues;
-	const gint	*values;
-	GtkTreeModel	*model;
-	GtkTreeIter	 iter;
-	gboolean	 valid;
-
-	current = g_settings_get_value (settings, "buttonmapping");
-	values = g_variant_get_fixed_array (current, &nvalues, sizeof (gint32));
-	model = gtk_combo_box_get_model (combo);
-	valid = gtk_tree_model_get_iter_first (model, &iter);
-
-	while (valid) {
-		gint button;
-
-		gtk_tree_model_get (model, &iter,
-				    BUTTONNUMBER_COLUMN, &button,
-				    -1);
-
-		/* Currently button values match logical X buttons. If we
-		 * introduce things like double-click, this code must
-		 * change. Recommendation: use negative buttons numbers for
-		 * special ones.
-		 */
-
-		/* 0 vs 1-indexed array/button numbers */
-		if (button == values[current_button - 1]) {
-			gtk_combo_box_set_active_iter (combo, &iter);
-			break;
-		}
-
-		valid = gtk_tree_model_iter_next (model, &iter);
-	}
-}
-
-static void
-map_button (GSettings *settings, int button2, int button3)
-{
-	GVariant	*current; /* current mapping */
-	GVariant	*array;   /* new mapping */
-	GVariant	**tmp;
-	gsize		 nvalues;
-	const gint	*values;
-	gint		 i;
-
-	current = g_settings_get_value (settings, "buttonmapping");
-	values = g_variant_get_fixed_array (current, &nvalues, sizeof (gint32));
-
-	tmp = g_malloc (nvalues * sizeof (GVariant*));
-	for (i = 0; i < nvalues; i++) {
-		if (i == 1) /* zero indexed array vs one-indexed buttons */
-			tmp[i] = g_variant_new_int32 (button2);
-		else if (i == 2)
-			tmp[i] = g_variant_new_int32 (button3);
-		else
-			tmp[i] = g_variant_new_int32 (values[i]);
-	}
-
-	array = g_variant_new_array (G_VARIANT_TYPE_INT32, tmp, nvalues);
-	g_settings_set_value (settings, "buttonmapping", array);
-
-	g_free (tmp);
-}
-
-static void
-button_changed_cb (GtkComboBox *combo, gpointer user_data)
-{
-	CcWacomStylusPagePrivate	*priv = CC_WACOM_STYLUS_PAGE(user_data)->priv;
-	GtkTreeIter		iter;
-	GtkListStore		*liststore;
-	gint			mapping_b2,
-				mapping_b3;
-
-	if (!gtk_combo_box_get_active_iter (GTK_COMBO_BOX (WID ("combo-bottombutton")), &iter))
-		return;
-
-	liststore = GTK_LIST_STORE (WID ("liststore-buttons"));
-	gtk_tree_model_get (GTK_TREE_MODEL (liststore), &iter,
-			    BUTTONNUMBER_COLUMN, &mapping_b2,
-			    -1);
-
-	if (!gtk_combo_box_get_active_iter (GTK_COMBO_BOX (WID ("combo-topbutton")), &iter))
-		return;
-
-	gtk_tree_model_get (GTK_TREE_MODEL (liststore), &iter,
-			    BUTTONNUMBER_COLUMN, &mapping_b3,
-			    -1);
-
-	map_button (priv->stylus_settings, mapping_b2, mapping_b3);
-}
-
-static void
-combobox_text_cellrenderer (GtkComboBox *combo, int name_column)
-{
-	GtkCellRenderer	*renderer;
-
-	renderer = gtk_cell_renderer_text_new ();
-	gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo), renderer, TRUE);
-	gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo), renderer,
-					"text", BUTTONNAME_COLUMN, NULL);
-}
-
-/* Boilerplate code goes below */
-
-static void
-cc_wacom_stylus_page_get_property (GObject    *object,
-                             guint       property_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_stylus_page_set_property (GObject      *object,
-                             guint         property_id,
-                             const GValue *value,
-                             GParamSpec   *pspec)
-{
-	switch (property_id)
-	{
-		default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-	}
-}
-
-static void
-cc_wacom_stylus_page_dispose (GObject *object)
-{
-	CcWacomStylusPagePrivate *priv = CC_WACOM_STYLUS_PAGE (object)->priv;
-
-	if (priv->builder) {
-		g_object_unref (priv->builder);
-		priv->builder = NULL;
-	}
-
-
-	G_OBJECT_CLASS (cc_wacom_stylus_page_parent_class)->dispose (object);
-}
-
-static void
-cc_wacom_stylus_page_class_init (CcWacomStylusPageClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (CcWacomStylusPagePrivate));
-
-	object_class->get_property = cc_wacom_stylus_page_get_property;
-	object_class->set_property = cc_wacom_stylus_page_set_property;
-	object_class->dispose = cc_wacom_stylus_page_dispose;
-}
-
-static void
-cc_wacom_stylus_page_init (CcWacomStylusPage *self)
-{
-	CcWacomStylusPagePrivate *priv;
-	GError *error = NULL;
-	GtkComboBox *combo;
-	GtkWidget *box;
-	char *objects[] = {
-		"stylus-grid",
-		"liststore-buttons",
-		"adjustment-tip-feel",
-		"adjustment-eraser-feel",
-		NULL
-	};
-
-	priv = self->priv = WACOM_STYLUS_PAGE_PRIVATE (self);
-
-	priv->builder = gtk_builder_new ();
-
-	gtk_builder_add_objects_from_resource (priv->builder,
-                                               "/org/gnome/control-center/wacom/wacom-stylus-page.ui",
-                                               objects,
-                                               &error);
-	if (error != NULL) {
-		g_warning ("Error loading UI file: %s", error->message);
-		g_object_unref (priv->builder);
-		g_error_free (error);
-		return;
-	}
-
-	box = WID ("stylus-grid");
-	gtk_container_add (GTK_CONTAINER (self), box);
-	gtk_widget_set_vexpand (GTK_WIDGET (box), TRUE);
-
-	g_signal_connect (WID ("scale-tip-feel"), "value-changed",
-			  G_CALLBACK (tip_feel_value_changed_cb), self);
-	g_signal_connect (WID ("scale-eraser-feel"), "value-changed",
-			  G_CALLBACK (eraser_feel_value_changed_cb), self);
-
-	combo = GTK_COMBO_BOX (WID ("combo-topbutton"));
-	combobox_text_cellrenderer (combo, BUTTONNAME_COLUMN);
-	g_signal_connect (G_OBJECT (combo), "changed",
-			  G_CALLBACK (button_changed_cb), self);
-
-	combo = GTK_COMBO_BOX (WID ("combo-bottombutton"));
-	combobox_text_cellrenderer (combo, BUTTONNAME_COLUMN);
-	g_signal_connect (G_OBJECT (combo), "changed",
-			  G_CALLBACK (button_changed_cb), self);
-
-	priv->nav = cc_wacom_nav_button_new ();
-        gtk_widget_set_halign (priv->nav, GTK_ALIGN_END);
-        gtk_widget_set_margin_left (priv->nav, 10);
-	gtk_grid_attach (GTK_GRID (box), priv->nav, 1, 0, 1, 1);
-}
-
-static void
-set_icon_name (CcWacomStylusPage *page,
-	       const char  *widget_name,
-	       const char  *icon_name)
-{
-	CcWacomStylusPagePrivate *priv;
-	char *resource;
-
-	priv = page->priv;
-
-	resource = g_strdup_printf ("/org/gnome/control-center/wacom/%s.svg", icon_name);
-	gtk_image_set_from_resource (GTK_IMAGE (WID (widget_name)), resource);
-	g_free (resource);
-}
-
-/* Different types of layout for the stylus config */
-enum {
-	LAYOUT_NORMAL,   /* eraser, 2 buttons, tip */
-	LAYOUT_INKING,   /* tip */
-	LAYOUT_AIRBRUSH, /* eraser, 1 button, tip */
-	LAYOUT_OTHER
-};
-
-static void
-remove_buttons (CcWacomStylusPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("combo-topbutton"));
-	gtk_widget_destroy (WID ("combo-bottombutton"));
-	gtk_widget_destroy (WID ("label-top-button"));
-	gtk_widget_destroy (WID ("label-lower-button"));
-}
-
-static void
-remove_button (CcWacomStylusPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("combo-topbutton"));
-	gtk_widget_destroy (WID ("label-top-button"));
-	gtk_label_set_text (GTK_LABEL (WID ("label-lower-button")), _("Button"));
-}
-
-static void
-remove_eraser (CcWacomStylusPagePrivate *priv)
-{
-	gtk_widget_destroy (WID ("eraser-box"));
-	gtk_widget_destroy (WID ("label-eraser-feel"));
-}
-
-static void
-update_stylus_ui (CcWacomStylusPage *page,
-		  int                layout)
-{
-	CcWacomStylusPagePrivate *priv = page->priv;
-
-	switch (layout) {
-	case LAYOUT_NORMAL:
-		/* easy! */
-		break;
-	case LAYOUT_INKING:
-		remove_buttons (page->priv);
-		remove_eraser (page->priv);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("label-tip-feel"),
-					 "top_attach", 0, NULL);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("box-tip-feel"),
-					 "top_attach", 0, NULL);
-		break;
-	case LAYOUT_AIRBRUSH:
-		remove_button (page->priv);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("label-lower-button"),
-					 "top_attach", 1, NULL);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("combo-bottombutton"),
-					 "top_attach", 1, NULL);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("label-tip-feel"),
-					 "top_attach", 2, NULL);
-		gtk_container_child_set (CWID ("stylus-controls-grid"),
-					 WID ("box-tip-feel"),
-					 "top_attach", 2, NULL);
-	case LAYOUT_OTHER:
-		/* We already warn about it in cc_wacom_stylus_page_new () */
-		break;
-	}
-}
-
-GtkWidget *
-cc_wacom_stylus_page_new (GsdWacomStylus *stylus,
-			  GsdWacomStylus *eraser)
-{
-	CcWacomStylusPage *page;
-	CcWacomStylusPagePrivate *priv;
-	int num_buttons;
-	int layout;
-
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	page = g_object_new (CC_TYPE_WACOM_STYLUS_PAGE, NULL);
-
-	priv = page->priv;
-	priv->stylus = stylus;
-	priv->eraser = eraser;
-
-	/* Icon */
-	set_icon_name (page, "image-stylus", gsd_wacom_stylus_get_icon_name (stylus));
-
-	/* Settings */
-	priv->stylus_settings = gsd_wacom_stylus_get_settings (stylus);
-	if (eraser != NULL)
-		priv->eraser_settings = gsd_wacom_stylus_get_settings (eraser);
-
-	/* Stylus name */
-	gtk_label_set_text (GTK_LABEL (WID ("label-stylus")), gsd_wacom_stylus_get_name (stylus));
-
-	num_buttons = gsd_wacom_stylus_get_num_buttons (stylus);
-	if (num_buttons == 0 && eraser == NULL)
-		layout = LAYOUT_INKING;
-	else if (num_buttons == 2 && eraser != NULL)
-		layout = LAYOUT_NORMAL;
-	else if (num_buttons == 1 && eraser != NULL)
-		layout = LAYOUT_AIRBRUSH;
-	else {
-		layout = LAYOUT_OTHER;
-		if (num_buttons == 0)
-			remove_buttons (priv);
-		else if (num_buttons == 1)
-			remove_button (priv);
-
-		if (eraser == NULL)
-			remove_eraser (priv);
-
-		g_warning ("The layout of this page is not known, %d buttons, %s eraser",
-			   num_buttons, eraser ? "with" : "without");
-	}
-
-	update_stylus_ui (page, layout);
-
-	if (num_buttons == 2)
-		set_button_mapping_from_gsettings (GTK_COMBO_BOX (WID ("combo-topbutton")), priv->stylus_settings, 3);
-	if (num_buttons >= 1)
-		set_button_mapping_from_gsettings (GTK_COMBO_BOX (WID ("combo-bottombutton")), priv->stylus_settings, 2);
-	set_feel_from_gsettings (GTK_ADJUSTMENT (WID ("adjustment-tip-feel")), priv->stylus_settings);
-
-	if (eraser != NULL)
-		set_feel_from_gsettings (GTK_ADJUSTMENT (WID ("adjustment-eraser-feel")), priv->eraser_settings);
-
-	g_object_set (G_OBJECT (page), "margin-top", 16, NULL);
-
-	return GTK_WIDGET (page);
-}
-
-GsdWacomStylus *
-cc_wacom_stylus_page_get_stylus (CcWacomStylusPage *page)
-{
-	return page->priv->stylus;
-}
-
-void
-cc_wacom_stylus_page_set_navigation (CcWacomStylusPage *page,
-				     GtkNotebook *notebook)
-{
-	CcWacomStylusPagePrivate *priv;
-
-	g_return_if_fail (CC_IS_WACOM_STYLUS_PAGE (page));
-
-	priv = page->priv;
-
-	g_object_set (G_OBJECT (priv->nav),
-		      "notebook", notebook,
-		      NULL);
-}
diff --git a/panels/wacom/cc-wacom-stylus-page.h b/panels/wacom/cc-wacom-stylus-page.h
deleted file mode 100644
index 61a0964..0000000
--- a/panels/wacom/cc-wacom-stylus-page.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright  2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: Peter Hutterer <peter.hutterer@redhat.com>
- *          Bastien Nocera <hadess@hadess.net>
- */
-
-
-#ifndef _CC_WACOM_STYLUS_PAGE_H
-#define _CC_WACOM_STYLUS_PAGE_H
-
-#include <gtk/gtk.h>
-#include "gsd-wacom-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WACOM_STYLUS_PAGE cc_wacom_stylus_page_get_type()
-
-#define CC_WACOM_STYLUS_PAGE(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
-  CC_TYPE_WACOM_STYLUS_PAGE, CcWacomStylusPage))
-
-#define CC_WACOM_STYLUS_PAGE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST ((klass), \
-  CC_TYPE_WACOM_STYLUS_PAGE, CcWacomStylusPageClass))
-
-#define CC_IS_WACOM_STYLUS_PAGE(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
-  CC_TYPE_WACOM_STYLUS_PAGE))
-
-#define CC_IS_WACOM_STYLUS_PAGE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
-  CC_TYPE_WACOM_STYLUS_PAGE))
-
-#define CC_WACOM_STYLUS_PAGE_GET_CLASS(obj) \
-  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
-  CC_TYPE_WACOM_STYLUS_PAGE, CcWacomStylusPageClass))
-
-typedef struct _CcWacomStylusPage CcWacomStylusPage;
-typedef struct _CcWacomStylusPageClass CcWacomStylusPageClass;
-typedef struct _CcWacomStylusPagePrivate CcWacomStylusPagePrivate;
-
-struct _CcWacomStylusPage
-{
-  GtkBox parent;
-
-  CcWacomStylusPagePrivate *priv;
-};
-
-struct _CcWacomStylusPageClass
-{
-  GtkBoxClass parent_class;
-};
-
-GType cc_wacom_stylus_page_get_type (void) G_GNUC_CONST;
-
-GtkWidget * cc_wacom_stylus_page_new (GsdWacomStylus *stylus,
-				      GsdWacomStylus *eraser);
-
-GsdWacomStylus * cc_wacom_stylus_page_get_stylus (CcWacomStylusPage *page);
-
-void cc_wacom_stylus_page_set_navigation (CcWacomStylusPage *page,
-					  GtkNotebook *notebook);
-
-G_END_DECLS
-
-#endif /* _CC_WACOM_STYLUS_PAGE_H */
diff --git a/panels/wacom/gnome-wacom-properties.ui b/panels/wacom/gnome-wacom-properties.ui
deleted file mode 100644
index 3be1a4c..0000000
--- a/panels/wacom/gnome-wacom-properties.ui
+++ /dev/null
@@ -1,407 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <!-- interface-requires gtk+ 3.0 -->
-  <object class="GtkListStore" id="liststore-tabletmode">
-    <columns>
-      <!-- column-name tabletmode -->
-      <column type="guint"/>
-      <!-- column-name tabletmode-label -->
-      <column type="gchararray"/>
-    </columns>
-    <data>
-      <row>
-        <col id="0">0</col>
-        <col id="1" translatable="yes">Tablet (absolute)</col>
-      </row>
-      <row>
-        <col id="0">1</col>
-        <col id="1" translatable="yes">Touchpad (relative)</col>
-      </row>
-    </data>
-  </object>
-  <object class="GtkDialog" id="wacom_properties_dialog">
-    <property name="can_focus">False</property>
-    <property name="vexpand">True</property>
-    <property name="border_width">5</property>
-    <property name="title" translatable="yes">Tablet Preferences</property>
-    <property name="resizable">False</property>
-    <property name="default_width">675</property>
-    <property name="default_height">460</property>
-    <property name="icon_name">input-tablet</property>
-    <property name="type_hint">dialog</property>
-    <child internal-child="vbox">
-      <object class="GtkBox" id="dialog-vbox1">
-        <property name="can_focus">False</property>
-        <property name="orientation">vertical</property>
-        <property name="spacing">2</property>
-        <child internal-child="action_area">
-          <object class="GtkButtonBox" id="dialog-action_area1">
-            <property name="can_focus">False</property>
-            <property name="layout_style">end</property>
-            <child>
-              <object class="GtkButton" id="helpbutton1">
-                <property name="label">gtk-help</property>
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="can_default">True</property>
-                <property name="receives_default">False</property>
-                <property name="use_action_appearance">False</property>
-                <property name="use_stock">True</property>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">False</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkButton" id="closebutton1">
-                <property name="label">gtk-close</property>
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="can_default">True</property>
-                <property name="receives_default">False</property>
-                <property name="use_action_appearance">False</property>
-                <property name="use_stock">True</property>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">False</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">False</property>
-            <property name="fill">True</property>
-            <property name="pack_type">end</property>
-            <property name="position">0</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkNotebook" id="main-notebook">
-            <property name="visible">True</property>
-            <property name="can_focus">True</property>
-            <property name="vexpand">True</property>
-            <property name="show_tabs">False</property>
-            <child>
-              <object class="GtkBox" id="main-box">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="vexpand">True</property>
-                <property name="orientation">vertical</property>
-                <child>
-                  <placeholder/>
-                </child>
-                <child>
-                  <object class="GtkLabel" id="advice-label1">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="vexpand">True</property>
-                    <property name="yalign">1</property>
-                    <property name="label" translatable="yes">No tablet detected</property>
-                    <property name="justify">center</property>
-                    <property name="use_markup">True</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">True</property>
-                    <property name="position">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkLabel" id="advice-label2">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="vexpand">True</property>
-                    <property name="yalign">0</property>
-                    <property name="label" translatable="yes">Please plug in or turn on your Wacom tablet</property>
-                    <property name="justify">center</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">True</property>
-                    <property name="position">3</property>
-                  </packing>
-                </child>
-                <child>
-                  <placeholder/>
-                </child>
-                <child>
-                  <object class="GtkLinkButton" id="linkbutton">
-                    <property name="label" translatable="yes">Bluetooth Settings</property>
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="receives_default">True</property>
-                    <property name="has_tooltip">False</property>
-                    <property name="halign">end</property>
-                    <property name="valign">end</property>
-                    <property name="use_action_appearance">False</property>
-                    <property name="relief">none</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">True</property>
-                    <property name="position">5</property>
-                  </packing>
-                </child>
-              </object>
-              <packing>
-                <property name="tab_expand">True</property>
-              </packing>
-            </child>
-            <child type="tab">
-              <object class="GtkLabel" id="label4">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label">Plugin</property>
-              </object>
-              <packing>
-                <property name="tab_fill">False</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkGrid" id="main-grid">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="column_spacing">10</property>
-                <property name="row_spacing">10</property>
-                <child>
-                  <object class="GtkLabel" id="label-tabletmodel">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="halign">start</property>
-                    <property name="valign">center</property>
-                    <property name="label" translatable="yes">Wacom Tablet</property>
-                    <attributes>
-                      <attribute name="weight" value="bold"/>
-                    </attributes>
-                  </object>
-                  <packing>
-                    <property name="left_attach">0</property>
-                    <property name="top_attach">0</property>
-                    <property name="width">2</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkImage" id="image-tablet">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="pixbuf">wacom-tablet.svg</property>
-                    <property name="valign">start</property>
-                    <property name="halign">center</property>
-                  </object>
-                  <packing>
-                    <property name="left_attach">0</property>
-                    <property name="top_attach">1</property>
-                    <property name="width">1</property>
-                    <property name="height">3</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkBox" id="tablet-buttons-box">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="hexpand">True</property>
-                    <property name="spacing">10</property>
-                    <child>
-                      <object class="GtkButton" id="display-mapping-button">
-                        <property name="label" translatable="yes">Map to Monitor</property>
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="receives_default">True</property>
-                        <property name="valign">center</property>
-                        <property name="use_action_appearance">False</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">True</property>
-                        <property name="pack_type">end</property>
-                        <property name="position">0</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkButton" id="map-buttons-button">
-                        <property name="label" translatable="yes">Map Buttons</property>
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="receives_default">True</property>
-                        <property name="valign">center</property>
-                        <property name="use_action_appearance">False</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">True</property>
-                        <property name="pack_type">end</property>
-                        <property name="position">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkButton" id="button-calibrate">
-                        <property name="label" translatable="yes">Calibrate</property>
-                        <property name="can_focus">True</property>
-                        <property name="receives_default">True</property>
-                        <property name="valign">center</property>
-                        <property name="use_action_appearance">False</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">True</property>
-                        <property name="pack_type">end</property>
-                        <property name="position">2</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="top_attach">2</property>
-                    <property name="width">1</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-                <child>
-                 <object class="GtkLinkButton" id="display-link">
-                   <property name="label" translatable="yes">Adjust display resolution</property>
-                   <property name="visible">False</property>
-                   <property name="can_focus">True</property>
-                   <property name="receives_default">True</property>
-                   <property name="has_tooltip">False</property>
-                   <property name="use_action_appearance">False</property>
-                   <property name="relief">none</property>
-                   <property name="halign">end</property>
-                   <property name="valign">center</property>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="top_attach">3</property>
-                    <property name="width">1</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkGrid" id="main-controls-grid">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="orientation">vertical</property>
-                    <property name="margin_left">16</property>
-                    <property name="row_spacing">10</property>
-                    <property name="column_spacing">10</property>
-                    <child>
-                      <object class="GtkLabel" id="label-trackingmode">
-                        <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="halign">end</property>
-                        <property name="valign">center</property>
-                        <property name="label" translatable="yes">Tracking Mode</property>
-                        <style>
-                          <class name="dim-label-ucc"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left_attach">0</property>
-                        <property name="top_attach">0</property>
-                        <property name="width">1</property>
-                        <property name="height">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkComboBox" id="combo-tabletmode">
-                        <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="hexpand">True</property>
-                        <property name="model">liststore-tabletmode</property>
-                      </object>
-                      <packing>
-                        <property name="left_attach">1</property>
-                        <property name="top_attach">0</property>
-                        <property name="width">1</property>
-                        <property name="height">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="label-left-handed">
-                        <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="halign">end</property>
-                        <property name="valign">center</property>
-                        <property name="label" translatable="yes">Left-Handed Orientation</property>
-                        <style>
-                          <class name="dim-label-ucc"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left_attach">0</property>
-                        <property name="top_attach">1</property>
-                        <property name="width">1</property>
-                        <property name="height">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkSwitch" id="switch-left-handed">
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="halign">start</property>
-                        <property name="valign">center</property>
-                        <property name="use_action_appearance">False</property>
-                      </object>
-                      <packing>
-                        <property name="left_attach">1</property>
-                        <property name="top_attach">1</property>
-                        <property name="width">1</property>
-                        <property name="height">1</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="top_attach">1</property>
-                    <property name="width">1</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkNotebook" id="stylus-notebook">
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="vexpand">True</property>
-                    <property name="show_tabs">False</property>
-                  </object>
-                  <packing>
-                    <property name="left_attach">0</property>
-                    <property name="top_attach">4</property>
-                    <property name="width">2</property>
-                    <property name="height">1</property>
-                  </packing>
-                </child>
-              </object>
-              <packing>
-                <property name="position">1</property>
-              </packing>
-            </child>
-            <child type="tab">
-              <object class="GtkLabel" id="label1">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label">Wacom</property>
-              </object>
-              <packing>
-                <property name="position">1</property>
-                <property name="tab_fill">False</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">True</property>
-            <property name="fill">True</property>
-            <property name="position">1</property>
-          </packing>
-        </child>
-      </object>
-    </child>
-    <action-widgets>
-      <action-widget response="0">helpbutton1</action-widget>
-      <action-widget response="0">closebutton1</action-widget>
-    </action-widgets>
-  </object>
-</interface>
diff --git a/panels/wacom/gsd-enums.h b/panels/wacom/gsd-enums.h
deleted file mode 100644
index a5808fd..0000000
--- a/panels/wacom/gsd-enums.h
+++ /dev/null
@@ -1,7 +0,0 @@
-/* We copy gsd-wacom-device from gnome-settings-daemon.
- * It include "gsd-enums.h" because the include directory
- * is known. As gnome-settings-daemon's pkg-config file
- * prefixes this, we need a little help to avoid this
- * one line difference */
-
-#include <unity-settings-daemon/gsd-enums.h>
diff --git a/panels/wacom/gsd-input-helper.c b/panels/wacom/gsd-input-helper.c
deleted file mode 100644
index b81189d..0000000
--- a/panels/wacom/gsd-input-helper.c
+++ /dev/null
@@ -1,565 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2010 Bastien Nocera <hadess@hadess.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-#include "config.h"
-
-#include <string.h>
-
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-
-#include <sys/types.h>
-#include <X11/Xatom.h>
-#include <X11/extensions/XInput2.h>
-
-#include "gsd-input-helper.h"
-
-#define INPUT_DEVICES_SCHEMA "org.gnome.settings-daemon.peripherals.input-devices"
-#define KEY_HOTPLUG_COMMAND  "hotplug-command"
-
-typedef gboolean (* InfoIdentifyFunc) (XDeviceInfo *device_info);
-typedef gboolean (* DeviceIdentifyFunc) (XDevice *xdevice);
-
-gboolean
-device_set_property (XDevice        *xdevice,
-                     const char     *device_name,
-                     PropertyHelper *property)
-{
-        int rc, i;
-        Atom prop;
-        Atom realtype;
-        int realformat;
-        unsigned long nitems, bytes_after;
-        unsigned char *data;
-
-        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                            property->name, False);
-        if (!prop)
-                return FALSE;
-
-        gdk_error_trap_push ();
-
-        rc = XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                                 xdevice, prop, 0, property->nitems, False,
-                                 AnyPropertyType, &realtype, &realformat, &nitems,
-                                 &bytes_after, &data);
-
-        if (rc != Success ||
-            realtype != property->type ||
-            realformat != property->format ||
-            nitems < property->nitems) {
-                gdk_error_trap_pop_ignored ();
-                g_warning ("Error reading property \"%s\" for \"%s\"", property->name, device_name);
-                return FALSE;
-        }
-
-        for (i = 0; i < nitems; i++) {
-                switch (property->format) {
-                        case 8:
-                                data[i] = property->data.c[i];
-                                break;
-                        case 32:
-                                ((long*)data)[i] = property->data.i[i];
-                                break;
-                }
-        }
-
-        XChangeDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                               xdevice, prop, realtype, realformat,
-                               PropModeReplace, data, nitems);
-
-        XFree (data);
-
-        if (gdk_error_trap_pop ()) {
-                g_warning ("Error in setting \"%s\" for \"%s\"", property->name, device_name);
-                return FALSE;
-        }
-
-        return TRUE;
-}
-
-static gboolean
-supports_xinput_devices_with_opcode (int *opcode)
-{
-        gint op_code, event, error;
-        gboolean retval;
-
-        retval = XQueryExtension (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-				  "XInputExtension",
-				  &op_code,
-				  &event,
-				  &error);
-	if (opcode)
-		*opcode = op_code;
-
-	return retval;
-}
-
-gboolean
-supports_xinput_devices (void)
-{
-	return supports_xinput_devices_with_opcode (NULL);
-}
-
-gboolean
-supports_xinput2_devices (int *opcode)
-{
-        int major, minor;
-
-        if (supports_xinput_devices_with_opcode (opcode) == FALSE)
-                return FALSE;
-
-        gdk_error_trap_push ();
-
-        major = 2;
-        minor = 0;
-
-        if (XIQueryVersion (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &major, &minor) != Success) {
-                gdk_error_trap_pop_ignored ();
-                /* try for 2.2, maybe gtk has already announced 2.2 support */
-                gdk_error_trap_push ();
-                major = 2;
-                minor = 2;
-                if (XIQueryVersion (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &major, &minor) != Success) {
-                    gdk_error_trap_pop_ignored ();
-                    return FALSE;
-                }
-        }
-        gdk_error_trap_pop_ignored ();
-
-        if ((major * 1000 + minor) < (2000))
-                return FALSE;
-
-        return TRUE;
-}
-
-gboolean
-device_is_touchpad (XDevice *xdevice)
-{
-        Atom realtype, prop;
-        int realformat;
-        unsigned long nitems, bytes_after;
-        unsigned char *data;
-
-        /* we don't check on the type being XI_TOUCHPAD here,
-         * but having a "Synaptics Off" property should be enough */
-
-        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Synaptics Off", False);
-        if (!prop)
-                return FALSE;
-
-        gdk_error_trap_push ();
-        if ((XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdevice, prop, 0, 1, False,
-                                XA_INTEGER, &realtype, &realformat, &nitems,
-                                &bytes_after, &data) == Success) && (realtype != None)) {
-                gdk_error_trap_pop_ignored ();
-                XFree (data);
-                return TRUE;
-        }
-        gdk_error_trap_pop_ignored ();
-
-        return FALSE;
-}
-
-gboolean
-device_info_is_touchpad (XDeviceInfo *device_info)
-{
-        return (device_info->type == XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), XI_TOUCHPAD, False));
-}
-
-gboolean
-device_info_is_touchscreen (XDeviceInfo *device_info)
-{
-        return (device_info->type == XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), XI_TOUCHSCREEN, False));
-}
-
-gboolean
-device_info_is_tablet (XDeviceInfo *device_info)
-{
-        /* Note that this doesn't match Wacom tablets */
-        return (device_info->type == XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), XI_TABLET, False));
-}
-
-gboolean
-device_info_is_mouse (XDeviceInfo *device_info)
-{
-        return (device_info->type == XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), XI_MOUSE, False));
-}
-
-gboolean
-device_info_is_trackball (XDeviceInfo *device_info)
-{
-        gboolean retval;
-
-        retval = (device_info->type == XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), XI_TRACKBALL, False));
-        if (retval == FALSE &&
-            device_info->name != NULL) {
-                char *lowercase;
-
-                lowercase = g_ascii_strdown (device_info->name, -1);
-                retval = strstr (lowercase, "trackball") != NULL;
-                g_free (lowercase);
-        }
-
-        return retval;
-}
-
-static gboolean
-device_type_is_present (InfoIdentifyFunc info_func,
-                        DeviceIdentifyFunc device_func)
-{
-        XDeviceInfo *device_info;
-        gint n_devices;
-        guint i;
-        gboolean retval;
-
-        if (supports_xinput_devices () == FALSE)
-                return TRUE;
-
-        retval = FALSE;
-
-        device_info = XListInputDevices (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &n_devices);
-        if (device_info == NULL)
-                return FALSE;
-
-        for (i = 0; i < n_devices; i++) {
-                XDevice *device;
-
-                /* Check with the device info first */
-                retval = (info_func) (&device_info[i]);
-                if (retval == FALSE)
-                        continue;
-
-                /* If we only have an info func, we're done checking */
-                if (device_func == NULL)
-                        break;
-
-                gdk_error_trap_push ();
-                device = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device_info[i].id);
-                if (gdk_error_trap_pop () || (device == NULL))
-                        continue;
-
-                retval = (device_func) (device);
-                if (retval) {
-                        XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device);
-                        break;
-                }
-
-                XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device);
-        }
-        XFreeDeviceList (device_info);
-
-        return retval;
-}
-
-gboolean
-touchscreen_is_present (void)
-{
-        return device_type_is_present (device_info_is_touchscreen,
-                                       NULL);
-}
-
-gboolean
-touchpad_is_present (void)
-{
-        return device_type_is_present (device_info_is_touchpad,
-                                       device_is_touchpad);
-}
-
-gboolean
-mouse_is_present (void)
-{
-        return device_type_is_present (device_info_is_mouse,
-                                       NULL);
-}
-
-gboolean
-trackball_is_present (void)
-{
-        return device_type_is_present (device_info_is_trackball,
-                                       NULL);
-}
-
-char *
-xdevice_get_device_node (int deviceid)
-{
-        Atom           prop;
-        Atom           act_type;
-        int            act_format;
-        unsigned long  nitems, bytes_after;
-        unsigned char *data;
-        char          *ret;
-
-        gdk_display_sync (gdk_display_get_default ());
-
-        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Device Node", False);
-        if (!prop)
-                return NULL;
-
-        gdk_error_trap_push ();
-
-        if (!XIGetProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                            deviceid, prop, 0, 1000, False,
-                            AnyPropertyType, &act_type, &act_format,
-                            &nitems, &bytes_after, &data) == Success) {
-                gdk_error_trap_pop_ignored ();
-                return NULL;
-        }
-        if (gdk_error_trap_pop ())
-                goto out;
-
-        if (nitems == 0)
-                goto out;
-
-        if (act_type != XA_STRING)
-                goto out;
-
-        /* Unknown string format */
-        if (act_format != 8)
-                goto out;
-
-        ret = g_strdup ((char *) data);
-
-        XFree (data);
-        return ret;
-
-out:
-        XFree (data);
-        return NULL;
-}
-
-#define TOOL_ID_FORMAT_SIZE 32
-static int
-get_id_for_index (guchar *data,
-		  guint   idx)
-{
-	guchar *ptr;
-	int id;
-
-	ptr = data;
-	ptr += TOOL_ID_FORMAT_SIZE / 8 * idx;
-
-	id = *((int32_t*)ptr);
-	id = id & 0xfffff;
-
-	return id;
-}
-
-
-#define STYLUS_DEVICE_ID        0x02
-#define ERASER_DEVICE_ID        0x0A
-
-int
-xdevice_get_last_tool_id (int  deviceid)
-{
-        Atom           prop;
-        Atom           act_type;
-        int            act_format;
-        unsigned long  nitems, bytes_after;
-        unsigned char *data;
-        int            id;
-
-        id = -1;
-
-        gdk_display_sync (gdk_display_get_default ());
-
-        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), WACOM_SERIAL_IDS_PROP, False);
-        if (!prop)
-                return -1;
-
-        data = NULL;
-
-        gdk_error_trap_push ();
-
-        if (XIGetProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                            deviceid, prop, 0, 1000, False,
-                            AnyPropertyType, &act_type, &act_format,
-                            &nitems, &bytes_after, &data) != Success) {
-                gdk_error_trap_pop_ignored ();
-                goto out;
-        }
-
-        if (gdk_error_trap_pop ())
-                goto out;
-
-	if (nitems != 4 && nitems != 5)
-		goto out;
-
-	if (act_type != XA_INTEGER)
-		goto out;
-
-	if (act_format != TOOL_ID_FORMAT_SIZE)
-		goto out;
-
-	/* item 0 = tablet ID
-	 * item 1 = old device serial number (== last tool in proximity)
-	 * item 2 = old hardware serial number (including tool ID)
-	 * item 3 = current serial number (0 if no tool in proximity)
-	 * item 4 = current tool ID (since Feb 2012)
-	 *
-	 * Get the current tool ID first, if available, then the old one */
-	id = 0x0;
-	if (nitems == 5)
-		id = get_id_for_index (data, 4);
-	if (id == 0x0)
-		id = get_id_for_index (data, 2);
-
-	/* That means that no tool was set down yet */
-	if (id == STYLUS_DEVICE_ID ||
-	    id == ERASER_DEVICE_ID)
-		id = 0x0;
-
-out:
-        if (data != NULL)
-                XFree (data);
-        return id;
-}
-
-gboolean
-set_device_enabled (int device_id,
-                    gboolean enabled)
-{
-        Atom prop;
-        guchar value;
-
-        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Device Enabled", False);
-        if (!prop)
-                return FALSE;
-
-        gdk_error_trap_push ();
-
-        value = enabled ? 1 : 0;
-        XIChangeProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                          device_id, prop, XA_INTEGER, 8, PropModeReplace, &value, 1);
-
-        if (gdk_error_trap_pop ())
-                return FALSE;
-
-        return TRUE;
-}
-
-static const char *
-custom_command_to_string (CustomCommand command)
-{
-        switch (command) {
-        case COMMAND_DEVICE_ADDED:
-                return "added";
-        case COMMAND_DEVICE_REMOVED:
-                return "removed";
-        case COMMAND_DEVICE_PRESENT:
-                return "present";
-        default:
-                g_assert_not_reached ();
-        }
-}
-
-/* Run a custom command on device presence events. Parameters passed into
- * the custom command are:
- * command -t [added|removed|present] -i <device ID> <device name>
- * Type 'added' and 'removed' signal 'device added' and 'device removed',
- * respectively. Type 'present' signals 'device present at
- * gnome-settings-daemon init'.
- *
- * The script is expected to run synchronously, and an exit value
- * of "1" means that no other settings will be applied to this
- * particular device.
- *
- * More options may be added in the future.
- *
- * This function returns TRUE if we should not apply any more settings
- * to the device.
- */
-gboolean
-run_custom_command (GdkDevice              *device,
-                    CustomCommand           command)
-{
-        GSettings *settings;
-        char *cmd;
-        char *argv[7];
-        int exit_status;
-        gboolean rc;
-        int id;
-
-        settings = g_settings_new (INPUT_DEVICES_SCHEMA);
-        cmd = g_settings_get_string (settings, KEY_HOTPLUG_COMMAND);
-        g_object_unref (settings);
-
-        if (!cmd || cmd[0] == '\0') {
-                g_free (cmd);
-                return FALSE;
-        }
-
-        /* Easter egg! */
-        g_object_get (device, "device-id", &id, NULL);
-
-        argv[0] = cmd;
-        argv[1] = "-t";
-        argv[2] = (char *) custom_command_to_string (command);
-        argv[3] = "-i";
-        argv[4] = g_strdup_printf ("%d", id);
-        argv[5] = (char*) gdk_device_get_name (device);
-        argv[6] = NULL;
-
-        rc = g_spawn_sync (g_get_home_dir (), argv, NULL, G_SPAWN_SEARCH_PATH,
-                           NULL, NULL, NULL, NULL, &exit_status, NULL);
-
-        if (rc == FALSE)
-                g_warning ("Couldn't execute command '%s', verify that this is a valid command.", cmd);
-
-        g_free (argv[0]);
-        g_free (argv[4]);
-
-        return (exit_status == 1);
-}
-
-GList *
-get_disabled_devices (GdkDeviceManager *manager)
-{
-        XDeviceInfo *device_info;
-        gint n_devices;
-        guint i;
-        GList *ret;
-
-        ret = NULL;
-
-        device_info = XListInputDevices (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &n_devices);
-        if (device_info == NULL)
-                return ret;
-
-        for (i = 0; i < n_devices; i++) {
-                GdkDevice *device;
-
-                /* Ignore core devices */
-                if (device_info[i].use == IsXKeyboard ||
-                    device_info[i].use == IsXPointer)
-                        continue;
-
-                /* Check whether the device is actually available */
-                device = gdk_x11_device_manager_lookup (manager, device_info[i].id);
-                if (device != NULL)
-                        continue;
-
-                ret = g_list_prepend (ret, GINT_TO_POINTER (device_info[i].id));
-        }
-
-        XFreeDeviceList (device_info);
-
-        return ret;
-}
diff --git a/panels/wacom/gsd-input-helper.h b/panels/wacom/gsd-input-helper.h
deleted file mode 100644
index b93b90c..0000000
--- a/panels/wacom/gsd-input-helper.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2010 Bastien Nocera <hadess@hadess.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GSD_INPUT_HELPER_H
-#define __GSD_INPUT_HELPER_H
-
-G_BEGIN_DECLS
-
-#include <glib.h>
-
-#include <X11/extensions/XInput.h>
-#include <X11/extensions/XIproto.h>
-
-#define WACOM_SERIAL_IDS_PROP "Wacom Serial IDs"
-
-typedef enum {
-        COMMAND_DEVICE_ADDED,
-        COMMAND_DEVICE_REMOVED,
-        COMMAND_DEVICE_PRESENT
-} CustomCommand;
-
-/* Generic property setting code. Fill up the struct property with the property
- * data and pass it into device_set_property together with the device to be
- * changed.  Note: doesn't cater for non-zero offsets yet, but we don't have
- * any settings that require that.
- */
-typedef struct {
-        const char *name;       /* property name */
-        gint nitems;            /* number of items in data */
-        gint format;            /* CARD8 or CARD32 sized-items */
-        gint type;              /* Atom representing data type */
-        union {
-                const gchar *c; /* 8 bit data */
-                const gint *i;  /* 32 bit data */
-        } data;
-} PropertyHelper;
-
-gboolean  supports_xinput_devices  (void);
-gboolean  supports_xinput2_devices (int *opcode);
-
-gboolean set_device_enabled       (int device_id,
-                                   gboolean enabled);
-
-gboolean  device_is_touchpad       (XDevice                *xdevice);
-
-gboolean  device_info_is_touchpad    (XDeviceInfo         *device_info);
-gboolean  device_info_is_touchscreen (XDeviceInfo         *device_info);
-gboolean  device_info_is_tablet (XDeviceInfo         *device_info);
-gboolean  device_info_is_mouse       (XDeviceInfo         *device_info);
-gboolean  device_info_is_trackball   (XDeviceInfo         *device_info);
-
-gboolean  touchpad_is_present     (void);
-gboolean  touchscreen_is_present  (void);
-gboolean  mouse_is_present        (void);
-gboolean  trackball_is_present    (void);
-
-gboolean  device_set_property     (XDevice                *xdevice,
-                                   const char             *device_name,
-                                   PropertyHelper         *property);
-
-gboolean  run_custom_command      (GdkDevice              *device,
-                                   CustomCommand           command);
-
-GList *   get_disabled_devices     (GdkDeviceManager       *manager);
-char *    xdevice_get_device_node  (int                     deviceid);
-int       xdevice_get_last_tool_id (int                     deviceid);
-
-G_END_DECLS
-
-#endif /* __GSD_INPUT_HELPER_H */
diff --git a/panels/wacom/gsd-wacom-device.c b/panels/wacom/gsd-wacom-device.c
deleted file mode 100644
index 28d6e4d..0000000
--- a/panels/wacom/gsd-wacom-device.c
+++ /dev/null
@@ -1,2185 +0,0 @@
-/*
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#include "config.h"
-
-#include <glib.h>
-#include <glib/gi18n-lib.h>
-#include <gtk/gtk.h>
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include <X11/Xatom.h>
-#define GNOME_DESKTOP_USE_UNSTABLE_API
-#include <libgnome-desktop/gnome-rr.h>
-
-#include <libwacom/libwacom.h>
-#include <X11/extensions/XInput.h>
-#include <X11/extensions/XInput2.h>
-
-#include "gsd-input-helper.h"
-
-#include "gsd-enums.h"
-#include "gsd-wacom-device.h"
-
-#define GSD_WACOM_STYLUS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusPrivate))
-
-#define WACOM_TABLET_SCHEMA "org.gnome.settings-daemon.peripherals.wacom"
-#define WACOM_DEVICE_CONFIG_BASE "/org/gnome/settings-daemon/peripherals/wacom/%s-%s/"
-#define WACOM_STYLUS_SCHEMA "org.gnome.settings-daemon.peripherals.wacom.stylus"
-#define WACOM_ERASER_SCHEMA "org.gnome.settings-daemon.peripherals.wacom.eraser"
-#define WACOM_BUTTON_SCHEMA "org.gnome.settings-daemon.peripherals.wacom.tablet-button"
-
-static struct {
-	GnomeRRRotation  rotation;
-	GsdWacomRotation rotation_wacom;
-	const gchar     *rotation_string;
-} rotation_table[] = {
-	{ GNOME_RR_ROTATION_0,   GSD_WACOM_ROTATION_NONE, "none" },
-	{ GNOME_RR_ROTATION_90,  GSD_WACOM_ROTATION_CCW,  "ccw"  },
-	{ GNOME_RR_ROTATION_180, GSD_WACOM_ROTATION_HALF, "half" },
-	{ GNOME_RR_ROTATION_270, GSD_WACOM_ROTATION_CW,   "cw"   }
-};
-
-static WacomDeviceDatabase *db = NULL;
-
-struct GsdWacomStylusPrivate
-{
-	GsdWacomDevice *device;
-	int id;
-	WacomStylusType type;
-	char *name;
-	const char *icon_name;
-	GSettings *settings;
-	gboolean has_eraser;
-	int num_buttons;
-};
-
-static void     gsd_wacom_stylus_class_init  (GsdWacomStylusClass *klass);
-static void     gsd_wacom_stylus_init        (GsdWacomStylus      *wacom_stylus);
-static void     gsd_wacom_stylus_finalize    (GObject              *object);
-
-G_DEFINE_TYPE (GsdWacomStylus, gsd_wacom_stylus, G_TYPE_OBJECT)
-
-static void
-gsd_wacom_stylus_class_init (GsdWacomStylusClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->finalize = gsd_wacom_stylus_finalize;
-
-        g_type_class_add_private (klass, sizeof (GsdWacomStylusPrivate));
-}
-
-static void
-gsd_wacom_stylus_init (GsdWacomStylus *stylus)
-{
-        stylus->priv = GSD_WACOM_STYLUS_GET_PRIVATE (stylus);
-}
-
-static void
-gsd_wacom_stylus_finalize (GObject *object)
-{
-        GsdWacomStylus *stylus;
-        GsdWacomStylusPrivate *p;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSD_IS_WACOM_STYLUS (object));
-
-        stylus = GSD_WACOM_STYLUS (object);
-
-        g_return_if_fail (stylus->priv != NULL);
-
-	p = stylus->priv;
-
-        if (p->settings != NULL) {
-                g_object_unref (p->settings);
-                p->settings = NULL;
-        }
-
-        g_free (p->name);
-        p->name = NULL;
-
-        G_OBJECT_CLASS (gsd_wacom_stylus_parent_class)->finalize (object);
-}
-
-static const char *
-get_icon_name_from_type (WacomStylusType type)
-{
-	switch (type) {
-	case WSTYLUS_INKING:
-	case WSTYLUS_STROKE:
-		/* The stroke pen is the same as the inking pen with
-		 * a different nib */
-		return "wacom-stylus-inking";
-	case WSTYLUS_AIRBRUSH:
-		return "wacom-stylus-airbrush";
-	case WSTYLUS_MARKER:
-		return "wacom-stylus-art-pen";
-	case WSTYLUS_CLASSIC:
-		return "wacom-stylus-classic";
-	default:
-		return "wacom-stylus";
-	}
-}
-
-static GsdWacomStylus *
-gsd_wacom_stylus_new (GsdWacomDevice    *device,
-		      const WacomStylus *wstylus,
-		      GSettings         *settings)
-{
-	GsdWacomStylus *stylus;
-
-	g_return_val_if_fail (G_IS_SETTINGS (settings), NULL);
-	g_return_val_if_fail (wstylus != NULL, NULL);
-
-	stylus = GSD_WACOM_STYLUS (g_object_new (GSD_TYPE_WACOM_STYLUS,
-						 NULL));
-	stylus->priv->device = device;
-	stylus->priv->id = libwacom_stylus_get_id (wstylus);
-	stylus->priv->name = g_strdup (libwacom_stylus_get_name (wstylus));
-	stylus->priv->settings = settings;
-	stylus->priv->type = libwacom_stylus_get_type (wstylus);
-	stylus->priv->icon_name = get_icon_name_from_type (stylus->priv->type);
-	stylus->priv->has_eraser = libwacom_stylus_has_eraser (wstylus);
-	stylus->priv->num_buttons = libwacom_stylus_get_num_buttons (wstylus);
-
-	return stylus;
-}
-
-GSettings *
-gsd_wacom_stylus_get_settings (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	return stylus->priv->settings;
-}
-
-const char *
-gsd_wacom_stylus_get_name (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	return stylus->priv->name;
-}
-
-const char *
-gsd_wacom_stylus_get_icon_name (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	return stylus->priv->icon_name;
-}
-
-GsdWacomDevice *
-gsd_wacom_stylus_get_device (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
-
-	return stylus->priv->device;
-}
-
-gboolean
-gsd_wacom_stylus_get_has_eraser (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), FALSE);
-
-	return stylus->priv->has_eraser;
-}
-
-guint
-gsd_wacom_stylus_get_num_buttons (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), -1);
-
-	return stylus->priv->num_buttons;
-}
-
-GsdWacomStylusType
-gsd_wacom_stylus_get_stylus_type (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), WACOM_STYLUS_TYPE_UNKNOWN);
-
-	switch (stylus->priv->type) {
-	case WSTYLUS_UNKNOWN:
-		return WACOM_STYLUS_TYPE_UNKNOWN;
-	case WSTYLUS_GENERAL:
-		return WACOM_STYLUS_TYPE_GENERAL;
-	case WSTYLUS_INKING:
-		return WACOM_STYLUS_TYPE_INKING;
-	case WSTYLUS_AIRBRUSH:
-		return WACOM_STYLUS_TYPE_AIRBRUSH;
-	case WSTYLUS_CLASSIC:
-		return WACOM_STYLUS_TYPE_CLASSIC;
-	case WSTYLUS_MARKER:
-		return WACOM_STYLUS_TYPE_MARKER;
-	case WSTYLUS_STROKE:
-		return WACOM_STYLUS_TYPE_STROKE;
-	case WSTYLUS_PUCK:
-		return WACOM_STYLUS_TYPE_PUCK;
-	default:
-		g_assert_not_reached ();
-	}
-
-	return WACOM_STYLUS_TYPE_UNKNOWN;
-}
-
-int
-gsd_wacom_stylus_get_id (GsdWacomStylus *stylus)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), -1);
-
-	return stylus->priv->id;
-}
-
-/* Tablet buttons */
-static GsdWacomTabletButton *
-gsd_wacom_tablet_button_new (const char               *name,
-			     const char               *id,
-			     const char               *settings_path,
-			     GsdWacomTabletButtonType  type,
-			     GsdWacomTabletButtonPos   pos,
-			     int                       group_id,
-			     int                       idx,
-			     int                       status_led)
-{
-	GsdWacomTabletButton *ret;
-
-	ret = g_new0 (GsdWacomTabletButton, 1);
-	ret->name = g_strdup (name);
-	ret->id = g_strdup (id);
-	if (type != WACOM_TABLET_BUTTON_TYPE_HARDCODED) {
-		char *button_settings_path;
-
-		button_settings_path = g_strdup_printf ("%s%s/", settings_path, id);
-		ret->settings = g_settings_new_with_path (WACOM_BUTTON_SCHEMA, button_settings_path);
-		g_free (button_settings_path);
-	}
-	ret->group_id = group_id;
-	ret->idx = idx;
-	ret->type = type;
-	ret->pos = pos;
-	ret->status_led = status_led;
-
-	return ret;
-}
-
-void
-gsd_wacom_tablet_button_free (GsdWacomTabletButton *button)
-{
-	g_return_if_fail (button != NULL);
-
-	if (button->settings != NULL)
-		g_object_unref (button->settings);
-	g_free (button->name);
-	g_free (button->id);
-	g_free (button);
-}
-
-GsdWacomTabletButton *
-gsd_wacom_tablet_button_copy (GsdWacomTabletButton *button)
-{
-	GsdWacomTabletButton *ret;
-
-	g_return_val_if_fail (button != NULL, NULL);
-
-	ret = g_new0 (GsdWacomTabletButton, 1);
-	ret->name = g_strdup (button->name);
-	if (button->settings != NULL)
-		ret->settings = g_object_ref (button->settings);
-	ret->id = button->id;
-	ret->type = button->type;
-	ret->group_id = button->group_id;
-
-	return ret;
-}
-
-#define GSD_WACOM_DEVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDevicePrivate))
-
-/* we support two types of settings:
- * Tablet-wide settings: applied to each tool on the tablet. e.g. rotation
- * Tool-specific settings: applied to one tool only.
- */
-#define SETTINGS_WACOM_DIR         "org.gnome.settings-daemon.peripherals.wacom"
-#define SETTINGS_STYLUS_DIR        "stylus"
-#define SETTINGS_ERASER_DIR        "eraser"
-
-struct GsdWacomDevicePrivate
-{
-	GdkDevice *gdk_device;
-	int device_id;
-	int opcode;
-
-	GsdWacomDeviceType type;
-	char *name;
-	char *path;
-	char *machine_id;
-	const char *icon_name;
-	char *layout_path;
-	char *tool_name;
-	gboolean reversible;
-	gboolean is_screen_tablet;
-	gboolean is_isd; /* integrated system device */
-	gboolean is_fallback;
-	GList *styli;
-	GsdWacomStylus *last_stylus;
-	GList *buttons;
-	gint num_rings;
-	gint num_strips;
-	GHashTable *modes; /* key = int (group), value = int (index) */
-	GHashTable *num_modes; /* key = int (group), value = int (index) */
-	GSettings *wacom_settings;
-};
-
-enum {
-	PROP_0,
-	PROP_GDK_DEVICE,
-	PROP_LAST_STYLUS
-};
-
-static void     gsd_wacom_device_class_init  (GsdWacomDeviceClass *klass);
-static void     gsd_wacom_device_init        (GsdWacomDevice      *wacom_device);
-static void     gsd_wacom_device_finalize    (GObject              *object);
-
-G_DEFINE_TYPE (GsdWacomDevice, gsd_wacom_device, G_TYPE_OBJECT)
-
-static GdkFilterReturn
-filter_events (XEvent         *xevent,
-               GdkEvent       *event,
-               GsdWacomDevice *device)
-{
-	XIEvent             *xiev;
-	XIPropertyEvent     *pev;
-	XGenericEventCookie *cookie;
-	char                *name;
-	int                  tool_id;
-
-        /* verify we have a property event */
-	if (xevent->type != GenericEvent)
-		return GDK_FILTER_CONTINUE;
-
-	cookie = &xevent->xcookie;
-	if (cookie->extension != device->priv->opcode)
-		return GDK_FILTER_CONTINUE;
-
-	xiev = (XIEvent *) xevent->xcookie.data;
-
-	if (xiev->evtype != XI_PropertyEvent)
-		return GDK_FILTER_CONTINUE;
-
-	pev = (XIPropertyEvent *) xiev;
-
-	/* Is the event for us? */
-	if (pev->deviceid != device->priv->device_id)
-		return GDK_FILTER_CONTINUE;
-
-	name = XGetAtomName (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), pev->property);
-	if (name == NULL ||
-	    g_strcmp0 (name, WACOM_SERIAL_IDS_PROP) != 0) {
-		if (name)
-			XFree (name);
-		return GDK_FILTER_CONTINUE;
-	}
-	XFree (name);
-
-	tool_id = xdevice_get_last_tool_id (device->priv->device_id);
-	if (tool_id == -1) {
-		g_warning ("Failed to get value for changed stylus ID on device '%d'", device->priv->device_id);
-		return GDK_FILTER_CONTINUE;
-	}
-	gsd_wacom_device_set_current_stylus (device, tool_id);
-
-	return GDK_FILTER_CONTINUE;
-}
-
-static gboolean
-setup_property_notify (GsdWacomDevice *device)
-{
-	Display *dpy;
-	XIEventMask evmask;
-	int tool_id;
-
-	evmask.deviceid = device->priv->device_id;
-	evmask.mask_len = XIMaskLen (XI_PropertyEvent);
-	evmask.mask = g_new0 (guchar, evmask.mask_len);
-	XISetMask (evmask.mask, XI_PropertyEvent);
-
-	dpy = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-	XISelectEvents (dpy, DefaultRootWindow (dpy), &evmask, 1);
-
-	g_free (evmask.mask);
-
-	gdk_window_add_filter (NULL,
-			       (GdkFilterFunc) filter_events,
-			       device);
-
-	tool_id = xdevice_get_last_tool_id (device->priv->device_id);
-	if (tool_id == -1) {
-		g_warning ("Failed to get value for changed stylus ID on device '%d", device->priv->device_id);
-		return TRUE;
-	}
-	gsd_wacom_device_set_current_stylus (device, tool_id);
-
-	return TRUE;
-}
-
-static GsdWacomDeviceType
-get_device_type (XDeviceInfo *dev)
-{
-	GsdWacomDeviceType ret;
-        static Atom stylus, cursor, eraser, pad, touch, prop;
-        XDevice *device;
-        Atom realtype;
-        int realformat;
-        unsigned long nitems, bytes_after;
-        unsigned char *data = NULL;
-        int rc;
-
-        ret = WACOM_TYPE_INVALID;
-
-        if ((dev->use == IsXPointer) || (dev->use == IsXKeyboard))
-                return ret;
-
-        if (!stylus)
-                stylus = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "STYLUS", False);
-        if (!eraser)
-                eraser = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "ERASER", False);
-        if (!cursor)
-                cursor = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "CURSOR", False);
-        if (!pad)
-                pad = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "PAD", False);
-        if (!touch)
-                touch = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "TOUCH", False);
-        if (!prop)
-		prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Wacom Tool Type", False);
-
-	if (dev->type == stylus)
-		ret = WACOM_TYPE_STYLUS;
-	else if (dev->type == eraser)
-		ret = WACOM_TYPE_ERASER;
-	else if (dev->type == cursor)
-		ret = WACOM_TYPE_CURSOR;
-	else if (dev->type == pad)
-		ret = WACOM_TYPE_PAD;
-	else if (dev->type == touch)
-		ret = WACOM_TYPE_TOUCH;
-
-	if (ret == WACOM_TYPE_INVALID)
-		return ret;
-
-        /* There is currently no good way of detecting the driver for a device
-         * other than checking for a driver-specific property.
-         * Wacom Tool Type exists on all tools
-         */
-        gdk_error_trap_push ();
-        device = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), dev->id);
-        if (gdk_error_trap_pop () || (device == NULL))
-                return ret;
-
-        gdk_error_trap_push ();
-
-        rc = XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                                 device, prop, 0, 1, False,
-                                 XA_ATOM, &realtype, &realformat, &nitems,
-                                 &bytes_after, &data);
-        XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device);
-
-        if (gdk_error_trap_pop () || rc != Success || realtype == None)
-                ret = WACOM_TYPE_INVALID;
-
-        XFree (data);
-
-	return ret;
-}
-
-/* Finds an output which matches the given EDID information. Any NULL
- * parameter will be interpreted to match any value. */
-static GnomeRROutput *
-find_output_by_edid (GnomeRRScreen *rr_screen, const gchar *vendor, const gchar *product, const gchar *serial)
-{
-	GnomeRROutput **rr_outputs;
-	GnomeRROutput *retval = NULL;
-	guint i;
-
-	rr_outputs = gnome_rr_screen_list_outputs (rr_screen);
-
-	for (i = 0; rr_outputs[i] != NULL; i++) {
-		gchar *o_vendor_s;
-		gchar *o_product_s;
-		int o_product;
-		gchar *o_serial_s;
-		int o_serial;
-		gboolean match;
-
-		if (!gnome_rr_output_is_connected (rr_outputs[i]))
-			continue;
-
-		if (!gnome_rr_output_get_ids_from_edid (rr_outputs[i],
-						        &o_vendor_s,
-						        &o_product,
-						        &o_serial))
-			continue;
-
-		o_product_s = g_strdup_printf ("%d", o_product);
-		o_serial_s  = g_strdup_printf ("%d", o_serial);
-
-		g_debug ("Checking for match between '%s','%s','%s' and '%s','%s','%s'", \
-		         vendor, product, serial, o_vendor_s, o_product_s, o_serial_s);
-
-		match = (vendor  == NULL || g_strcmp0 (vendor,  o_vendor_s)  == 0) && \
-		        (product == NULL || g_strcmp0 (product, o_product_s) == 0) && \
-		        (serial  == NULL || g_strcmp0 (serial,  o_serial_s)  == 0);
-
-		g_free (o_vendor_s);
-		g_free (o_product_s);
-		g_free (o_serial_s);
-
-		if (match) {
-			retval = rr_outputs[i];
-			break;
-		}
-	}
-
-	if (retval == NULL)
-		g_debug ("Did not find a matching output for EDID '%s,%s,%s'",
-			 vendor, product, serial);
-
-	return retval;
-}
-
-static GnomeRROutput*
-find_builtin_output (GnomeRRScreen *rr_screen)
-{
-	GnomeRROutput **rr_outputs;
-	GnomeRROutput *retval = NULL;
-	guint i;
-
-	rr_outputs = gnome_rr_screen_list_outputs (rr_screen);
-	for (i = 0; rr_outputs[i] != NULL; i++) {
-		if (!gnome_rr_output_is_connected (rr_outputs[i]))
-			continue;
-
-		if (gnome_rr_output_is_laptop(rr_outputs[i])) {
-			retval = rr_outputs[i];
-			break;
-		}
-	}
-
-	if (retval == NULL)
-		g_debug ("Did not find a built-in monitor");
-
-	return retval;
-}
-
-static GnomeRROutput *
-find_output_by_heuristic (GnomeRRScreen *rr_screen, GsdWacomDevice *device)
-{
-	GnomeRROutput *rr_output;
-
-	/* TODO: This heuristic will fail for non-Wacom display
-	 * tablets and may give the wrong result if multiple Wacom
-	 * display tablets are connected.
-	 */
-	rr_output = find_output_by_edid (rr_screen, "WAC", NULL, NULL);
-
-	if (!rr_output)
-		rr_output = find_builtin_output (rr_screen);
-
-	return rr_output;
-}
-
-static GnomeRROutput *
-find_output_by_display (GnomeRRScreen *rr_screen, GsdWacomDevice *device)
-{
-	gsize n;
-	GSettings *tablet;
-	GVariant *display;
-	const gchar **edid;
-	GnomeRROutput *ret;
-
-	if (device == NULL)
-		return NULL;
-
-	ret      = NULL;
-	tablet   = device->priv->wacom_settings;
-	display  = g_settings_get_value (tablet, "display");
-	edid     = g_variant_get_strv (display, &n);
-
-	if (n != 3) {
-		g_critical ("Expected 'display' key to store %d values; got %"G_GSIZE_FORMAT".", 3, n);
-		goto out;
-	}
-
-	if (strlen (edid[0]) == 0 || strlen (edid[1]) == 0 || strlen (edid[2]) == 0)
-		goto out;
-
-	ret = find_output_by_edid (rr_screen, edid[0], edid[1], edid[2]);
-
-out:
-	g_free (edid);
-	g_variant_unref (display);
-
-	return ret;
-}
-
-static gboolean
-is_on (GnomeRROutput *output)
-{
-	GnomeRRCrtc *crtc;
-
-	crtc = gnome_rr_output_get_crtc (output);
-	if (!crtc)
-		return FALSE;
-	return gnome_rr_crtc_get_current_mode (crtc) != NULL;
-}
-
-static GnomeRROutput *
-find_output_by_monitor (GnomeRRScreen *rr_screen,
-			GdkScreen     *screen,
-			int            monitor)
-{
-	GnomeRROutput **rr_outputs;
-	GnomeRROutput *ret;
-	guint i;
-
-	ret = NULL;
-
-	rr_outputs = gnome_rr_screen_list_outputs (rr_screen);
-
-	for (i = 0; rr_outputs[i] != NULL; i++) {
-		GnomeRROutput *rr_output;
-		GnomeRRCrtc *crtc;
-		int x, y;
-
-		rr_output = rr_outputs[i];
-
-		if (!is_on (rr_output))
-			continue;
-
-		crtc = gnome_rr_output_get_crtc (rr_output);
-		if (!crtc)
-			continue;
-
-		gnome_rr_crtc_get_position (crtc, &x, &y);
-
-		if (monitor == gdk_screen_get_monitor_at_point (screen, x, y)) {
-			ret = rr_output;
-			break;
-		}
-	}
-
-	if (ret == NULL)
-		g_warning ("No output found for monitor %d.", monitor);
-
-	return ret;
-}
-
-static void
-set_display_by_output (GsdWacomDevice  *device,
-                       GnomeRROutput   *rr_output)
-{
-	GSettings   *tablet;
-	GVariant    *c_array;
-	GVariant    *n_array;
-	gsize        nvalues;
-	gchar       *o_vendor_s, *o_product_s, *o_serial_s;
-	int          o_product, o_serial;
-	const gchar *values[3];
-
-	tablet  = gsd_wacom_device_get_settings (device);
-	c_array = g_settings_get_value (tablet, "display");
-	g_variant_get_strv (c_array, &nvalues);
-	if (nvalues != 3) {
-		g_warning ("Unable set set display property. Got %"G_GSIZE_FORMAT" items; expected %d items.\n", nvalues, 4);
-		return;
-	}
-
-	if (rr_output == NULL ||
-	    !gnome_rr_output_get_ids_from_edid (rr_output,
-					        &o_vendor_s,
-					        &o_product,
-					        &o_serial)) {
-		o_vendor_s  = g_strdup ("");
-		o_product_s = g_strdup ("");
-		o_serial_s  = g_strdup ("");
-	} else {
-		o_product_s = g_strdup_printf ("%d", o_product);
-		o_serial_s  = g_strdup_printf ("%d", o_serial);
-	}
-
-	values[0] = o_vendor_s;
-	values[1] = o_product_s;
-	values[2] = o_serial_s;
-	n_array = g_variant_new_strv ((const gchar * const *) &values, 3);
-	g_settings_set_value (tablet, "display", n_array);
-
-	g_free (o_vendor_s);
-	g_free (o_product_s);
-	g_free (o_serial_s);
-}
-
-static GsdWacomRotation
-get_rotation_wacom (GnomeRRRotation rotation)
-{
-        guint i;
-
-        for (i = 0; i < G_N_ELEMENTS (rotation_table); i++) {
-                if (rotation_table[i].rotation & rotation)
-                        return (rotation_table[i].rotation_wacom);
-        }
-        g_assert_not_reached ();
-}
-
-void
-gsd_wacom_device_set_display (GsdWacomDevice *device,
-                              int             monitor)
-{
-	GError *error = NULL;
-	GnomeRRScreen *rr_screen;
-	GnomeRROutput *output = NULL;
-
-        g_return_if_fail (GSD_IS_WACOM_DEVICE (device));
-
-	rr_screen = gnome_rr_screen_new (gdk_screen_get_default (), &error);
-	if (rr_screen == NULL) {
-		g_warning ("Failed to create GnomeRRScreen: %s", error->message);
-		g_error_free (error);
-		return;
-	}
-
-	if (monitor > GSD_WACOM_SET_ALL_MONITORS)
-		output = find_output_by_monitor (rr_screen, gdk_screen_get_default (), monitor);
-	set_display_by_output (device, output);
-
-	g_object_unref (rr_screen);
-}
-
-static GnomeRROutput *
-find_output (GnomeRRScreen  *rr_screen,
-	     GsdWacomDevice *device)
-{
-	GnomeRROutput *rr_output;
-	rr_output = find_output_by_display (rr_screen, device);
-
-	if (rr_output == NULL) {
-		if (gsd_wacom_device_is_screen_tablet (device)) {
-			rr_output = find_output_by_heuristic (rr_screen, device);
-			if (rr_output == NULL)
-				g_warning ("No fuzzy match based on heuristics was found.");
-			else
-				g_warning ("Automatically mapping tablet to heuristically-found display.");
-		}
-	}
-
-	return rr_output;
-}
-
-static void
-calculate_transformation_matrix (const GdkRectangle mapped, const GdkRectangle desktop, float matrix[NUM_ELEMS_MATRIX])
-{
-	float x_scale = (float)mapped.x / desktop.width;
-	float y_scale = (float)mapped.y / desktop.height;
-	float width_scale  = (float)mapped.width / desktop.width;
-	float height_scale = (float)mapped.height / desktop.height;
-
-	matrix[0] = width_scale;
-	matrix[1] = 0.0f;
-	matrix[2] = x_scale;
-
-	matrix[3] = 0.0f;
-	matrix[4] = height_scale;
-	matrix[5] = y_scale;
-
-	matrix[6] = 0.0f;
-	matrix[7] = 0.0f;
-	matrix[8] = 1.0f;
-
-	g_debug ("Matrix is %f,%f,%f,%f,%f,%f,%f,%f,%f.",
-	         matrix[0], matrix[1], matrix[2],
-	         matrix[3], matrix[4], matrix[5],
-	         matrix[6], matrix[7], matrix[8]);
-
-	return;
-}
-
-int
-gsd_wacom_device_get_display_monitor (GsdWacomDevice *device)
-{
-	GError *error = NULL;
-	GnomeRRScreen *rr_screen;
-	GnomeRROutput *rr_output;
-	GnomeRRMode *mode;
-	GnomeRRCrtc *crtc;
-	gint area[4];
-
-        g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), GSD_WACOM_SET_ALL_MONITORS);
-
-	rr_screen = gnome_rr_screen_new (gdk_screen_get_default (), &error);
-	if (rr_screen == NULL) {
-		g_warning ("Failed to create GnomeRRScreen: %s", error->message);
-		g_error_free (error);
-		return GSD_WACOM_SET_ALL_MONITORS;
-	}
-
-	rr_output = find_output (rr_screen, device);
-	if (rr_output == NULL) {
-		g_object_unref (rr_screen);
-		return GSD_WACOM_SET_ALL_MONITORS;
-	}
-
-	if (!is_on (rr_output)) {
-		g_warning ("Output is not active.");
-		g_object_unref (rr_screen);
-		return GSD_WACOM_SET_ALL_MONITORS;
-	}
-
-	crtc = gnome_rr_output_get_crtc (rr_output);
-	gnome_rr_crtc_get_position (crtc, &area[0], &area[1]);
-
-	mode = gnome_rr_crtc_get_current_mode (crtc);
-	area[2] = gnome_rr_mode_get_width (mode);
-	area[3] = gnome_rr_mode_get_height (mode);
-
-	g_object_unref (rr_screen);
-
-	if (area[2] <= 0 || area[3] <= 0) {
-		g_warning ("Output has non-positive area.");
-		return GSD_WACOM_SET_ALL_MONITORS;
-	}
-
-	g_debug ("Area: %d,%d %dx%d", area[0], area[1], area[2], area[3]);
-	return gdk_screen_get_monitor_at_point (gdk_screen_get_default (), area[0], area[1]);
-}
-
-gboolean
-gsd_wacom_device_get_display_matrix (GsdWacomDevice *device, float matrix[NUM_ELEMS_MATRIX])
-{
-	int monitor;
-	GdkRectangle display;
-	GdkRectangle desktop;
-	GdkScreen *screen = gdk_screen_get_default ();
-
-	matrix[0] = 1.0f;
-	matrix[1] = 0.0f;
-	matrix[2] = 0.0f;
-	matrix[3] = 0.0f;
-	matrix[4] = 1.0f;
-	matrix[5] = 0.0f;
-	matrix[6] = 0.0f;
-	matrix[7] = 0.0f;
-	matrix[8] = 1.0f;
-
-	monitor = gsd_wacom_device_get_display_monitor (device);
-	if (monitor < 0)
-		return FALSE;
-
-	desktop.x = 0;
-	desktop.y = 0;
-	desktop.width = gdk_screen_get_width (screen);
-	desktop.height = gdk_screen_get_height (screen);
-
-	gdk_screen_get_monitor_geometry (screen, monitor, &display);
-	calculate_transformation_matrix (display, desktop, matrix);
-	return TRUE;
-}
-
-GsdWacomRotation
-gsd_wacom_device_get_display_rotation (GsdWacomDevice *device)
-{
-	GError *error = NULL;
-	GnomeRRScreen *rr_screen;
-	GnomeRROutput *rr_output;
-	GnomeRRRotation rotation = GNOME_RR_ROTATION_0;
-
-	rr_screen = gnome_rr_screen_new (gdk_screen_get_default (), &error);
-	if (rr_screen == NULL) {
-		g_warning ("Failed to create GnomeRRScreen: %s", error->message);
-		g_error_free (error);
-		return GSD_WACOM_ROTATION_NONE;
-	}
-
-	rr_output = find_output (rr_screen, device);
-	if (rr_output) {
-		GnomeRRCrtc *crtc = gnome_rr_output_get_crtc (rr_output);
-		if (crtc)
-			rotation = gnome_rr_crtc_get_current_rotation (crtc);
-	}
-	g_object_unref (rr_screen);
-
-	return get_rotation_wacom (rotation);
-}
-
-static void
-add_stylus_to_device (GsdWacomDevice *device,
-		      const char     *settings_path,
-		      int             id)
-{
-	const WacomStylus *wstylus;
-
-	wstylus = libwacom_stylus_get_for_id (db, id);
-	if (wstylus) {
-		GsdWacomStylus *stylus;
-		char *stylus_settings_path;
-		GSettings *settings;
-
-		if (device->priv->type == WACOM_TYPE_STYLUS &&
-		    libwacom_stylus_is_eraser (wstylus))
-			return;
-		if (device->priv->type == WACOM_TYPE_ERASER &&
-		    libwacom_stylus_is_eraser (wstylus) == FALSE)
-			return;
-
-		stylus_settings_path = g_strdup_printf ("%s0x%x/", settings_path, id);
-		if (device->priv->type == WACOM_TYPE_STYLUS) {
-			settings = g_settings_new_with_path (WACOM_STYLUS_SCHEMA, stylus_settings_path);
-			stylus = gsd_wacom_stylus_new (device, wstylus, settings);
-		} else {
-			settings = g_settings_new_with_path (WACOM_ERASER_SCHEMA, stylus_settings_path);
-			stylus = gsd_wacom_stylus_new (device, wstylus, settings);
-		}
-		g_free (stylus_settings_path);
-		device->priv->styli = g_list_prepend (device->priv->styli, stylus);
-	}
-}
-
-int
-gsd_wacom_device_get_num_modes (GsdWacomDevice *device,
-				int             group_id)
-{
-	int num_modes;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), -1);
-	num_modes = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->num_modes, GINT_TO_POINTER(group_id)));
-
-	return num_modes;
-}
-
-int
-gsd_wacom_device_get_current_mode (GsdWacomDevice *device,
-				   int             group_id)
-{
-	int current_idx;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), -1);
-	current_idx = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER(group_id)));
-	/* That means that the mode doesn't exist, see gsd_wacom_device_add_modes() */
-	g_return_val_if_fail (current_idx != 0, -1);
-
-	return current_idx;
-}
-
-int
-gsd_wacom_device_set_next_mode (GsdWacomDevice       *device,
-				GsdWacomTabletButton *button)
-{
-	GList *l;
-	int current_idx;
-	int num_modes;
-	int num_switches;
-	int group_id;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), -1);
-
-	group_id = button->group_id;
-	current_idx = 0;
-	num_switches = 0;
-	num_modes = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->num_modes, GINT_TO_POINTER(group_id)));
-
-	/*
-	 * Check if we have multiple mode-switch buttons for that
-	 * group, and if so, compute the current index based on
-	 * the position in the list...
-	 */
-	for (l = device->priv->buttons; l != NULL; l = l->next) {
-		GsdWacomTabletButton *b = l->data;
-		if (b->type != WACOM_TABLET_BUTTON_TYPE_HARDCODED)
-			continue;
-		if (button->group_id == b->group_id)
-			num_switches++;
-		if (g_strcmp0 (button->id, b->id) == 0)
-			current_idx = num_switches;
-	}
-
-	/* We should at least have found the current mode-switch button...
-	 * If not, then it means that the given button is not a valid
-	 * mode-switch.
-	 */
-	g_return_val_if_fail (num_switches != 0, -1);
-
-	/* Only one mode-switch? cycle through the modes */
-	if (num_switches == 1) {
-		current_idx = gsd_wacom_device_get_current_mode (device, group_id);
-		/* gsd_wacom_device_get_current_mode() returns -1 when the mode doesn't exist */
-		g_return_val_if_fail (current_idx > 0, -1);
-
-		current_idx++;
-	}
-
-	if (current_idx > num_modes)
-		current_idx = 1;
-
-	g_hash_table_insert (device->priv->modes, GINT_TO_POINTER (group_id), GINT_TO_POINTER (current_idx));
-
-	return current_idx;
-}
-
-static int
-flags_to_group (WacomButtonFlags flags)
-{
-	if (flags & WACOM_BUTTON_RING_MODESWITCH)
-		return 1;
-	if (flags & WACOM_BUTTON_RING2_MODESWITCH)
-		return 2;
-	if (flags & WACOM_BUTTON_TOUCHSTRIP_MODESWITCH)
-		return 3;
-	if (flags & WACOM_BUTTON_TOUCHSTRIP2_MODESWITCH)
-		return 4;
-
-	return 0;
-}
-
-static GList *
-gsd_wacom_device_add_ring_modes (WacomDevice      *wacom_device,
-				 const char       *settings_path,
-				 WacomButtonFlags  direction)
-{
-	GList *l;
-	guint num_modes;
-	guint group;
-	guint i;
-	char *name, *id;
-
-	l = NULL;
-
-	if ((direction & WACOM_BUTTON_POSITION_LEFT) && libwacom_has_ring (wacom_device)) {
-		num_modes = libwacom_get_ring_num_modes (wacom_device);
-		group = flags_to_group (WACOM_BUTTON_RING_MODESWITCH);
-		if (num_modes == 0) {
-			/* If no mode is available, we use "left-ring-mode-1" for backward compat */
-			l = g_list_append (l, gsd_wacom_tablet_button_new (_("Left Ring"),
-									   "left-ring-mode-1",
-									   settings_path,
-									   WACOM_TABLET_BUTTON_TYPE_RING,
-									   WACOM_TABLET_BUTTON_POS_LEFT,
-									   group,
-									   0,
-									   GSD_WACOM_NO_LED));
-		} else {
-			for (i = 1; i <= num_modes; i++) {
-				name = g_strdup_printf (_("Left Ring Mode #%d"), i);
-				id = g_strdup_printf ("left-ring-mode-%d", i);
-				l = g_list_append (l, gsd_wacom_tablet_button_new (name,
-				                                                   id,
-				                                                   settings_path,
-				                                                   WACOM_TABLET_BUTTON_TYPE_RING,
-										   WACOM_TABLET_BUTTON_POS_LEFT,
-				                                                   group,
-				                                                   i - 1,
-										   GSD_WACOM_NO_LED));
-				g_free (name);
-				g_free (id);
-			}
-		}
-	} else if ((direction & WACOM_BUTTON_POSITION_RIGHT) && libwacom_has_ring2 (wacom_device)) {
-		num_modes = libwacom_get_ring2_num_modes (wacom_device);
-		group = flags_to_group (WACOM_BUTTON_RING2_MODESWITCH);
-		if (num_modes == 0) {
-			/* If no mode is available, we use "right-ring-mode-1" for backward compat */
-			l = g_list_append (l, gsd_wacom_tablet_button_new (_("Right Ring"),
-									   "right-ring-mode-1",
-									   settings_path,
-									   WACOM_TABLET_BUTTON_TYPE_RING,
-									   WACOM_TABLET_BUTTON_POS_RIGHT,
-									   group,
-									   0,
-									   GSD_WACOM_NO_LED));
-		} else {
-			for (i = 1; i <= num_modes; i++) {
-				name = g_strdup_printf (_("Right Ring Mode #%d"), i);
-				id = g_strdup_printf ("right-ring-mode-%d", i);
-				l = g_list_append (l, gsd_wacom_tablet_button_new (name,
-				                                                   id,
-				                                                   settings_path,
-				                                                   WACOM_TABLET_BUTTON_TYPE_RING,
-										   WACOM_TABLET_BUTTON_POS_RIGHT,
-				                                                   group,
-				                                                   i - 1,
-										   GSD_WACOM_NO_LED));
-				g_free (name);
-				g_free (id);
-			}
-		}
-	}
-
-	return l;
-}
-
-static GList *
-gsd_wacom_device_add_strip_modes (WacomDevice      *wacom_device,
-				  const char       *settings_path,
-				  WacomButtonFlags  direction)
-{
-	GList *l;
-	guint num_modes;
-	guint num_strips;
-	guint group;
-	guint i;
-	char *name, *id;
-
-	l = NULL;
-	num_strips = libwacom_get_num_strips (wacom_device);
-	if (num_strips > 2)
-		g_warning ("Unhandled number of touchstrips: %d", num_strips);
-
-	if ((direction & WACOM_BUTTON_POSITION_LEFT) && num_strips >= 1) {
-		num_modes = libwacom_get_strips_num_modes (wacom_device);
-		group = flags_to_group (WACOM_BUTTON_TOUCHSTRIP_MODESWITCH);
-		if (num_modes == 0) {
-			/* If no mode is available, we use "left-strip-mode-1" for backward compat */
-			l = g_list_append (l, gsd_wacom_tablet_button_new (_("Left Touchstrip"),
-									   "left-strip-mode-1",
-									   settings_path,
-									   WACOM_TABLET_BUTTON_TYPE_STRIP,
-									   WACOM_TABLET_BUTTON_POS_LEFT,
-									   group,
-									   0,
-									   GSD_WACOM_NO_LED));
-		} else {
-			for (i = 1; i <= num_modes; i++) {
-				name = g_strdup_printf (_("Left Touchstrip Mode #%d"), i);
-				id = g_strdup_printf ("left-strip-mode-%d", i);
-				l = g_list_append (l, gsd_wacom_tablet_button_new (name,
-				                                                   id,
-				                                                   settings_path,
-				                                                   WACOM_TABLET_BUTTON_TYPE_STRIP,
-										   WACOM_TABLET_BUTTON_POS_LEFT,
-				                                                   group,
-				                                                   i - 1,
-										   GSD_WACOM_NO_LED));
-				g_free (name);
-				g_free (id);
-			}
-		}
-	} else if ((direction & WACOM_BUTTON_POSITION_RIGHT) && num_strips >= 2) {
-		num_modes = libwacom_get_strips_num_modes (wacom_device);
-		group = flags_to_group (WACOM_BUTTON_TOUCHSTRIP2_MODESWITCH);
-		if (num_modes == 0) {
-			/* If no mode is available, we use "right-strip-mode-1" for backward compat */
-			l = g_list_append (l, gsd_wacom_tablet_button_new (_("Right Touchstrip"),
-									   "right-strip-mode-1",
-									   settings_path,
-									   WACOM_TABLET_BUTTON_TYPE_STRIP,
-									   WACOM_TABLET_BUTTON_POS_RIGHT,
-									   group,
-									   0,
-									   GSD_WACOM_NO_LED));
-		} else {
-			for (i = 1; i <= num_modes; i++) {
-				name = g_strdup_printf (_("Right Touchstrip Mode #%d"), i);
-				id = g_strdup_printf ("right-strip-mode-%d", i);
-				l = g_list_append (l, gsd_wacom_tablet_button_new (name,
-				                                                   id,
-				                                                   settings_path,
-				                                                   WACOM_TABLET_BUTTON_TYPE_STRIP,
-										   WACOM_TABLET_BUTTON_POS_RIGHT,
-				                                                   group,
-				                                                   i - 1,
-										   GSD_WACOM_NO_LED));
-				g_free (name);
-				g_free (id);
-			}
-		}
-	}
-
-	return l;
-}
-
-static char *
-gsd_wacom_device_modeswitch_name (WacomButtonFlags flags,
-				  guint button_num)
-{
-	if (flags & WACOM_BUTTON_RINGS_MODESWITCH) {
-		if (flags & WACOM_BUTTON_POSITION_LEFT)
-			return g_strdup_printf (_("Left Touchring Mode Switch"));
-		else
-			return g_strdup_printf (_("Right Touchring Mode Switch"));
-	} else if (flags & WACOM_BUTTON_TOUCHSTRIPS_MODESWITCH) {
-		if (flags & WACOM_BUTTON_POSITION_LEFT)
-			return g_strdup_printf (_("Left Touchstrip Mode Switch"));
-		else
-			return g_strdup_printf (_("Right Touchstrip Mode Switch"));
-	}
-
-	g_warning ("Unhandled modeswitch and direction combination");
-
-	return g_strdup_printf (_("Mode Switch #%d"), button_num);
-}
-
-static GsdWacomTabletButtonType
-gsd_wacom_device_button_pos (WacomButtonFlags flags)
-{
-	if (flags & WACOM_BUTTON_POSITION_LEFT)
-		return WACOM_TABLET_BUTTON_POS_LEFT;
-	else if (flags & WACOM_BUTTON_POSITION_RIGHT)
-		return WACOM_TABLET_BUTTON_POS_RIGHT;
-	else if (flags & WACOM_BUTTON_POSITION_TOP)
-		return WACOM_TABLET_BUTTON_POS_TOP;
-	else if (flags & WACOM_BUTTON_POSITION_BOTTOM)
-		return WACOM_TABLET_BUTTON_POS_BOTTOM;
-
-	g_warning ("Unhandled button position");
-
-	return WACOM_TABLET_BUTTON_POS_UNDEF;
-}
-
-static GList *
-gsd_wacom_device_add_buttons_dir (WacomDevice      *wacom_device,
-				  const char       *settings_path,
-				  WacomButtonFlags  direction,
-				  const char       *button_str,
-				  const char       *button_str_id)
-{
-	GList *l;
-	guint num_buttons, i, button_num;
-	char *name, *id;
-
-	l = NULL;
-	button_num = 1;
-	num_buttons = libwacom_get_num_buttons (wacom_device);
-	for (i = 'A'; i < 'A' + num_buttons; i++) {
-		WacomButtonFlags flags;
-
-		flags = libwacom_get_button_flag (wacom_device, i);
-		if (!(flags & direction))
-			continue;
-		/* Ignore mode switches */
-		if (flags & WACOM_BUTTON_MODESWITCH)
-			continue;
-
-		name = g_strdup_printf (button_str, button_num++);
-		id = g_strdup_printf ("%s%c", button_str_id, i);
-		l = g_list_append (l, gsd_wacom_tablet_button_new (name,
-		                                                   id,
-		                                                   settings_path,
-		                                                   WACOM_TABLET_BUTTON_TYPE_NORMAL,
-		                                                   gsd_wacom_device_button_pos (flags),
-		                                                   flags_to_group (flags),
-		                                                   -1,
-		                                                   GSD_WACOM_NO_LED));
-		g_free (name);
-		g_free (id);
-	}
-
-	/* Handle modeswitches */
-	for (i = 'A'; i < 'A' + num_buttons; i++) {
-		WacomButtonFlags flags;
-		char *name, *id;
-		int status_led;
-
-		flags = libwacom_get_button_flag (wacom_device, i);
-		if (!(flags & direction))
-			continue;
-		/* Ignore non-mode switches */
-		if (!(flags & WACOM_BUTTON_MODESWITCH))
-			continue;
-
-		name = gsd_wacom_device_modeswitch_name (flags, button_num++);
-		id = g_strdup_printf ("%s%c", button_str_id, i);
-		status_led = libwacom_get_button_led_group (wacom_device, i);
-		l = g_list_append (l, gsd_wacom_tablet_button_new (name,
-		                                                   id,
-		                                                   settings_path,
-		                                                   WACOM_TABLET_BUTTON_TYPE_HARDCODED,
-		                                                   gsd_wacom_device_button_pos (flags),
-		                                                   flags_to_group (flags),
-		                                                   -1,
-		                                                   status_led));
-		g_free (name);
-		g_free (id);
-	}
-
-	/* Handle touch{strips,rings} */
-	if (libwacom_has_ring2 (wacom_device) || libwacom_has_ring (wacom_device))
-		l = g_list_concat (l, gsd_wacom_device_add_ring_modes (wacom_device, settings_path, direction));
-	if  (libwacom_get_num_strips (wacom_device) > 0)
-		l = g_list_concat (l, gsd_wacom_device_add_strip_modes (wacom_device, settings_path, direction));
-
-	return l;
-}
-
-static void
-gsd_wacom_device_add_buttons (GsdWacomDevice *device,
-			      WacomDevice    *wacom_device,
-			      const char     *settings_path)
-{
-	GList *l, *ret;
-
-	ret = NULL;
-
-	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_LEFT, _("Left Button #%d"), "button");
-	if (l)
-		ret = l;
-	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_RIGHT, _("Right Button #%d"), "button");
-	if (l)
-		ret = g_list_concat (ret, l);
-	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_TOP, _("Top Button #%d"), "button");
-	if (l)
-		ret = g_list_concat (ret, l);
-	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_BOTTOM, _("Bottom Button #%d"), "button");
-	if (l)
-		ret = g_list_concat (ret, l);
-
-	device->priv->buttons = ret;
-}
-
-static void
-gsd_wacom_device_get_modeswitches (WacomDevice      *wacom_device,
-				   gint             *num_rings,
-				   gint             *num_strips)
-{
-	*num_strips = libwacom_get_num_strips (wacom_device);
-
-	if (libwacom_has_ring2 (wacom_device))
-		*num_rings = 2;
-	else if  (libwacom_has_ring (wacom_device))
-		*num_rings = 1;
-	else
-		*num_rings = 0;
-}
-
-static void
-gsd_wacom_device_add_modes (GsdWacomDevice *device,
-			    WacomDevice    *wacom_device)
-{
-	GList *l;
-
-	device->priv->modes = g_hash_table_new (g_direct_hash, g_direct_equal);
-	device->priv->num_modes = g_hash_table_new (g_direct_hash, g_direct_equal);
-
-	for (l = device->priv->buttons; l != NULL; l = l->next) {
-		GsdWacomTabletButton *button = l->data;
-
-		if (button->group_id > 0)
-			g_hash_table_insert (device->priv->modes, GINT_TO_POINTER (button->group_id), GINT_TO_POINTER (1));
-
-		/* See flags_to_group() for group ID/button type matches */
-		if (button->group_id == 1) {
-			g_hash_table_insert (device->priv->num_modes,
-					     GINT_TO_POINTER (button->group_id),
-					     GINT_TO_POINTER (libwacom_get_ring_num_modes (wacom_device)));
-		} else if (button->group_id == 2) {
-			g_hash_table_insert (device->priv->num_modes,
-					     GINT_TO_POINTER (button->group_id),
-					     GINT_TO_POINTER (libwacom_get_ring2_num_modes (wacom_device)));
-		} else if (button->group_id == 3 || button->group_id == 4) {
-			g_hash_table_insert (device->priv->num_modes,
-					     GINT_TO_POINTER (button->group_id),
-					     GINT_TO_POINTER (libwacom_get_strips_num_modes (wacom_device)));
-		}
-	}
-}
-
-static void
-gsd_wacom_device_update_from_db (GsdWacomDevice *device,
-				 WacomDevice    *wacom_device,
-				 const char     *identifier)
-{
-	char *settings_path;
-	WacomIntegrationFlags integration_flags;
-
-	settings_path = g_strdup_printf (WACOM_DEVICE_CONFIG_BASE,
-					 device->priv->machine_id,
-					 libwacom_get_match (wacom_device));
-	device->priv->wacom_settings = g_settings_new_with_path (WACOM_TABLET_SCHEMA,
-								 settings_path);
-
-	device->priv->name = g_strdup (libwacom_get_name (wacom_device));
-	device->priv->layout_path = g_strdup (libwacom_get_layout_filename (wacom_device));
-	device->priv->reversible = libwacom_is_reversible (wacom_device);
-	integration_flags = libwacom_get_integration_flags (wacom_device);
-	device->priv->is_screen_tablet = (integration_flags & WACOM_DEVICE_INTEGRATED_DISPLAY);
-	device->priv->is_isd = (integration_flags & WACOM_DEVICE_INTEGRATED_SYSTEM);
-	if (device->priv->is_screen_tablet) {
-		if (!device->priv->is_isd)
-			device->priv->icon_name = "wacom-tablet-cintiq";
-		else
-			device->priv->icon_name = "wacom-tablet-pc";
-	} else {
-		device->priv->icon_name = "wacom-tablet";
-	}
-
-	if (device->priv->type == WACOM_TYPE_PAD) {
-		gsd_wacom_device_get_modeswitches (wacom_device,
-						   &device->priv->num_rings,
-						   &device->priv->num_strips);
-		gsd_wacom_device_add_buttons (device, wacom_device, settings_path);
-		gsd_wacom_device_add_modes (device, wacom_device);
-	}
-
-	if (device->priv->type == WACOM_TYPE_STYLUS ||
-	    device->priv->type == WACOM_TYPE_ERASER) {
-		const int *ids;
-		int num_styli;
-		guint i;
-
-		ids = libwacom_get_supported_styli (wacom_device, &num_styli);
-		g_assert (num_styli >= 1);
-		for (i = 0; i < num_styli; i++)
-			add_stylus_to_device (device, settings_path, ids[i]);
-		device->priv->styli = g_list_reverse (device->priv->styli);
-	}
-	g_free (settings_path);
-}
-
-static GObject *
-gsd_wacom_device_constructor (GType                     type,
-                              guint                      n_construct_properties,
-                              GObjectConstructParam     *construct_properties)
-{
-        GsdWacomDevice *device;
-        GdkDeviceManager *device_manager;
-        XDeviceInfo *device_info;
-        WacomDevice *wacom_device;
-        int n_devices;
-        guint i;
-
-        device = GSD_WACOM_DEVICE (G_OBJECT_CLASS (gsd_wacom_device_parent_class)->constructor (type,
-												n_construct_properties,
-												construct_properties));
-
-	if (device->priv->gdk_device == NULL)
-		return G_OBJECT (device);
-
-	device_manager = gdk_display_get_device_manager (gdk_display_get_default ());
-	g_object_get (device_manager, "opcode", &device->priv->opcode, NULL);
-
-        g_object_get (device->priv->gdk_device, "device-id", &device->priv->device_id, NULL);
-
-        device_info = XListInputDevices (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &n_devices);
-        if (device_info == NULL) {
-		g_warning ("Could not list any input devices through XListInputDevices()");
-		goto end;
-	}
-
-        for (i = 0; i < n_devices; i++) {
-		if (device_info[i].id == device->priv->device_id) {
-			device->priv->type = get_device_type (&device_info[i]);
-			device->priv->tool_name = g_strdup (device_info[i].name);
-			break;
-		}
-	}
-
-	XFreeDeviceList (device_info);
-
-	if (device->priv->type == WACOM_TYPE_INVALID)
-		goto end;
-
-	device->priv->path = xdevice_get_device_node (device->priv->device_id);
-	if (device->priv->path == NULL) {
-		g_warning ("Could not get the device node path for ID '%d'", device->priv->device_id);
-		device->priv->type = WACOM_TYPE_INVALID;
-		goto end;
-	}
-
-	if (db == NULL)
-		db = libwacom_database_new ();
-
-	wacom_device = libwacom_new_from_path (db, device->priv->path, FALSE, NULL);
-	if (!wacom_device) {
-		WacomError *wacom_error;
-
-		g_debug ("Creating fallback driver for wacom tablet '%s' ('%s')",
-			 gdk_device_get_name (device->priv->gdk_device),
-			 device->priv->path);
-
-		device->priv->is_fallback = TRUE;
-		wacom_error = libwacom_error_new ();
-		wacom_device = libwacom_new_from_path (db, device->priv->path, TRUE, wacom_error);
-		if (wacom_device == NULL) {
-			g_warning ("Failed to create fallback wacom device for '%s': %s (%d)",
-				   device->priv->path,
-				   libwacom_error_get_message (wacom_error),
-				   libwacom_error_get_code (wacom_error));
-			libwacom_error_free (&wacom_error);
-			device->priv->type = WACOM_TYPE_INVALID;
-			goto end;
-		}
-	}
-
-	gsd_wacom_device_update_from_db (device, wacom_device, device->priv->path);
-	libwacom_destroy (wacom_device);
-
-	if (device->priv->type == WACOM_TYPE_STYLUS ||
-	    device->priv->type == WACOM_TYPE_ERASER) {
-		setup_property_notify (device);
-	}
-
-end:
-        return G_OBJECT (device);
-}
-
-static void
-gsd_wacom_device_set_property (GObject        *object,
-                               guint           prop_id,
-                               const GValue   *value,
-                               GParamSpec     *pspec)
-{
-        GsdWacomDevice *device;
-
-        device = GSD_WACOM_DEVICE (object);
-
-        switch (prop_id) {
-	case PROP_GDK_DEVICE:
-		device->priv->gdk_device = g_value_get_pointer (value);
-		break;
-	case PROP_LAST_STYLUS:
-		device->priv->last_stylus = g_value_get_pointer (value);
-		break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsd_wacom_device_get_property (GObject        *object,
-                               guint           prop_id,
-                               GValue         *value,
-                               GParamSpec     *pspec)
-{
-        GsdWacomDevice *device;
-
-        device = GSD_WACOM_DEVICE (object);
-
-        switch (prop_id) {
-	case PROP_GDK_DEVICE:
-		g_value_set_pointer (value, device->priv->gdk_device);
-		break;
-	case PROP_LAST_STYLUS:
-		g_value_set_pointer (value, device->priv->last_stylus);
-		break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsd_wacom_device_class_init (GsdWacomDeviceClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->constructor = gsd_wacom_device_constructor;
-        object_class->finalize = gsd_wacom_device_finalize;
-        object_class->set_property = gsd_wacom_device_set_property;
-        object_class->get_property = gsd_wacom_device_get_property;
-
-        g_type_class_add_private (klass, sizeof (GsdWacomDevicePrivate));
-
-	g_object_class_install_property (object_class, PROP_GDK_DEVICE,
-					 g_param_spec_pointer ("gdk-device", "gdk-device", "gdk-device",
-							       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (object_class, PROP_LAST_STYLUS,
-					 g_param_spec_pointer ("last-stylus", "last-stylus", "last-stylus",
-							       G_PARAM_READWRITE));
-}
-
-static void
-gsd_wacom_device_init (GsdWacomDevice *device)
-{
-        device->priv = GSD_WACOM_DEVICE_GET_PRIVATE (device);
-        device->priv->type = WACOM_TYPE_INVALID;
-
-        if (g_file_get_contents ("/etc/machine-id", &device->priv->machine_id, NULL, NULL) == FALSE)
-                if (g_file_get_contents ("/var/lib/dbus/machine-id", &device->priv->machine_id, NULL, NULL) == FALSE)
-                        device->priv->machine_id = g_strdup ("00000000000000000000000000000000");
-
-        device->priv->machine_id = g_strstrip (device->priv->machine_id);
-}
-
-static void
-gsd_wacom_device_finalize (GObject *object)
-{
-        GsdWacomDevice *device;
-        GsdWacomDevicePrivate *p;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSD_IS_WACOM_DEVICE (object));
-
-        device = GSD_WACOM_DEVICE (object);
-
-        g_return_if_fail (device->priv != NULL);
-
-	p = device->priv;
-
-        if (p->wacom_settings != NULL) {
-                g_object_unref (p->wacom_settings);
-                p->wacom_settings = NULL;
-        }
-
-        g_list_foreach (p->styli, (GFunc) g_object_unref, NULL);
-        g_list_free (p->styli);
-
-        g_list_foreach (p->buttons, (GFunc) gsd_wacom_tablet_button_free, NULL);
-        g_list_free (p->buttons);
-
-        g_free (p->name);
-        p->name = NULL;
-
-        g_free (p->tool_name);
-        p->tool_name = NULL;
-
-        g_free (p->path);
-        p->path = NULL;
-
-        g_free (p->machine_id);
-        p->machine_id = NULL;
-
-        if (p->modes) {
-                g_hash_table_destroy (p->modes);
-                p->modes = NULL;
-        }
-        if (p->num_modes) {
-                g_hash_table_destroy (p->num_modes);
-                p->num_modes = NULL;
-        }
-
-	g_clear_pointer (&p->layout_path, g_free);
-
-	gdk_window_remove_filter (NULL,
-				  (GdkFilterFunc) filter_events,
-				  device);
-
-        G_OBJECT_CLASS (gsd_wacom_device_parent_class)->finalize (object);
-}
-
-GsdWacomDevice *
-gsd_wacom_device_new (GdkDevice *device)
-{
-	return GSD_WACOM_DEVICE (g_object_new (GSD_TYPE_WACOM_DEVICE,
-					       "gdk-device", device,
-					       NULL));
-}
-
-GList *
-gsd_wacom_device_list_styli (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return g_list_copy (device->priv->styli);
-}
-
-GsdWacomStylus *
-gsd_wacom_device_get_stylus_for_type (GsdWacomDevice     *device,
-				      GsdWacomStylusType  type)
-{
-	GList *l;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	for (l = device->priv->styli; l != NULL; l = l->next) {
-		GsdWacomStylus *stylus = l->data;
-
-		if (gsd_wacom_stylus_get_stylus_type (stylus) == type)
-			return stylus;
-	}
-	return NULL;
-}
-
-const char *
-gsd_wacom_device_get_name (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->name;
-}
-
-const char *
-gsd_wacom_device_get_layout_path (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->layout_path;
-}
-
-const char *
-gsd_wacom_device_get_path (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->path;
-}
-
-const char *
-gsd_wacom_device_get_icon_name (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->icon_name;
-}
-
-const char *
-gsd_wacom_device_get_tool_name (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->tool_name;
-}
-
-gboolean
-gsd_wacom_device_reversible (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), FALSE);
-
-	return device->priv->reversible;
-}
-
-gboolean
-gsd_wacom_device_is_screen_tablet (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), FALSE);
-
-	return device->priv->is_screen_tablet;
-}
-
-gboolean
-gsd_wacom_device_is_isd (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), FALSE);
-
-	return device->priv->is_isd;
-}
-
-gboolean
-gsd_wacom_device_is_fallback (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), FALSE);
-
-	return device->priv->is_fallback;
-}
-
-gint
-gsd_wacom_device_get_num_strips (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), 0);
-
-	return device->priv->num_strips;
-}
-
-gint
-gsd_wacom_device_get_num_rings (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), 0);
-
-	return device->priv->num_rings;
-}
-
-GSettings *
-gsd_wacom_device_get_settings (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return device->priv->wacom_settings;
-}
-
-void
-gsd_wacom_device_set_current_stylus (GsdWacomDevice *device,
-				     int             stylus_id)
-{
-	GList *l;
-	GsdWacomStylus *stylus;
-
-	g_return_if_fail (GSD_IS_WACOM_DEVICE (device));
-
-	/* Don't change anything if the stylus is already set */
-	if (device->priv->last_stylus != NULL) {
-		GsdWacomStylus *stylus = device->priv->last_stylus;
-		if (stylus->priv->id == stylus_id)
-			return;
-	}
-
-	for (l = device->priv->styli; l; l = l->next) {
-		stylus = l->data;
-
-		/* Set a nice default if 0x0 */
-		if (stylus_id == 0x0 &&
-		    stylus->priv->type == WSTYLUS_GENERAL) {
-			g_object_set (device, "last-stylus", stylus, NULL);
-			return;
-		}
-
-		if (stylus->priv->id == stylus_id) {
-			g_object_set (device, "last-stylus", stylus, NULL);
-			return;
-		}
-	}
-
-	/* Setting the default stylus to be the generic one */
-	for (l = device->priv->styli; l; l = l->next) {
-		stylus = l->data;
-
-		/* Set a nice default if 0x0 */
-		if (stylus->priv->type == WSTYLUS_GENERAL) {
-			g_debug ("Could not find stylus ID 0x%x for tablet '%s', setting general pen ID 0x%x instead",
-				 stylus_id, device->priv->name, stylus->priv->id);
-			g_object_set (device, "last-stylus", stylus, NULL);
-			return;
-		}
-	}
-
-	g_warning ("Could not set the current stylus ID 0x%x for tablet '%s', no general pen found",
-		   stylus_id, device->priv->name);
-
-	/* Setting the default stylus to be the first one */
-	g_assert (device->priv->styli);
-
-	stylus = device->priv->styli->data;
-	g_object_set (device, "last-stylus", stylus, NULL);
-}
-
-GsdWacomDeviceType
-gsd_wacom_device_get_device_type (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), WACOM_TYPE_INVALID);
-
-	return device->priv->type;
-}
-
-gint *
-gsd_wacom_device_get_area (GsdWacomDevice *device)
-{
-	int i, id;
-	XDevice *xdevice;
-	Atom area, realtype;
-	int rc, realformat;
-	unsigned long nitems, bytes_after;
-	unsigned char *data = NULL;
-	gint *device_area;
-
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	g_object_get (device->priv->gdk_device, "device-id", &id, NULL);
-
-	area = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Wacom Tablet Area", False);
-
-	gdk_error_trap_push ();
-	xdevice = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), id);
-	if (gdk_error_trap_pop () || (device == NULL))
-		return NULL;
-
-	gdk_error_trap_push ();
-	rc = XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-				 xdevice, area, 0, 4, False,
-				 XA_INTEGER, &realtype, &realformat, &nitems,
-				 &bytes_after, &data);
-	if (gdk_error_trap_pop () || rc != Success || realtype == None || bytes_after != 0 || nitems != 4) {
-		XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdevice);
-		return NULL;
-	}
-
-	device_area = g_new0 (int, nitems);
-	for (i = 0; i < nitems; i++)
-		device_area[i] = ((long *)data)[i];
-
-	XFree (data);
-	XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdevice);
-
-	return device_area;
-}
-
-const char *
-gsd_wacom_device_type_to_string (GsdWacomDeviceType type)
-{
-	switch (type) {
-	case WACOM_TYPE_INVALID:
-		return "Invalid";
-	case WACOM_TYPE_STYLUS:
-		return "Stylus";
-	case WACOM_TYPE_ERASER:
-		return "Eraser";
-	case WACOM_TYPE_CURSOR:
-		return "Cursor";
-	case WACOM_TYPE_PAD:
-		return "Pad";
-	case WACOM_TYPE_TOUCH:
-		return "Touch";
-	default:
-		return "Unknown type";
-	}
-}
-
-GList *
-gsd_wacom_device_get_buttons (GsdWacomDevice *device)
-{
-	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
-
-	return g_list_copy (device->priv->buttons);
-}
-
-static GsdWacomTabletButton *
-find_button_with_id (GsdWacomDevice *device,
-		     const char     *id)
-{
-	GList *l;
-
-	for (l = device->priv->buttons; l != NULL; l = l->next) {
-		GsdWacomTabletButton *button = l->data;
-
-		if (g_strcmp0 (button->id, id) == 0)
-			return button;
-	}
-	return NULL;
-}
-
-static GsdWacomTabletButton *
-find_button_with_index (GsdWacomDevice *device,
-			const char     *id,
-			int             index)
-{
-	GsdWacomTabletButton *button;
-	char *str;
-
-	str = g_strdup_printf ("%s-mode-%d", id, index);
-	button = find_button_with_id (device, str);
-	g_free (str);
-
-	return button;
-}
-
-GsdWacomTabletButton *
-gsd_wacom_device_get_button (GsdWacomDevice   *device,
-			     int               button,
-			     GtkDirectionType *dir)
-{
-	int index;
-
-	if (button <= 26) {
-		char *id;
-		GsdWacomTabletButton *ret;
-		int physical_button;
-
-		/* mouse_button = physical_button < 4 ? physical_button : physical_button + 4 */
-		if (button > 4)
-			physical_button = button - 4;
-		else
-			physical_button = button;
-
-		id = g_strdup_printf ("button%c", 'A' + physical_button - 1);
-		ret = find_button_with_id (device, id);
-		g_free (id);
-
-		return ret;
-	}
-
-	switch (button) {
-	case 90:
-	case 92:
-	case 94:
-	case 96:
-		*dir = GTK_DIR_UP;
-		break;
-	case 91:
-	case 93:
-	case 95:
-	case 97:
-		*dir = GTK_DIR_DOWN;
-		break;
-	default:
-		;;
-	}
-
-	/* The group ID is implied by the button number */
-	switch (button) {
-	case 90:
-	case 91:
-		index = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER (1)));
-		return find_button_with_index (device, "left-ring", index);
-	case 92:
-	case 93:
-		index = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER (2)));
-		return find_button_with_index (device, "right-ring", index);
-	case 94:
-	case 95:
-		index = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER (3)));
-		return find_button_with_index (device, "left-strip", index);
-	case 96:
-	case 97:
-		index = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER (4)));
-		return find_button_with_index (device, "right-strip", index);
-	default:
-		return NULL;
-	}
-}
-
-GsdWacomRotation
-gsd_wacom_device_rotation_name_to_type (const char *rotation)
-{
-        guint i;
-
-	g_return_val_if_fail (rotation != NULL, GSD_WACOM_ROTATION_NONE);
-
-        for (i = 0; i < G_N_ELEMENTS (rotation_table); i++) {
-                if (strcmp (rotation_table[i].rotation_string, rotation) == 0)
-                        return (rotation_table[i].rotation_wacom);
-        }
-
-	return GSD_WACOM_ROTATION_NONE;
-}
-
-const char *
-gsd_wacom_device_rotation_type_to_name (GsdWacomRotation type)
-{
-        guint i;
-
-        for (i = 0; i < G_N_ELEMENTS (rotation_table); i++) {
-                if (rotation_table[i].rotation_wacom == type)
-                        return (rotation_table[i].rotation_string);
-        }
-
-	return "none";
-}
-
-GsdWacomDevice *
-gsd_wacom_device_create_fake (GsdWacomDeviceType  type,
-			      const char         *name,
-			      const char         *tool_name)
-{
-	GsdWacomDevice *device;
-	GsdWacomDevicePrivate *priv;
-	WacomDevice *wacom_device;
-
-	device = GSD_WACOM_DEVICE (g_object_new (GSD_TYPE_WACOM_DEVICE, NULL));
-
-	if (db == NULL)
-		db = libwacom_database_new ();
-
-	wacom_device = libwacom_new_from_name (db, name, NULL);
-	if (wacom_device == NULL)
-		return NULL;
-
-	priv = device->priv;
-	priv->type = type;
-	priv->tool_name = g_strdup (tool_name);
-	gsd_wacom_device_update_from_db (device, wacom_device, name);
-	libwacom_destroy (wacom_device);
-
-	return device;
-}
-
-GList *
-gsd_wacom_device_create_fake_cintiq (void)
-{
-	GsdWacomDevice *device;
-	GList *devices;
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
-					       "Wacom Cintiq 21UX2",
-					       "Wacom Cintiq 21UX2 stylus");
-	devices = g_list_prepend (NULL, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
-					       "Wacom Cintiq 21UX2",
-					       "Wacom Cintiq 21UX2 eraser");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
-					       "Wacom Cintiq 21UX2",
-					       "Wacom Cintiq 21UX2 pad");
-	devices = g_list_prepend (devices, device);
-
-	return devices;
-}
-
-GList *
-gsd_wacom_device_create_fake_bt (void)
-{
-	GsdWacomDevice *device;
-	GList *devices;
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
-					       "Wacom Graphire Wireless",
-					       "Graphire Wireless stylus");
-	devices = g_list_prepend (NULL, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
-					       "Wacom Graphire Wireless",
-					       "Graphire Wireless eraser");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
-					       "Wacom Graphire Wireless",
-					       "Graphire Wireless pad");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_CURSOR,
-					       "Wacom Graphire Wireless",
-					       "Graphire Wireless cursor");
-	devices = g_list_prepend (devices, device);
-
-	return devices;
-}
-
-GList *
-gsd_wacom_device_create_fake_x201 (void)
-{
-	GsdWacomDevice *device;
-	GList *devices;
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
-					       "Wacom Serial Tablet WACf004",
-					       "Wacom Serial Tablet WACf004 stylus");
-	devices = g_list_prepend (NULL, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
-					       "Wacom Serial Tablet WACf004",
-					       "Wacom Serial Tablet WACf004 eraser");
-	devices = g_list_prepend (devices, device);
-
-	return devices;
-}
-
-GList *
-gsd_wacom_device_create_fake_intuos4 (void)
-{
-	GsdWacomDevice *device;
-	GList *devices;
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
-					       "Wacom Intuos4 6x9",
-					       "Wacom Intuos4 6x9 stylus");
-	devices = g_list_prepend (NULL, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
-					       "Wacom Intuos4 6x9",
-					       "Wacom Intuos4 6x9 eraser");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
-					       "Wacom Intuos4 6x9",
-					       "Wacom Intuos4 6x9 pad");
-	devices = g_list_prepend (devices, device);
-
-	device = gsd_wacom_device_create_fake (WACOM_TYPE_CURSOR,
-					       "Wacom Intuos4 6x9",
-					       "Wacom Intuos4 6x9 cursor");
-	devices = g_list_prepend (devices, device);
-
-	return devices;
-}
diff --git a/panels/wacom/gsd-wacom-device.h b/panels/wacom/gsd-wacom-device.h
deleted file mode 100644
index 335945f..0000000
--- a/panels/wacom/gsd-wacom-device.h
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Bastien Nocera <hadess@hadess.net>
- *
- */
-
-#ifndef __GSD_WACOM_DEVICE_MANAGER_H
-#define __GSD_WACOM_DEVICE_MANAGER_H
-
-#include <glib-object.h>
-#include "gsd-enums.h"
-
-G_BEGIN_DECLS
-
-#define NUM_ELEMS_MATRIX 9
-
-#define GSD_TYPE_WACOM_DEVICE         (gsd_wacom_device_get_type ())
-#define GSD_WACOM_DEVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDevice))
-#define GSD_WACOM_DEVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_WACOM_DEVICE, GsdWacomDeviceClass))
-#define GSD_IS_WACOM_DEVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_WACOM_DEVICE))
-#define GSD_IS_WACOM_DEVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_WACOM_DEVICE))
-#define GSD_WACOM_DEVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDeviceClass))
-
-typedef struct GsdWacomDevicePrivate GsdWacomDevicePrivate;
-
-typedef struct
-{
-        GObject                parent;
-        GsdWacomDevicePrivate *priv;
-} GsdWacomDevice;
-
-typedef struct
-{
-        GObjectClass   parent_class;
-} GsdWacomDeviceClass;
-
-#define GSD_TYPE_WACOM_STYLUS         (gsd_wacom_stylus_get_type ())
-#define GSD_WACOM_STYLUS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylus))
-#define GSD_WACOM_STYLUS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusClass))
-#define GSD_IS_WACOM_STYLUS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_WACOM_STYLUS))
-#define GSD_IS_WACOM_STYLUS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_WACOM_STYLUS))
-#define GSD_WACOM_STYLUS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusClass))
-
-typedef struct GsdWacomStylusPrivate GsdWacomStylusPrivate;
-
-typedef struct
-{
-        GObject                parent;
-        GsdWacomStylusPrivate *priv;
-} GsdWacomStylus;
-
-typedef struct
-{
-        GObjectClass   parent_class;
-} GsdWacomStylusClass;
-
-typedef enum {
-	WACOM_STYLUS_TYPE_UNKNOWN,
-	WACOM_STYLUS_TYPE_GENERAL,
-	WACOM_STYLUS_TYPE_INKING,
-	WACOM_STYLUS_TYPE_AIRBRUSH,
-	WACOM_STYLUS_TYPE_CLASSIC,
-	WACOM_STYLUS_TYPE_MARKER,
-	WACOM_STYLUS_TYPE_STROKE,
-	WACOM_STYLUS_TYPE_PUCK
-} GsdWacomStylusType;
-
-GType            gsd_wacom_stylus_get_type       (void);
-GSettings      * gsd_wacom_stylus_get_settings   (GsdWacomStylus *stylus);
-const char     * gsd_wacom_stylus_get_name       (GsdWacomStylus *stylus);
-const char     * gsd_wacom_stylus_get_icon_name  (GsdWacomStylus *stylus);
-GsdWacomDevice * gsd_wacom_stylus_get_device     (GsdWacomStylus *stylus);
-gboolean         gsd_wacom_stylus_get_has_eraser (GsdWacomStylus *stylus);
-guint            gsd_wacom_stylus_get_num_buttons(GsdWacomStylus *stylus);
-int              gsd_wacom_stylus_get_id         (GsdWacomStylus *stylus);
-GsdWacomStylusType gsd_wacom_stylus_get_stylus_type (GsdWacomStylus *stylus);
-
-/* Tablet Buttons */
-typedef enum {
-	WACOM_TABLET_BUTTON_TYPE_NORMAL,
-	WACOM_TABLET_BUTTON_TYPE_STRIP,
-	WACOM_TABLET_BUTTON_TYPE_RING,
-	WACOM_TABLET_BUTTON_TYPE_HARDCODED
-} GsdWacomTabletButtonType;
-
-/*
- * Positions of the buttons on the tablet in default right-handed mode
- * (ie with no rotation applied).
- */
-typedef enum {
-	WACOM_TABLET_BUTTON_POS_UNDEF = 0,
-	WACOM_TABLET_BUTTON_POS_LEFT,
-	WACOM_TABLET_BUTTON_POS_RIGHT,
-	WACOM_TABLET_BUTTON_POS_TOP,
-	WACOM_TABLET_BUTTON_POS_BOTTOM
-} GsdWacomTabletButtonPos;
-
-#define MAX_GROUP_ID 4
-
-#define GSD_WACOM_NO_LED -1
-
-typedef struct
-{
-	char                     *name;
-	char                     *id;
-	GSettings                *settings;
-	GsdWacomTabletButtonType  type;
-	GsdWacomTabletButtonPos   pos;
-	int                       group_id, idx;
-	int                       status_led;
-} GsdWacomTabletButton;
-
-void                  gsd_wacom_tablet_button_free (GsdWacomTabletButton *button);
-GsdWacomTabletButton *gsd_wacom_tablet_button_copy (GsdWacomTabletButton *button);
-
-/* Device types to apply a setting to */
-typedef enum {
-	WACOM_TYPE_INVALID =     0,
-        WACOM_TYPE_STYLUS  =     (1 << 1),
-        WACOM_TYPE_ERASER  =     (1 << 2),
-        WACOM_TYPE_CURSOR  =     (1 << 3),
-        WACOM_TYPE_PAD     =     (1 << 4),
-        WACOM_TYPE_TOUCH   =     (1 << 5),
-        WACOM_TYPE_ALL     =     WACOM_TYPE_STYLUS | WACOM_TYPE_ERASER | WACOM_TYPE_CURSOR | WACOM_TYPE_PAD | WACOM_TYPE_TOUCH
-} GsdWacomDeviceType;
-
-/* We use -1 for entire screen when setting/getting monitor value */
-#define GSD_WACOM_SET_ALL_MONITORS -1
-
-GType gsd_wacom_device_get_type     (void);
-
-void     gsd_wacom_device_set_display         (GsdWacomDevice    *device,
-                                               int                monitor);
-gint     gsd_wacom_device_get_display_monitor (GsdWacomDevice *device);
-gboolean gsd_wacom_device_get_display_matrix  (GsdWacomDevice *device,
-                                               float           matrix[NUM_ELEMS_MATRIX]);
-GsdWacomRotation gsd_wacom_device_get_display_rotation (GsdWacomDevice *device);
-
-GsdWacomDevice * gsd_wacom_device_new              (GdkDevice *device);
-GList          * gsd_wacom_device_list_styli       (GsdWacomDevice *device);
-const char     * gsd_wacom_device_get_name         (GsdWacomDevice *device);
-const char     * gsd_wacom_device_get_layout_path  (GsdWacomDevice *device);
-const char     * gsd_wacom_device_get_path         (GsdWacomDevice *device);
-const char     * gsd_wacom_device_get_icon_name    (GsdWacomDevice *device);
-const char     * gsd_wacom_device_get_tool_name    (GsdWacomDevice *device);
-gboolean         gsd_wacom_device_reversible       (GsdWacomDevice *device);
-gboolean         gsd_wacom_device_is_screen_tablet (GsdWacomDevice *device);
-gboolean         gsd_wacom_device_is_isd           (GsdWacomDevice *device);
-gboolean         gsd_wacom_device_is_fallback      (GsdWacomDevice *device);
-gint             gsd_wacom_device_get_num_strips   (GsdWacomDevice *device);
-gint             gsd_wacom_device_get_num_rings    (GsdWacomDevice *device);
-GSettings      * gsd_wacom_device_get_settings     (GsdWacomDevice *device);
-void             gsd_wacom_device_set_current_stylus (GsdWacomDevice *device,
-						      int             stylus_id);
-GsdWacomStylus * gsd_wacom_device_get_stylus_for_type (GsdWacomDevice     *device,
-						       GsdWacomStylusType  type);
-
-GsdWacomDeviceType gsd_wacom_device_get_device_type (GsdWacomDevice *device);
-gint           * gsd_wacom_device_get_area          (GsdWacomDevice *device);
-const char     * gsd_wacom_device_type_to_string    (GsdWacomDeviceType type);
-GList          * gsd_wacom_device_get_buttons       (GsdWacomDevice *device);
-GsdWacomTabletButton *gsd_wacom_device_get_button   (GsdWacomDevice   *device,
-						     int               button,
-						     GtkDirectionType *dir);
-int gsd_wacom_device_get_num_modes                  (GsdWacomDevice   *device,
-						     int               group_id);
-int gsd_wacom_device_get_current_mode               (GsdWacomDevice   *device,
-						     int               group_id);
-int gsd_wacom_device_set_next_mode                  (GsdWacomDevice       *device,
-						     GsdWacomTabletButton *button);
-GsdWacomRotation gsd_wacom_device_rotation_name_to_type (const char *rotation);
-const char     * gsd_wacom_device_rotation_type_to_name (GsdWacomRotation type);
-
-
-/* Helper and debug functions */
-GsdWacomDevice * gsd_wacom_device_create_fake (GsdWacomDeviceType  type,
-					       const char         *name,
-					       const char         *tool_name);
-
-GList * gsd_wacom_device_create_fake_cintiq   (void);
-GList * gsd_wacom_device_create_fake_bt       (void);
-GList * gsd_wacom_device_create_fake_x201     (void);
-GList * gsd_wacom_device_create_fake_intuos4  (void);
-
-G_END_DECLS
-
-#endif /* __GSD_WACOM_DEVICE_MANAGER_H */
diff --git a/panels/wacom/test-wacom.c b/panels/wacom/test-wacom.c
deleted file mode 100644
index c3012cc..0000000
--- a/panels/wacom/test-wacom.c
+++ /dev/null
@@ -1,103 +0,0 @@
-
-#include "config.h"
-
-#include <glib/gi18n.h>
-
-#include "cc-wacom-page.h"
-#include "gsd-wacom-device.h"
-
-#define FIXED_WIDTH 675
-
-void
-cc_wacom_panel_switch_to_panel (CcWacomPanel *self, const char *panel)
-{
-	g_message ("Should launch display preferences here");
-}
-
-static void
-add_page (GList *devices,
-	  GtkWidget *notebook)
-{
-	GtkWidget *widget;
-	GsdWacomDevice *stylus, *eraser, *pad;
-	GList *l;
-
-	if (devices == NULL)
-		return;
-
-	stylus = eraser = pad = NULL;
-	for (l = devices; l ; l = l->next) {
-		switch (gsd_wacom_device_get_device_type (l->data)) {
-		case WACOM_TYPE_ERASER:
-			eraser = l->data;
-			break;
-		case WACOM_TYPE_STYLUS:
-			stylus = l->data;
-			break;
-		case WACOM_TYPE_PAD:
-			pad = l->data;
-			break;
-		default:
-			/* Nothing */
-			;
-		}
-	}
-	g_list_free (devices);
-
-	widget = cc_wacom_page_new (NULL, stylus, eraser, pad);
-	cc_wacom_page_set_navigation (CC_WACOM_PAGE (widget), GTK_NOTEBOOK (notebook), FALSE);
-	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), widget, NULL);
-	gtk_widget_show (widget);
-}
-
-static gboolean
-delete_event_cb (GtkWidget *widget,
-		 GdkEvent  *event,
-		 gpointer   user_data)
-{
-	gtk_main_quit ();
-
-	return FALSE;
-}
-
-int main (int argc, char **argv)
-{
-	GtkWidget *window, *notebook;
-	GList *devices;
-
-	bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
-	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-	textdomain (GETTEXT_PACKAGE);
-
-	gtk_init (&argc, &argv);
-
-	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-	gtk_window_set_resizable (GTK_WINDOW (window), FALSE);
-	gtk_widget_set_size_request (window, FIXED_WIDTH, -1);
-	g_signal_connect (G_OBJECT (window), "delete-event",
-			  G_CALLBACK (delete_event_cb), NULL);
-	notebook = gtk_notebook_new ();
-	gtk_notebook_set_show_tabs (GTK_NOTEBOOK (notebook), FALSE);
-	gtk_widget_set_vexpand (notebook, TRUE);
-	gtk_container_set_border_width (GTK_CONTAINER (notebook), 24);
-	gtk_container_add (GTK_CONTAINER (window), notebook);
-	gtk_widget_show (notebook);
-
-	devices = gsd_wacom_device_create_fake_intuos4 ();
-	add_page (devices, notebook);
-
-	devices = gsd_wacom_device_create_fake_cintiq ();
-	add_page (devices, notebook);
-
-	devices = gsd_wacom_device_create_fake_bt ();
-	add_page (devices, notebook);
-
-	devices = gsd_wacom_device_create_fake_x201 ();
-	add_page (devices, notebook);
-
-	gtk_widget_show (window);
-
-	gtk_main ();
-
-	return 0;
-}
diff --git a/panels/wacom/unity-wacom-panel.desktop.in.in b/panels/wacom/unity-wacom-panel.desktop.in.in
deleted file mode 100644
index 99e1320..0000000
--- a/panels/wacom/unity-wacom-panel.desktop.in.in
+++ /dev/null
@@ -1,13 +0,0 @@
-[Desktop Entry]
-_Name=Wacom Tablet
-_Comment=Set button mappings and adjust stylus sensitivity for graphics tablets
-Exec=unity-control-center wacom
-Icon=input-tablet
-Terminal=false
-Type=Application
-StartupNotify=true
-Categories=GNOME;GTK;Settings;HardwareSettings;X-Unity-Settings-Panel;
-OnlyShowIn=Unity;
-X-Unity-Settings-Panel=wacom
-# Translators: those are keywords for the wacom tablet control-center panel
-_Keywords=Tablet;Wacom;Stylus;Eraser;Mouse;
diff --git a/panels/wacom/wacom-module.c b/panels/wacom/wacom-module.c
deleted file mode 100644
index 3383ef8..0000000
--- a/panels/wacom/wacom-module.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright  Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author: Peter Hutterer <peter.hutterer@redhat.com>
- *
- */
-
-#include <config.h>
-
-#include "cc-wacom-panel.h"
-
-#include <glib/gi18n-lib.h>
-
-void
-g_io_module_load (GIOModule *module)
-{
-  bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
-  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-
-  /* register the panel */
-  cc_wacom_panel_register (module);
-}
-
-void
-g_io_module_unload (GIOModule *module)
-{
-}
diff --git a/panels/wacom/wacom-stylus-airbrush.svg b/panels/wacom/wacom-stylus-airbrush.svg
deleted file mode 100644
index 7d35a51..0000000
--- a/panels/wacom/wacom-stylus-airbrush.svg
+++ /dev/null
@@ -1,94 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   id="svg86343"
-   version="1.1"
-   inkscape:version="0.48.2 r9819"
-   width="148"
-   height="192"
-   sodipodi:docname="wacom-stylus-airbrush.svg">
-  <metadata
-     id="metadata86349">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs86347" />
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1037"
-     inkscape:window-height="741"
-     id="namedview86345"
-     showgrid="false"
-     inkscape:snap-nodes="false"
-     inkscape:snap-bbox="true"
-     inkscape:zoom="7"
-     inkscape:cx="111.67742"
-     inkscape:cy="-1.9993707"
-     inkscape:window-x="241"
-     inkscape:window-y="26"
-     inkscape:window-maximized="0"
-     inkscape:current-layer="svg86343"
-     borderlayer="true"
-     inkscape:showpageshadow="false">
-    <inkscape:grid
-       type="xygrid"
-       id="grid86802"
-       empspacing="5"
-       visible="true"
-       enabled="true"
-       snapvisiblegridlinesonly="true" />
-  </sodipodi:namedview>
-  <g
-     style="opacity:0.2;display:inline"
-     id="g10631"
-     transform="translate(592.43375,-302.48416)">
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 384.35014,508.88388 8.18019,0 0,-68.25798 82.46967,0"
-       id="path10552"
-       inkscape:connector-curvature="0"
-       transform="translate(-928.4063,-79.84375)"
-       sodipodi:nodetypes="cccc" />
-    <path
-       sodipodi:nodetypes="cccc"
-       inkscape:connector-curvature="0"
-       id="path10556"
-       d="m -553.62983,305.002 16.78159,0 0,18.8605 83.44194,0"
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m -557.78929,491.98468 42.82049,0 0,-88.95343 61.5625,0"
-       id="path10629"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cccc" />
-  </g>
-  <path
-     style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-     d="m 36.76199,1.22591 c -1.43276,0 -2.59423,1.88644 -2.59423,4.21347 0,0.06 -0.002,0.11387 0,0.17315 l -0.9224,0 -9.22393,88.19416 c 0.9224,9.23499 -17.8868963,29.69978 -17.8868963,29.69978 -4.0295528,5.27125 -3.9083456,22.05579 3.5898163,27.55716 l 12.4523,8.31149 5.07316,15.23774 0.5765,0 c 0.4809,6.59867 3.7818,16.16123 5.30375,16.16123 2.11004,0 4.72727,-11.12955 4.72727,-19.16261 0,-0.1448 0.002,-0.28896 0,-0.43293 0,0 5.38613,-9.2445 8.12859,-20.17264 6.283146,-2.81141 5.782898,-13.64962 0.49916,-16.4982 l -0.0094,-3.91974 c 0.83292,-0.84067 1.75859,-2.00027 1.75859,-3.53531 0,-1.88597 -0.81769,-3.49443 -1.98891,-4.21347 L 45.09235,108.09211 40.62451,5.61253 l -1.26829,0 c 0.002,-0.0591 0,-0.11322 0,-0.17315 0,-2.32703 -1.16148,-4.21347 -2.59423,-4.21347 z"
-     id="path5306"
-     inkscape:connector-curvature="0"
-     sodipodi:nodetypes="ssccccccccssccccsccccss" />
-</svg>
diff --git a/panels/wacom/wacom-stylus-art-pen.svg b/panels/wacom/wacom-stylus-art-pen.svg
deleted file mode 100644
index e1b5b83..0000000
--- a/panels/wacom/wacom-stylus-art-pen.svg
+++ /dev/null
@@ -1,127 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   id="svg86343"
-   version="1.1"
-   inkscape:version="0.48.2 r9819"
-   width="148"
-   height="192"
-   sodipodi:docname="wacom-stylus-art-pen.svg">
-  <metadata
-     id="metadata86349">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs86347">
-    <inkscape:path-effect
-       effect="spiro"
-       id="path-effect31574"
-       is_visible="true" />
-  </defs>
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1037"
-     inkscape:window-height="741"
-     id="namedview86345"
-     showgrid="false"
-     inkscape:snap-nodes="false"
-     inkscape:snap-bbox="true"
-     inkscape:zoom="4"
-     inkscape:cx="84.005601"
-     inkscape:cy="140.80529"
-     inkscape:window-x="241"
-     inkscape:window-y="26"
-     inkscape:window-maximized="0"
-     inkscape:current-layer="svg86343"
-     borderlayer="true"
-     inkscape:showpageshadow="false">
-    <inkscape:grid
-       type="xygrid"
-       id="grid86802"
-       empspacing="5"
-       visible="true"
-       enabled="true"
-       snapvisiblegridlinesonly="true" />
-  </sodipodi:namedview>
-  <g
-     style="display:inline"
-     transform="translate(592.43375,-287.62088)"
-     id="g10545">
-    <path
-       sodipodi:nodetypes="sscsscsccccccccccccccscsscsss"
-       inkscape:connector-curvature="0"
-       id="rect10526"
-       transform="translate(-928.4063,-95.84375)"
-       d="m 351.16741,385.06603 c -2.25232,0 -3.61834,1.53072 -4.16741,4.08946 L 345.53125,396 344.125,396 c -1.9944,0 -3.59375,1.59935 -3.59375,3.59375 L 340.53125,516 338,545.125 c -0.1873,2.15512 1.62589,3.92035 3.75,4.125 l 1.625,6.6639 2.20868,0 -1.40241,1.58029 c 0,0 3.53964,7.3799 5.83774,7.46829 l 1.42852,-6.9e-4 0.0512,7.31672 3.97602,-2.37893 -0.0292,-4.98639 1.38503,0.0197 c 2.82843,0 5.42789,-7.64858 5.42789,-7.64858 l -1.5299,-1.37038 2.20868,0 1.65625,-6.72641 c 1.96694,-0.35188 3.54637,-2.02216 3.40625,-4.0625 L 365.53125,516 l 0,-116.40625 c 0,-1.9944 -1.59935,-3.59375 -3.59375,-3.59375 l -1.40625,0 L 359,389.15549 c -0.53643,-2.39779 -1.88996,-4.08946 -4.16741,-4.08946 z"
-       style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
-    <rect
-       style="color:#000000;fill:#eeeeec;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:0.99999994px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-       id="rect10541"
-       width="9.0059462"
-       height="35.214661"
-       x="-579.93378"
-       y="385.90622"
-       rx="3.25"
-       ry="3.2499998" />
-  </g>
-  <g
-     style="opacity:0.2;display:inline"
-     id="g10631"
-     transform="translate(592.43375,-302.48416)">
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 357.25,492.91161 35.28033,0 0,-52.04275 82.46967,0"
-       id="path10552"
-       inkscape:connector-curvature="0"
-       transform="translate(-928.4063,-79.84375)"
-       sodipodi:nodetypes="cccc" />
-    <path
-       sodipodi:nodetypes="cccc"
-       inkscape:connector-curvature="0"
-       id="path10556"
-       d="m -568.1563,309.03125 32.25,0 0,14.94921 82.5,0"
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m -577.26246,492.06786 41.38649,0 0,-48.24593 82.46967,0"
-       id="path10629"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cccc" />
-    <path
-       sodipodi:nodetypes="cccc"
-       inkscape:connector-curvature="0"
-       id="path86913"
-       d="m -571.1563,430.06786 48.10785,0 0,-27.00932 69.64215,0"
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
-  </g>
-  <path
-     style="opacity:0.5;color:#000000;fill:#eeeeec;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-     d="m 12.427494,118.46089 8.909363,0"
-     id="path31572"
-     inkscape:path-effect="#path-effect31574"
-     inkscape:original-d="m 12.427494,118.46089 8.909363,0"
-     inkscape:connector-curvature="0" />
-</svg>
diff --git a/panels/wacom/wacom-stylus-classic.svg b/panels/wacom/wacom-stylus-classic.svg
deleted file mode 100644
index d07906e..0000000
--- a/panels/wacom/wacom-stylus-classic.svg
+++ /dev/null
@@ -1,103 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   id="svg86343"
-   version="1.1"
-   inkscape:version="0.48.2 r9819"
-   width="148"
-   height="192"
-   sodipodi:docname="wacom-stylus-classic.svg">
-  <metadata
-     id="metadata86349">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs86347">
-    <inkscape:path-effect
-       effect="spiro"
-       id="path-effect14408"
-       is_visible="true" />
-  </defs>
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1037"
-     inkscape:window-height="741"
-     id="namedview86345"
-     showgrid="false"
-     inkscape:snap-nodes="false"
-     inkscape:snap-bbox="true"
-     inkscape:zoom="6"
-     inkscape:cx="72.723556"
-     inkscape:cy="29.510722"
-     inkscape:window-x="241"
-     inkscape:window-y="26"
-     inkscape:window-maximized="0"
-     inkscape:current-layer="svg86343"
-     borderlayer="true"
-     inkscape:showpageshadow="false">
-    <inkscape:grid
-       type="xygrid"
-       id="grid86802"
-       empspacing="5"
-       visible="true"
-       enabled="true"
-       snapvisiblegridlinesonly="true" />
-  </sodipodi:namedview>
-  <g
-     style="opacity:0.2;display:inline"
-     id="g10631"
-     transform="translate(592.43375,-302.48416)" />
-  <path
-     style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:0.99999994px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-     d="m 9.320334,143.05408 c 0.5048552,10.77062 -1.425426,24.64726 -1.425426,24.64726 l 1.559872,1.05225 c 0,0 1.362729,5.49117 1.850845,8.2077 0.488109,2.71653 3.679579,7.5712 3.679579,7.5712 l 1.545431,1e-5 -8e-6,3.89851 c -0.03586,1.30926 1.983788,1.38546 1.983788,9e-5 l 8e-6,-3.89851 1.451666,0 c 0,0 3.191479,-4.85469 3.679602,-7.57122 0.488109,-2.71652 1.850829,-8.20768 1.850829,-8.20768 l 1.559865,-1.05226 c 0,0 -1.786488,-11.863 -1.545414,-21.63127 0.02477,-1.0038 2.597475,-2.07462 2.650333,-3.20226 0.270987,-5.78108 0.707625,-18.64287 1.089793,-26.63126 0.05442,-1.13744 -1.422603,-2.29772 -1.371031,-3.48097 0.344388,-7.90158 0.611194,-10.82762 0.611194,-20.817562 0,-18.010758 -2.769382,-60.275057 -4.161591,-77.215202 -0.04797,-0.583659 -1.395782,-0.703789 -1.431722,-1.120751 -0.194665,-2.258415 -1.008414,-7.2278662 -1.084445,-7.5212464 -0.488463,-1.884831 -2.23225,-3.5368788 -4.278453,-3.4701457 -0.03684,-0.00219 -0.07529,0.00133 -0.11193,0 -2.047734,-0.068768 -3.789705,1.5842322 -4.278452,3.470141 -0.07358,0.2839198 -0.882492,5.1712001 -1.068191,7.3053231 -0.04236,0.486815 -1.400479,0.674009 -1.457914,1.373508 -1.3931925,16.967387 -4.1585528,59.180639 -4.158534,77.178329 2.3e-5,21.992366 2.3554437,40.345416 2.860306,51.116016 z"
-     id="path14406"
-     inkscape:connector-curvature="0"
-     sodipodi:nodetypes="sccsccccccsccssssssssccssscs" />
-  <path
-     style="opacity:0.2;fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;display:inline"
-     d="m 28.911333,120.55337 27.646447,0 0,-61.96967 82.46967,0"
-     id="path10552"
-     inkscape:connector-curvature="0"
-     sodipodi:nodetypes="cccc" />
-  <path
-     sodipodi:nodetypes="cccc"
-     inkscape:connector-curvature="0"
-     id="path10556"
-     d="m 24.27745,6.54709 32.25,0 0,15 82.5,0"
-     style="opacity:0.2;fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;display:inline" />
-  <path
-     style="opacity:0.2;fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;display:inline"
-     d="m 17.02745,189.5837 64.53033,0 0,-48 57.46967,0"
-     id="path10629"
-     inkscape:connector-curvature="0"
-     sodipodi:nodetypes="cccc" />
-  <path
-     sodipodi:nodetypes="cccc"
-     inkscape:connector-curvature="0"
-     id="path86913"
-     d="m 28.02745,138.52564 41.53033,0 0,-37.94194 69.46967,0"
-     style="opacity:0.2;fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;display:inline" />
-</svg>
diff --git a/panels/wacom/wacom-stylus-inking.svg b/panels/wacom/wacom-stylus-inking.svg
deleted file mode 100644
index aca5ca4..0000000
--- a/panels/wacom/wacom-stylus-inking.svg
+++ /dev/null
@@ -1,87 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   id="svg86343"
-   version="1.1"
-   inkscape:version="0.48.2 r9819"
-   width="148"
-   height="192"
-   sodipodi:docname="wacom-stylus-inking.svg">
-  <metadata
-     id="metadata86349">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs86347">
-    <inkscape:path-effect
-       effect="spiro"
-       id="path-effect14408"
-       is_visible="true" />
-  </defs>
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1280"
-     inkscape:window-height="742"
-     id="namedview86345"
-     showgrid="false"
-     inkscape:snap-nodes="false"
-     inkscape:snap-bbox="true"
-     inkscape:zoom="7"
-     inkscape:cx="100.36114"
-     inkscape:cy="19.260911"
-     inkscape:window-x="0"
-     inkscape:window-y="26"
-     inkscape:window-maximized="1"
-     inkscape:current-layer="svg86343"
-     borderlayer="true"
-     inkscape:showpageshadow="false">
-    <inkscape:grid
-       type="xygrid"
-       id="grid86802"
-       empspacing="5"
-       visible="true"
-       enabled="true"
-       snapvisiblegridlinesonly="true" />
-  </sodipodi:namedview>
-  <g
-     style="opacity:0.2;display:inline"
-     id="g10631"
-     transform="translate(592.43375,-302.48416)">
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 353.5,569.875 38.0625,0 0,-166.14286 83.4375,0"
-       id="path10552"
-       inkscape:connector-curvature="0"
-       transform="translate(-928.4063,-79.84375)"
-       sodipodi:nodetypes="cccc" />
-  </g>
-  <path
-     style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:0.99999994px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-     d="m 9.320334,142.86781 c 0.5052639,10.77933 -1.425426,24.83353 -1.425426,24.83353 l 1.559872,1.05225 c 0,0 1.362729,5.49117 1.850845,8.2077 0.488109,2.71653 3.679579,7.5712 3.679579,7.5712 l 1.545431,1e-5 -8e-6,3.89851 c -0.03586,1.30926 1.983788,1.38546 1.983788,9e-5 l 8e-6,-3.89851 1.451666,0 c 0,0 3.191479,-4.85469 3.679602,-7.57122 0.488109,-2.71652 1.850829,-8.20768 1.850829,-8.20768 l 1.559865,-1.05226 c 0,0 -1.930689,-14.0542 -1.425411,-24.83354 C 26.136241,132.08855 28.49126,113.93051 28.49126,91.938108 28.491252,69.945706 24.362076,8.8089377 23.653056,6.0730443 22.956873,3.3867824 20.471645,1.0322717 17.55539,1.12738 c -0.0525,-0.00312 -0.107307,0.0019 -0.159523,0 C 14.477429,1.029372 11.994773,3.3852354 11.298202,6.0730375 10.589174,8.8089377 6.460005,69.945698 6.460028,91.938064 c 2.3e-5,21.992366 2.355035,40.150416 2.860306,50.929746 z"
-     id="path14406"
-     inkscape:connector-curvature="0"
-     sodipodi:nodetypes="sccsccccccsccsssccscs" />
-</svg>
diff --git a/panels/wacom/wacom-stylus-page.ui b/panels/wacom/wacom-stylus-page.ui
deleted file mode 100644
index 627aef0..0000000
--- a/panels/wacom/wacom-stylus-page.ui
+++ /dev/null
@@ -1,351 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <!-- interface-requires gtk+ 3.0 -->
-  <object class="GtkAdjustment" id="adjustment-eraser-feel">
-    <property name="upper">6</property>
-    <property name="step_increment">1</property>
-    <property name="page_increment">3</property>
-  </object>
-  <object class="GtkAdjustment" id="adjustment-tip-feel">
-    <property name="upper">6</property>
-    <property name="step_increment">1</property>
-    <property name="page_increment">3</property>
-  </object>
-  <object class="GtkListStore" id="liststore-buttons">
-    <columns>
-      <!-- column-name button -->
-      <column type="gint"/>
-      <!-- column-name button-label -->
-      <column type="gchararray"/>
-    </columns>
-    <data>
-      <row>
-        <col id="0">0</col>
-        <col id="1" translatable="yes">No Action</col>
-      </row>
-      <row>
-        <col id="0">1</col>
-        <col id="1" translatable="yes">Left Mouse Button Click</col>
-      </row>
-      <row>
-        <col id="0">2</col>
-        <col id="1" translatable="yes">Middle Mouse Button Click</col>
-      </row>
-      <row>
-        <col id="0">3</col>
-        <col id="1" translatable="yes">Right Mouse Button Click</col>
-      </row>
-      <row>
-        <col id="0">4</col>
-        <col id="1" translatable="yes">Scroll Up</col>
-      </row>
-      <row>
-        <col id="0">5</col>
-        <col id="1" translatable="yes">Scroll Down</col>
-      </row>
-      <row>
-        <col id="0">6</col>
-        <col id="1" translatable="yes">Scroll Left</col>
-      </row>
-      <row>
-        <col id="0">7</col>
-        <col id="1" translatable="yes">Scroll Right</col>
-      </row>
-      <row>
-        <col id="0">7</col>
-        <col id="1" translatable="yes">Back</col>
-      </row>
-      <row>
-        <col id="0">8</col>
-        <col id="1" translatable="yes">Forward</col>
-      </row>
-    </data>
-  </object>
-  <object class="GtkGrid" id="stylus-grid">
-    <property name="visible">True</property>
-    <property name="can_focus">False</property>
-    <property name="column_spacing">10</property>
-    <property name="row_spacing">10</property>
-    <child>
-      <object class="GtkLabel" id="label-stylus">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="halign">start</property>
-        <property name="valign">center</property>
-        <property name="label" translatable="yes">Stylus</property>
-        <attributes>
-          <attribute name="weight" value="bold"/>
-        </attributes>
-      </object>
-      <packing>
-        <property name="left_attach">0</property>
-        <property name="top_attach">0</property>
-        <property name="width">2</property>
-        <property name="height">1</property>
-      </packing>
-    </child>
-    <child>
-      <object class="GtkImage" id="image-stylus">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="halign">end</property>
-        <property name="valign">start</property>
-        <property name="pixbuf">wacom-stylus.svg</property>
-      </object>
-      <packing>
-        <property name="left_attach">0</property>
-        <property name="top_attach">1</property>
-        <property name="width">1</property>
-        <property name="height">1</property>
-      </packing>
-    </child>
-    <child>
-      <object class="GtkGrid" id="stylus-controls-grid">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="orientation">vertical</property>
-        <property name="margin_left">16</property>
-        <property name="margin_top">6</property>
-        <property name="row_spacing">10</property>
-        <property name="column_spacing">10</property>
-        <child>
-          <object class="GtkLabel" id="label-eraser-feel">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">end</property>
-            <property name="valign">center</property>
-            <property name="label" translatable="yes">Eraser Pressure Feel</property>
-            <property name="justify">right</property>
-            <style>
-              <class name="dim-label-ucc"/>
-            </style>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">0</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkBox" id="eraser-box">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="spacing">10</property>
-            <child>
-              <object class="GtkLabel" id="label-eraser-soft">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Soft</property>
-                <attributes>
-                  <attribute name="scale" value="0.82999999999999996"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkScale" id="scale-eraser-feel">
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="valign">center</property>
-                <property name="adjustment">adjustment-eraser-feel</property>
-                <property name="digits">0</property>
-                <property name="draw_value">False</property>
-              </object>
-              <packing>
-                <property name="expand">True</property>
-                <property name="fill">True</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkLabel" id="label-eraser-firm">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Firm</property>
-                <attributes>
-                  <attribute name="scale" value="0.82999999999999996"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">2</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="left_attach">1</property>
-            <property name="top_attach">0</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkLabel" id="label-top-button">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">end</property>
-            <property name="valign">center</property>
-            <property name="label" translatable="yes">Top Button</property>
-            <property name="justify">right</property>
-            <style>
-              <class name="dim-label-ucc"/>
-            </style>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">1</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkComboBox" id="combo-topbutton">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="valign">center</property>
-            <property name="model">liststore-buttons</property>
-          </object>
-          <packing>
-            <property name="left_attach">1</property>
-            <property name="top_attach">1</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkLabel" id="label-lower-button">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">end</property>
-            <property name="valign">center</property>
-            <property name="label" translatable="yes">Lower Button</property>
-            <property name="justify">right</property>
-            <style>
-              <class name="dim-label-ucc"/>
-            </style>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">2</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkComboBox" id="combo-bottombutton">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="valign">center</property>
-            <property name="model">liststore-buttons</property>
-          </object>
-          <packing>
-            <property name="left_attach">1</property>
-            <property name="top_attach">2</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkLabel" id="label-tip-feel">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">end</property>
-            <property name="valign">center</property>
-            <property name="label" translatable="yes">Tip Pressure Feel</property>
-            <property name="justify">right</property>
-            <style>
-              <class name="dim-label-ucc"/>
-            </style>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">3</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-        <child>
-          <object class="GtkBox" id="box-tip-feel">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="spacing">10</property>
-            <child>
-              <object class="GtkLabel" id="label-tip-soft">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Soft</property>
-                <attributes>
-                  <attribute name="scale" value="0.82999999999999996"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkScale" id="scale-tip-feel">
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="adjustment">adjustment-tip-feel</property>
-                <property name="digits">0</property>
-                <property name="draw_value">False</property>
-              </object>
-              <packing>
-                <property name="expand">True</property>
-                <property name="fill">True</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkLabel" id="label-tip-firm">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Firm</property>
-                <attributes>
-                  <attribute name="scale" value="0.82999999999999996"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">True</property>
-                <property name="position">2</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="left_attach">1</property>
-            <property name="top_attach">3</property>
-            <property name="width">1</property>
-            <property name="height">1</property>
-          </packing>
-        </child>
-      </object>
-      <packing>
-        <property name="left_attach">1</property>
-        <property name="top_attach">1</property>
-        <property name="width">1</property>
-        <property name="height">1</property>
-      </packing>
-    </child>
-    <child>
-      <placeholder/>
-    </child>
-    <child>
-      <placeholder/>
-    </child>
-    <child>
-      <placeholder/>
-    </child>
-    <child>
-      <placeholder/>
-    </child>
-  </object>
-</interface>
diff --git a/panels/wacom/wacom-stylus.svg b/panels/wacom/wacom-stylus.svg
deleted file mode 100644
index 63dfa6e..0000000
--- a/panels/wacom/wacom-stylus.svg
+++ /dev/null
@@ -1,124 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   id="svg86343"
-   version="1.1"
-   inkscape:version="0.48.2 r9819"
-   width="148"
-   height="192"
-   sodipodi:docname="wacom-stylus.svg">
-  <metadata
-     id="metadata86349">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs86347" />
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1280"
-     inkscape:window-height="742"
-     id="namedview86345"
-     showgrid="false"
-     inkscape:snap-nodes="false"
-     inkscape:snap-bbox="true"
-     inkscape:zoom="7"
-     inkscape:cx="93.888956"
-     inkscape:cy="186.10424"
-     inkscape:window-x="0"
-     inkscape:window-y="26"
-     inkscape:window-maximized="1"
-     inkscape:current-layer="svg86343"
-     borderlayer="true"
-     inkscape:showpageshadow="false">
-    <inkscape:grid
-       type="xygrid"
-       id="grid86802"
-       empspacing="5"
-       visible="true"
-       enabled="true"
-       snapvisiblegridlinesonly="true" />
-  </sodipodi:namedview>
-  <g
-     style="display:inline"
-     transform="translate(592.43375,-287.62088)"
-     id="g10545">
-    <path
-       sodipodi:nodetypes="sscsscscccccccccccccscsscsss"
-       inkscape:connector-curvature="0"
-       id="rect10526"
-       transform="translate(-928.4063,-95.84375)"
-       d="m 349.69531,384.96463 c -2.3083,0 -3.2326,1.49535 -3.69531,4.51323 L 345.53125,396 344.125,396 c -1.9944,0 -3.59375,1.59935 -3.59375,3.59375 L 340.53125,516 338,545.125 c -0.1873,2.15512 1.62589,3.92035 3.75,4.125 l 4.625,10.90625 1.53125,0 0,2.15625 3.61536,8.57242 1.18546,0.0214 0.44918,3.78119 0.33938,-3.7414 1.14797,-0.0687 3.76265,-8.53366 0,-2.1875 1.53125,0 4.65625,-10.96875 c 1.96694,-0.35188 3.54637,-2.02216 3.40625,-4.0625 L 365.53125,516 l 0,-116.40625 c 0,-1.9944 -1.59935,-3.59375 -3.59375,-3.59375 l -1.40625,0 L 360,389.47786 c -0.23272,-2.85711 -1.26201,-4.51323 -3.69531,-4.51323 z"
-       style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
-    <rect
-       style="color:#000000;fill:#eeeeec;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-       id="rect10541"
-       width="8.75"
-       height="22"
-       x="-579.65631"
-       y="385.90625"
-       rx="3.25"
-       ry="3.25" />
-    <rect
-       ry="3.2500002"
-       rx="3.25"
-       y="410.90625"
-       x="-579.65631"
-       height="12.25"
-       width="8.75"
-       id="rect10543"
-       style="color:#000000;fill:#eeeeec;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
-  </g>
-  <g
-     style="opacity:0.2;display:inline"
-     id="g10631"
-     transform="translate(592.43375,-302.48416)">
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 357.25,492.91161 35.28033,0 0,-52.14286 82.46967,0"
-       id="path10552"
-       inkscape:connector-curvature="0"
-       transform="translate(-928.4063,-79.84375)"
-       sodipodi:nodetypes="cccc" />
-    <path
-       sodipodi:nodetypes="cccc"
-       inkscape:connector-curvature="0"
-       id="path10556"
-       d="m -568.1563,309.03125 32.25,0 0,14.85714 82.5,0"
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m -575.4063,492.06786 39.53033,0 0,-48.14286 82.46967,0"
-       id="path10629"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cccc" />
-    <path
-       sodipodi:nodetypes="cccc"
-       inkscape:connector-curvature="0"
-       id="path86913"
-       d="m -571.1563,430.06786 48.28033,0 0,-27.14286 69.46967,0"
-       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
-  </g>
-</svg>
diff --git a/panels/wacom/wacom-tablet-cintiq.svg b/panels/wacom/wacom-tablet-cintiq.svg
deleted file mode 100644
index e9ae5c3..0000000
--- a/panels/wacom/wacom-tablet-cintiq.svg
+++ /dev/null
@@ -1,83 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   id="svg86858"
-   version="1.1"
-   inkscape:version="0.48.1 r9760"
-   width="148"
-   height="95"
-   sodipodi:docname="wacom-tablet-cintiq.svg">
-  <metadata
-     id="metadata86864">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs86862" />
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1199"
-     inkscape:window-height="807"
-     id="namedview86860"
-     showgrid="false"
-     borderlayer="true"
-     inkscape:showpageshadow="false"
-     inkscape:zoom="1"
-     inkscape:cx="-123.95096"
-     inkscape:cy="-15.993957"
-     inkscape:window-x="2858"
-     inkscape:window-y="395"
-     inkscape:window-maximized="0"
-     inkscape:current-layer="svg86858"
-     inkscape:snap-nodes="false"
-     inkscape:snap-bbox="true">
-    <inkscape:grid
-       type="xygrid"
-       id="grid86892"
-       empspacing="5"
-       visible="true"
-       enabled="true"
-       snapvisiblegridlinesonly="true" />
-  </sodipodi:namedview>
-  <g
-     style="display:inline;enable-background:new"
-     transform="matrix(0.68936116,0,0,0.68936115,465.30952,-75.491812)"
-     id="g4353-3">
-    <path
-       inkscape:connector-curvature="0"
-       style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1.45061844px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-       d="m 191,253 0,122 30.45602,0 0,10 20.32523,0 0,-10 65.25887,0 0,10 20.4159,0 0,-10 31.81597,0 0,-122 z"
-       transform="translate(-860.90625,-139.8605)"
-       id="rect22528"
-       sodipodi:nodetypes="ccccccccccccc" />
-    <rect
-       style="opacity:1;color:#000000;fill:#babdb6;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1.45061835000000006;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-       id="rect4133-4"
-       width="126.20383"
-       height="79.784019"
-       x="-649.60083"
-       y="130.54378" />
-  </g>
-</svg>
diff --git a/panels/wacom/wacom-tablet-pc.svg b/panels/wacom/wacom-tablet-pc.svg
deleted file mode 100644
index 091b9b1..0000000
--- a/panels/wacom/wacom-tablet-pc.svg
+++ /dev/null
@@ -1,77 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   id="svg86858"
-   version="1.1"
-   inkscape:version="0.48.1 r9760"
-   width="148"
-   height="95"
-   sodipodi:docname="wacom-tablet-pc.svg">
-  <metadata
-     id="metadata86864">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs86862" />
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1199"
-     inkscape:window-height="807"
-     id="namedview86860"
-     showgrid="false"
-     borderlayer="true"
-     inkscape:showpageshadow="false"
-     inkscape:zoom="1"
-     inkscape:cx="218.7114"
-     inkscape:cy="-21.332194"
-     inkscape:window-x="1873"
-     inkscape:window-y="310"
-     inkscape:window-maximized="0"
-     inkscape:current-layer="svg86858"
-     inkscape:snap-nodes="false"
-     inkscape:snap-bbox="true">
-    <inkscape:grid
-       type="xygrid"
-       id="grid86892"
-       empspacing="5"
-       visible="true"
-       enabled="true"
-       snapvisiblegridlinesonly="true" />
-  </sodipodi:namedview>
-  <path
-     style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:0.99999994000000003px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-     d="m 17.536356,5.4999999 0,59.7141961 -12.9738561,25.238058 115.6736201,0 -14.68849,-26.666627 -0.012,-58.2856271 z"
-     id="rect22528"
-     inkscape:connector-curvature="0"
-     sodipodi:nodetypes="ccccccc" />
-  <rect
-     y="14.5"
-     x="28.499998"
-     height="42"
-     width="66"
-     id="rect4133-4"
-     style="opacity:1;color:#000000;fill:#babdb6;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:0.99999994000000003;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
-</svg>
diff --git a/panels/wacom/wacom-tablet.svg b/panels/wacom/wacom-tablet.svg
deleted file mode 100644
index 35e5a4b..0000000
--- a/panels/wacom/wacom-tablet.svg
+++ /dev/null
@@ -1,81 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   id="svg86858"
-   version="1.1"
-   inkscape:version="0.48.1 r9760"
-   width="148"
-   height="95"
-   sodipodi:docname="wacom-tablet.svg">
-  <metadata
-     id="metadata86864">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs86862" />
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1199"
-     inkscape:window-height="807"
-     id="namedview86860"
-     showgrid="false"
-     borderlayer="true"
-     inkscape:showpageshadow="false"
-     inkscape:zoom="1.4142136"
-     inkscape:cx="42.197473"
-     inkscape:cy="89.570991"
-     inkscape:window-x="1873"
-     inkscape:window-y="310"
-     inkscape:window-maximized="0"
-     inkscape:current-layer="g4353-0">
-    <inkscape:grid
-       type="xygrid"
-       id="grid86892"
-       empspacing="5"
-       visible="true"
-       enabled="true"
-       snapvisiblegridlinesonly="true" />
-  </sodipodi:namedview>
-  <g
-     style="display:inline"
-     transform="matrix(0.59415025,0,0,0.67531282,405.44733,-74.059104)"
-     id="g4353-0">
-    <path
-       style="fill:#d3d7cf;fill-opacity:1;stroke:#babdb6;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="M 4.2812501,3.375 3.53125,85.5 C 31.076436,90.740667 83.579166,92.281216 115,85.5 L 114.25,3.375 z"
-       transform="matrix(1.683076,0,0,1.4807952,-682.39865,109.66637)"
-       id="path3568-6"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="ccccc" />
-    <rect
-       style="color:#000000;fill:#babdb6;fill-opacity:1;fill-rule:nonzero;stroke:#babdb6;stroke-width:1.57869899;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-       id="rect10889"
-       width="138.6996"
-       height="82.952255"
-       x="-651.99988"
-       y="129.88136" />
-  </g>
-</svg>
diff --git a/panels/wacom/wacom.gresource.xml b/panels/wacom/wacom.gresource.xml
deleted file mode 100644
index 7d46190..0000000
--- a/panels/wacom/wacom.gresource.xml
+++ /dev/null
@@ -1,16 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<gresources>
-  <gresource prefix="/org/gnome/control-center/wacom">
-    <file preprocess="xml-stripblanks">gnome-wacom-properties.ui</file>
-    <file preprocess="xml-stripblanks">wacom-stylus-page.ui</file>
-    <file preprocess="xml-stripblanks">button-mapping.ui</file>
-    <file>wacom-tablet.svg</file>
-    <file>wacom-stylus.svg</file>
-    <file>wacom-stylus-airbrush.svg</file>
-    <file>wacom-stylus-inking.svg</file>
-    <file>wacom-stylus-art-pen.svg</file>
-    <file>wacom-stylus-classic.svg</file>
-    <file>wacom-tablet-cintiq.svg</file>
-    <file>wacom-tablet-pc.svg</file>
-  </gresource>
-</gresources>
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 1aa623d..9d8b46e 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -114,16 +114,6 @@ panels/user-accounts/um-photo-dialog.c
 panels/user-accounts/um-realm-manager.c
 panels/user-accounts/um-user-panel.c
 panels/user-accounts/um-utils.c
-[type: gettext/glade]panels/wacom/button-mapping.ui
-panels/wacom/calibrator/gui_gtk.c
-panels/wacom/cc-wacom-mapping-panel.c
-panels/wacom/cc-wacom-nav-button.c
-panels/wacom/cc-wacom-page.c
-panels/wacom/cc-wacom-stylus-page.c
-panels/wacom/unity-wacom-panel.desktop.in.in
-[type: gettext/glade]panels/wacom/gnome-wacom-properties.ui
-panels/wacom/gsd-wacom-device.c
-[type: gettext/glade]panels/wacom/wacom-stylus-page.ui
 shell/cc-shell-nav-bar.c
 shell/control-center.c
 shell/unity-control-center.desktop.in.in
diff --git a/po/POTFILES.skip b/po/POTFILES.skip
index 92a9d3c..185f06e 100644
--- a/po/POTFILES.skip
+++ b/po/POTFILES.skip
@@ -18,5 +18,4 @@ panels/sound/gvc/gvc-mixer-control.c
 panels/universal-access/gnome-universal-access-panel.desktop.in
 panels/user-accounts/data/gnome-user-accounts-panel.desktop.in
 panels/user-accounts/fingerprint-strings.h
-panels/wacom/gnome-wacom-panel.desktop.in
 shell/gnome-control-center.desktop.in
-- 
1.9.2

